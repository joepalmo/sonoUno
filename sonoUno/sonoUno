#!/usr/bin python3
# -*- coding: utf-8 -*-
#--------------------------------------------------------------------------------------
#
#--------------------------------------------------------------------------------------

#Se agrega el script de la GUI para probar el ejecutable de MAC
import wx
import wx.stc
import wx.xrc
import wx.grid
from wx import py
import matplotlib
matplotlib.use('WXAgg')
from matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas
from matplotlib.figure import Figure

import platform
import numpy as np
from weakref import ref
import math
#import os
import pandas as pd
from wx.lib import dialogs
#from oct2py import octave
import oct2py
import re
import webbrowser

#import gui.frame_design as gui
#from gui.frame_design import DataTable
from data_import.data_import import DataImport
from sound_module.simple_sound import simpleSound
from data_export.data_export import DataExport
from data_transform.predef_math_functions import PredefMathFunctions

EVEN_ROW_COLOUR = '#CCE6FF'
GRID_LINE_COLOUR = '#ccc'

#class core (gui.FrameDesign):
class core (wx.Frame):
    def __init__(self):
    
        #Se agrega todo el init de la GUI
        """
        This class generate the framework of the software using wxPython. This
        is only the design, the functionalities are programmed in sonouno.py
        """
        # Create principal frame
        wx.Frame.__init__(self,
            parent = None,
            id = -1,
            title = u'SonoUno',
            pos = (1, 1),
            size=(850, 550),
            style = (wx.CAPTION | wx.DEFAULT_FRAME_STYLE | wx.SYSTEM_MENU
                | wx.TAB_TRAVERSAL)
            )
        self.SetSizeHints(wx.DefaultSize, wx.DefaultSize)
        # Create the menu bar
        self._createmenubar()
        # Create status bar
        self._statusbar = self.CreateStatusBar(
            number = 1,
            style = 0,
            id = wx.ID_ANY,
            name = 'Status Bar'
            )
        self._statusbar.SetStatusText('')
        # Create the principal sizer
        _mainsizer = wx.BoxSizer(wx.VERTICAL)
        # Create the main panel, this panel contain scroll bars.
        self._mainscrolledwindow = wx.ScrolledWindow(
            parent = self,
            id = wx.ID_ANY,
            pos = wx.DefaultPosition,
            size = wx.DefaultSize,
            style = wx.HSCROLL | wx.VSCROLL | wx.TAB_TRAVERSAL,
            name = 'Principal scrolled window.'
            )
        self._mainscrolledwindow.SetScrollRate(5, 5)
        # Create the sizer of _mainscrolledwindow -> row(1) col(2),
        # divided in left and right. The right column is growable.
        _mainfgsizer = wx.FlexGridSizer(
            rows = 1,
            cols = 2,
            vgap = 0,
            hgap = 0
            )
        _mainfgsizer.AddGrowableCol(1)
        _mainfgsizer.AddGrowableRow(0)
        _mainfgsizer.SetFlexibleDirection(wx.BOTH)

        # Create the left panel with its sizer -> row(2) cols(1).
        self._leftpanel = wx.Panel(
            parent = self._mainscrolledwindow,
            id = wx.ID_ANY,
            pos = wx.DefaultPosition,
            size = wx.DefaultSize,
            style = wx.TAB_TRAVERSAL,
            name = 'Left panel contain file and configurations \
                functionalities.'
            )
        _mainleftsizer = wx.FlexGridSizer(
            rows = 2,
            cols = 1,
            vgap = 0,
            hgap = 0
            )
        _mainleftsizer.SetFlexibleDirection(wx.BOTH)
        # Create the file panel with its own method.
        self._filepanel = self._createfilepanel(self._leftpanel)
        _mainleftsizer.Add(
            window = self._filepanel,
            proportion = 1,
            flag = wx.EXPAND | wx.ALL,
            border = 5
            )
        self._filepanel.Hide()
        # Create the configuration panel with its own method.
        self._congifpanel = self._createconfigpanel(self._leftpanel)
        _mainleftsizer.Add(
            window = self._congifpanel,
            proportion = 1,
            flag = wx.EXPAND | wx.ALL,
            border = 5
            )
        self._congifpanel.Hide()
        self._leftpanel.SetSizer(_mainleftsizer)
        self._leftpanel.Layout()
        _mainleftsizer.Fit(self._leftpanel)
        _mainfgsizer.Add(
            window = self._leftpanel,
            proportion = 1,
            flag = wx.EXPAND | wx.ALL,
            border = 5
            )

        # Create the right panel with its sizer -> row(2) col(1),
        # the first box is growable.
        self._rightpanel = wx.Panel(
            parent = self._mainscrolledwindow,
            id = wx.ID_ANY,
            pos = wx.DefaultPosition,
            size = wx.DefaultSize,
            style = wx.TAB_TRAVERSAL,
            name = 'Right panel contain the plot, display functionalities,\
                octave and predefined mathematical functions.'
            )
        self._mainrightsizer = wx.FlexGridSizer(
            rows = 2,
            cols = 1,
            vgap = 0,
            hgap = 0
            )
        self._mainrightsizer.AddGrowableCol(0)
        self._mainrightsizer.AddGrowableRow(0)
        self._mainrightsizer.SetFlexibleDirection(wx.BOTH)
        # Create the display panel
        self._displaypanel = self._createdisplaypanel(self._rightpanel)
        self._mainrightsizer.Add(
            window = self._displaypanel,
            proportion = 1,
            flag = wx.EXPAND | wx.ALL,
            border = 5
            )
        # Create the operation panel
        self._operationpanel = self._createoperationpanel(self._rightpanel)
        self._mainrightsizer.Add(
            window = self._operationpanel,
            proportion = 1,
            flag = wx.ALL | wx.EXPAND,
            border = 5
            )
        #self._operationpanel.Hide()
        self._rightpanel.SetSizer(self._mainrightsizer)
        self._rightpanel.Layout()
        self._mainrightsizer.Fit(self._rightpanel)
        _mainfgsizer.Add(
            self._rightpanel,
            1,
            wx.EXPAND | wx.ALL,
            5
            )

        self._mainscrolledwindow.SetSizer(_mainfgsizer)
        self._mainscrolledwindow.Layout()
        _mainfgsizer.Fit(self._mainscrolledwindow)
        _mainsizer.Add(
            window = self._mainscrolledwindow,
            proportion = 1,
            flag = wx.EXPAND | wx.ALL,
            border = 5
            )
        self.SetSizer(_mainsizer)
        self.Layout()
        self.Centre(wx.BOTH)

        # Create the shortcut key table, here the buttons and functions not
        # set on the menu bar can be added.
        # self.shortcuttable = wx.AcceleratorTable(
        #     [(wx.ACCEL_NORMAL, wx.WXK_SPACE, self._playmenuitem.GetId())]
        #     )
        # self.SetAcceleratorTable(self.shortcuttable)
        #This are commented, we decide change the shortcut
    
        #clase de la cual hereda
        #gui.FrameDesign.__init__(self)
        #instancias de clases
        self._expData = DataExport()
        self._openData = DataImport()
        self._dataSound = simpleSound()
        self._matFc = PredefMathFunctions()
        #evento timer
        self._timer = wx.Timer(self)
        self.Bind(wx.EVT_TIMER, self._sonoPlot, self._timer)
        self._timer_envelope = wx.Timer(self)
        self.Bind(wx.EVT_TIMER, self._playenvelope_event, self._timer_envelope)
        #se genera una asignación de variable porque se utiliza mucho en esta clase.
        self.panel = self._axes

        try:
            self._pythonShell.Execute("from oct2py import octave")
            self.octaveStatus = True
            self._pythonShell.Execute("self._pythonShell.clear()")
        except Exception as e:
            self.octaveStatus = False
            wx.MessageBox('Problems importing octave library.','Info', wx.OK | wx.ICON_INFORMATION)
            self._expData.writeexception(e)

        #Se genera un diccionario para la línea de comandos
        self.command_dict_withoutparam = {
            'open':self.openMethod,
            'dellastmark':self.deleteLastMark,
            'delallmarks':self.deleteAllMark,
            'delallmark':self.deleteAllMark,
            'savedata':self.saveData,
            'savemarks':self.saveMarks,
            'savemark':self.saveMarks,
            'saveplot':self.savePlot,
            'quit':self.Close,
            'exit':self.Close,
            'play':self.playMethod,
            'pause':self.playMethod,
            'stop':self.stopMethod,
            'markpoint':self.markPoints,
            'originaldata':self.originaldata_command,
            'xlastcut':self.xlastcut_command,
            'inverse_mf':self.inverse_command,
            'square_mf':self.square_command,
            'squareroot_mf':self.squareroot_command,
            'logarithm_mf':self.logarithm_command
            }

        self.command_dict_withparam = {
            'xposition':self.xposition_command,
            'tempo':self.selecttempo_command,
            'xlowerlimit':self.xlowerlimit_command,
            'xupperlimit':self.xupperlimit_command,
            'octave':self._octaveInput_command,
            'fromoctave':self._retrieveFromOctave_command
            }

        #we don't add soundFonts for now
        #self._sFontLabel = 'gm'
        # try:
        #     if platform.system() == 'Windows':
        #         self._sFontChoice = "soundModule\soundFont\FluidR3_GM.sf2"
        #     else:
        #         if platform.system() == 'Linux':
        #             self._sFontChoice = "soundModule/soundFont/FluidR3_GM.sf2"
        #         else:
        #             if platform.system() == 'Darwin':
        #                 self._sFontChoice = "soundModule/soundFont/FluidR3_GM.sf2"
        #             else:
        #                 self._expData.writeinfo("The operative system is unknown, the software can't set the sound font.")
        # except Exception as e:
        #     self._expData.writeexception(e)
#        try:
#            self._sFontTextCtrl.SetLabel("General MIDI")
#        except Exception as e:
#            self._expData.writeexception(e)
        #self._soundFontChoice()
        #try:
            #self._dataSound.reproductor.openMidi(self._sFontChoice)
        #except Exception as e:
        #    self._expData.writeexception(e)

        #Variables globales de estado
        self._lineExist = False
        self._plotCounter = 0
        self._fileSaved = False
        self._firstOpen = False
        self._xOctChange = False
        self._yOctChange = False
        self.limitDataToLoad = 101
        self.dataUpdateToOctave = False
        self.inverseFunc = False
        self.cont = 0

        #Variables globales con set y get
        self.setXActual(np.array(None))
        self.setYActual(np.array(None))
        self._setXOrigin(np.array(None))
        self._setYOrigin(np.array(None))
        self._setXOctave(np.array(None))
        self._setYOctave(np.array(None))
        self._setTimerIndex(0)
        self._settimerenvelopeindex(0)
        self._setVelocity(50)
        self._soundVelSlider.SetValue(50)
        self._askPoints = True

        array = np.array([0,1])
        index = [i for i in range(0, len(array))]
        self._setxPoints(np.delete(array,index))
        self._setyPoints(np.delete(array,index))

        self._setMatSelection("Original")
        self._setavNPoints(1)
        self._setMarkerStyleIndex(22)
        self._setLineChar('')
        self._setMarkerChar('')
        self._setColorChar('b')
        self._set_soundwaveformlist()
        self._set_waveformnumber(1)
        self._swaveformlistbox.InsertItems(self._get_soundwaveformlist(), 0)

        self._setGridColor("Black")
        self._setGridLinestyle("Dashed line")
        self._setGridLinewidth(0.5)

        self._setXLabel('')
        self._setYLabel('')
        self._setXName('')
        self._setYName('')

        self._setDataFrame(None)

        self.originaldataselected = True

        #Setting special sound config
        adrs = self._dataSound.reproductor.get_adsr()
        #Set the sliders and labels and the plot
        self._soundattackslider.SetValue(adrs['a']*100)
        self._actualattacktextctrl.SetValue(str(adrs['a']))
        self._sounddecayslider.SetValue(adrs['d']*100)
        self._actualdecaytextctrl.SetValue(str(adrs['d']))
        self._soundreleaseslider.SetValue(adrs['r']*100)
        self._actualreleasetextctrl.SetValue(str(adrs['r']))
        self._soundsustainslider.SetValue(adrs['s'])
        self._actualsustaintextctrl.SetValue(str(adrs['s']))

        self.setsoundattack(adrs['a'])
        self.setsounddecay(adrs['d'])
        self.setsoundsustain(adrs['s'])
        self.setsoundrelease(adrs['r'])

        self.plotsoundenvelope()

#Se agregan todos los metodos de disenio de la GUI
    def _createmenubar(self):

        """
        This method design the sonouno menu bar, this bar contain 6 items:
        File, Data display, Data operations, Panels, Setting and Help.
        """
        # Create the menuBar
        self._menubar = wx.MenuBar(style = 0)
        # Create the menu item File
        self._menufile = wx.Menu()
        # Create the menu item open and append it to file menu
        self._openmenuitem = wx.MenuItem(
            parentMenu = self._menufile,
            id = wx.ID_ANY,
            text = ('&Open' + '\t' + 'Ctrl+Alt+O'),
            helpString = ('Open a window where you can search the data file '
                + 'on the operative system.'),
            kind = wx.ITEM_NORMAL
            )
        self._menufile.Append(self._openmenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventopen,
            id = self._openmenuitem.GetId()
            )
        # Create the delete all marks menu item and append it to file menu
        self._deleteallmarksmenuitem = wx.MenuItem(
            parentMenu = self._menufile,
            id = wx.ID_ANY,
            text = ('D&elete all marks' + '\t' + 'Ctrl+Alt+E'),
            helpString = ('Delete all the marks on the data without save.'),
            kind = wx.ITEM_NORMAL
            )
        self._menufile.Append(self._deleteallmarksmenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventdeleteallmark,
            id = self._deleteallmarksmenuitem.GetId()
            )
        # Create the submenu save
        self._savesubmenu = wx.Menu()
        # Create the save data menu item and append it to save submenu
        self._savedatamenuitem = wx.MenuItem(
            parentMenu = self._savesubmenu,
            id = wx.ID_ANY,
            text = ('S&ave Data' + '\t' + 'Ctrl+Alt+A'),
            helpString = ('Save the data with the modifications done by the '
                + 'user.'),
            kind = wx.ITEM_NORMAL
            )
        self._savesubmenu.Append(self._savedatamenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventsavedata,
            id = self._savedatamenuitem.GetId()
            )
        #Create the save marks menu item and append it to save submenu
        self._savemarksmenuitem = wx.MenuItem(
            parentMenu = self._savesubmenu,
            id = wx.ID_ANY,
            text = ('Save &Marks' + '\t' + 'Ctrl+Alt+M'),
            helpString = ('Save the marks made by the user.'),
            kind = wx.ITEM_NORMAL
            )
        self._savesubmenu.Append(self._savemarksmenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventsavemarks,
            id = self._savemarksmenuitem.GetId()
            )
        # Create the save sound menu item and append it to save submenu
        self._savesoundmenuitem = wx.MenuItem(
            parentMenu = self._savesubmenu,
            id = wx.ID_ANY,
            text = ('Save &Sound' + '\t' + 'Ctrl+Alt+S'),
            helpString = ('Save the sound performed with the data opened.'),
            kind = wx.ITEM_NORMAL
            )
        self._savesubmenu.Append(self._savesoundmenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventsavesound,
            id = self._savesoundmenuitem.GetId()
            )
        # Create the save plot menu item and append it to save submenu
        self._saveplotmenuitem = wx.MenuItem(
            parentMenu = self._savesubmenu,
            id = wx.ID_ANY,
            text = ('Save &Plot' + '\t' + 'Ctrl+Alt+P'),
            helpString = ('Save the plot performed with the data opened.'),
            kind = wx.ITEM_NORMAL
            )
        self._savesubmenu.Append(self._saveplotmenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventsaveplot,
            id = self._saveplotmenuitem.GetId()
            )
        # Append the save submenu to the file menu
        self._menufile.AppendSubMenu(
            submenu = self._savesubmenu,
            text = 'Save',
            help = ('Show the things you can save on the application.')
            )
        # Create the close item Close and append it to file menu
        self._closemenuitem = wx.MenuItem(
            parentMenu = self._menufile,
            id = wx.ID_ANY,
            text = ('&Quit' + '\t' + 'Ctrl+Alt+Q'),
            helpString = ('Close the application.'),
            kind = wx.ITEM_NORMAL
            )
        self._menufile.Append(self._closemenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._onclose,
            id = self._closemenuitem.GetId()
            )
        self.Bind(
            event = wx.EVT_CLOSE,
            handler = self._eventclose
            )
        # Append file menu to menu bar
        self._menubar.Append(
            menu = self._menufile,
            title = 'File'
            )

        # Create data display menu
        self._menudisplay = wx.Menu()
        # Create the abscissa position menu item and append it to data
        # display menu
        self._absposmenuitem = wx.MenuItem(
            parentMenu = self._menudisplay,
            id = wx.ID_ANY,
            text = ('Abscissa Position (&x)' + '\t' + 'Alt+Shift+X'),
            helpString = ('Set the keyboard focus on the abscissa slider '
                + 'text label.'),
            kind = wx.ITEM_NORMAL
            )
        self._menudisplay.Append(self._absposmenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventabsposselect,
            id = self._absposmenuitem.GetId()
            )
        # Create the tempo menu item and append it to data display menu
        self._tempomenuitem = wx.MenuItem(
            parentMenu = self._menudisplay,
            id = wx.ID_ANY,
            text = ('&Tempo' + '\t' + 'Alt+Shift+T'),
            helpString = ('Set the keyboard focus on the tempo slider text '
                + 'label.'),
            kind = wx.ITEM_NORMAL
            )
        self._menudisplay.Append(self._tempomenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventtemposelect,
            id = self._tempomenuitem.GetId()
            )
        # Create the play menu item and append it to data display menu
        self._playmenuitem = wx.MenuItem(
            parentMenu = self._menudisplay,
            id = wx.ID_ANY,
            text = ('Play' + '\t' + 'Alt+Shift+P'),
            helpString = ('Start the reproduction of the sonifyed data.'),
            kind = wx.ITEM_CHECK
            )
        self._menudisplay.Append(self._playmenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventplay,
            id = self._playmenuitem.GetId()
            )
        # Create the stop menu item and append it to data display menu
        self._stopmenuitem = wx.MenuItem(
            parentMenu = self._menudisplay,
            id = wx.ID_ANY,
            text = ('&Stop' + '\t' + 'Alt+Shift+S'),
            helpString = ('Stop the sound.'),
            kind = wx.ITEM_NORMAL
            )
        self._menudisplay.Append(self._stopmenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventstop,
            id = self._stopmenuitem.GetId()
            )
        # Create the mark point menu item and append it to data display menu
        self._markmenuitem = wx.MenuItem(
            parentMenu = self._menudisplay,
            id = wx.ID_ANY,
            text = ('&Mark Point' + '\t' + 'Alt+Shift+M'),
            helpString = ('Mark a point on the current position of the data.'),
            kind = wx.ITEM_NORMAL
            )
        self._menudisplay.Append(self._markmenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventmarkpoint,
            id = self._markmenuitem.GetId()
            )
        # Create the delete last mark menu item and append it to data display
        # menu.
        self._deletelastmarkmenuitem = wx.MenuItem(
            parentMenu = self._menudisplay,
            id = wx.ID_ANY,
            text = ('&Delete last mark' + '\t' + 'Alt+Shift+D'),
            helpString = ('Delete the last mark plotted on the data.'),
            kind = wx.ITEM_NORMAL
            )
        self._menudisplay.Append(self._deletelastmarkmenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventdeletelastmark,
            id = self._deletelastmarkmenuitem.GetId()
            )
        # Append the data display menu to the menu bar
        self._menubar.Append(
            menu = self._menudisplay,
            title = 'Data Display'
            )

        # Create the data operations menu
        self._menudataop = wx.Menu()
        # # Create the vertical limit submenu
        # self._vertlimitsubmenu = wx.Menu()
        # # Create the lower limit menu item and append it to vertical limit
        # # submenu
        # self._vlowerlimitmenuitem = wx.MenuItem(
        #     parentMenu = self._vertlimitsubmenu,
        #     id = wx.ID_ANY,
        #     text = ('Lower Limit' + '\t' + 'Alt+Shift+V'),
        #     helpString = ('Set the focus keyboard on the text label of'
        #         + ' lower vertical limit slider.'),
        #     kind = wx.ITEM_NORMAL
        #     )
        # self._vertlimitsubmenu.Append(self._vlowerlimitmenuitem)
        # self.Bind(
        #     event = wx.EVT_MENU,
        #     handler = self._eventvlowerlimitselect,
        #     id = self._vlowerlimitmenuitem.GetId()
        #     )
        # # Create the upper limit menu item and append it to vertical limit
        # # submenu
        # self._vupperlimitmenuitem = wx.MenuItem(
        #     parentMenu = self._vertlimitsubmenu,
        #     id = wx.ID_ANY,
        #     text = ('Upper Limit' + '\t' + 'Alt+Shift+V'),
        #     helpString = ('Set focus keyboard on the text label of upper '
        #         + 'vertical limit slider.'),
        #     kind = wx.ITEM_NORMAL
        #     )
        # self._vertlimitsubmenu.Append(self._vupperlimitmenuitem)
        # self.Bind(
        #     event = wx.EVT_MENU,
        #     handler = self._eventvupperlimitselect,
        #     id = self._vupperlimitmenuitem.GetId()
        #     )
        # # Append vertical limit submenu to data operations menu
        # self._menudataop.AppendSubMenu(
        #     menu = self._vertlimitsubmenu,
        #     title = 'Vertical Limit',
        #     help = 'Show the vertical limits items.'
        #     )
        # Create horizontal limit submenu
        self._horilimitsubmenu = wx.Menu()
        # Create the lower limit menu item and append it to horizontal limit
        # submenu
        self._hlowerlimitmenuitem = wx.MenuItem(
            parentMenu = self._horilimitsubmenu,
            id = wx.ID_ANY,
            text = ('Lower Limit' + '\t' + 'Alt+Shift+H'),
            helpString = ('Set focus keyboard on the text label of lower'
                + ' horizontal limit slider.'),
            kind = wx.ITEM_NORMAL
            )
        self._horilimitsubmenu.Append(self._hlowerlimitmenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventhlowerlimitselect,
            id = self._hlowerlimitmenuitem.GetId()
            )
        # Create the upper limit menu item and append it to horizontal limit
        # submenu
        self._hupperlimitmenuitem = wx.MenuItem(
            parentMenu = self._horilimitsubmenu,
            id = wx.ID_ANY,
            text = ('Upper Limit' + '\t' + 'Alt+Shift+H'),
            helpString = ('Set focus keyboard on the text label of upper '
                + 'horizontal limit slider'),
            kind = wx.ITEM_NORMAL
            )
        self._horilimitsubmenu.Append(self._hupperlimitmenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventhupperlimitselect,
            id = self._hupperlimitmenuitem.GetId()
            )
        # Append horizontal limit submenu to data operations menu
        self._menudataop.AppendSubMenu(
            submenu = self._horilimitsubmenu,
            text = 'Horizontal Limit',
            help = 'Show the horizontal limits items.'
            )
        # Create the mathematical functions submenu
        self._matfuncsubmenu = wx.Menu()
        # Create original menu item and append it to mathematical functions
        # submenu
        self._originalmfmenuitem = wx.MenuItem(
            parentMenu = self._matfuncsubmenu,
            id = wx.ID_ANY,
            text = ('&Original' + '\t' + 'Alt+Shift+O'),
            helpString = ('Plot the original data on the graph section.'),
            kind = wx.ITEM_NORMAL
            )
        self._matfuncsubmenu.Append(self._originalmfmenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventoriginalmf,
            id = self._originalmfmenuitem.GetId()
            )
        # Create last cut menu item and append it to mathematical functions
        # submenu.
        self._lastcutmfmenuitem = wx.MenuItem(
            parentMenu = self._matfuncsubmenu,
            id = wx.ID_ANY,
            text = ('Previous &Cut' + '\t' + 'Alt+Shift+C'),
            helpString = ('Plot the previous cutted data on the graph '
                + 'section.'),
            kind = wx.ITEM_NORMAL
            )
        self._matfuncsubmenu.Append(self._lastcutmfmenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventlastcutmf,
            id = self._lastcutmfmenuitem.GetId()
            )
        # Create the inverse menu item and append it to mathematical functions
        # submenu
        self._inversemfmenuitem = wx.MenuItem(
            parentMenu = self._matfuncsubmenu,
            id = wx.ID_ANY,
            text = ('&Inverse' + '\t' + 'Alt+Shift+I'),
            helpString = 'Invert the y axis on the plot.',
            kind = wx.ITEM_NORMAL
            )
        self._matfuncsubmenu.Append(self._inversemfmenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventinversemf,
            id = self._inversemfmenuitem.GetId()
            )
        # Create the square menu item and append it to mathematical functions
        # submenu
        self._squaremfmenuitem = wx.MenuItem(
            parentMenu = self._matfuncsubmenu,
            id = wx.ID_ANY,
            text = ('Square'+ '\t' + 'Alt+Shift+2'),
            helpString = ('Perform the square function to the data and plot '
                + 'the results on the graph section.'),
            kind = wx.ITEM_NORMAL
            )
        self._matfuncsubmenu.Append(self._squaremfmenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventsquaremf,
            id = self._squaremfmenuitem.GetId()
            )
        # Create the square root menu item and append it to mathematical
        # functions submenu
        self._squarerootmfmenuitem = wx.MenuItem(
            parentMenu = self._matfuncsubmenu,
            id = wx.ID_ANY,
            text = ('Square root' + '\t' + 'Alt+Shift+R'),
            helpString = ('Perform the square root function to the data and '
                + 'plot the results on the graph section.'),
            kind = wx.ITEM_NORMAL
            )
        self._matfuncsubmenu.Append(self._squarerootmfmenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventsquarerootmf,
            id = self._squarerootmfmenuitem.GetId()
            )
        # Create the logarithm menu item and append it to mathematical
        # functions submenu
        self._logmfmenuitem = wx.MenuItem(
            parentMenu = self._matfuncsubmenu,
            id = wx.ID_ANY,
            text = ('Logarithm' + '\t' + 'Alt+Shift+L'),
            helpString = ('Perform the logarithm function to the data and '
                + 'plot the results on the graph section.'),
            kind = wx.ITEM_NORMAL
            )
        self._matfuncsubmenu.Append(self._logmfmenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventlogmf,
            id = self._logmfmenuitem.GetId()
            )
        # Create the octave menu item and append it to mathematical functions
        # submenu
        self._octavemenuitem = wx.MenuItem(
            parentMenu = self._matfuncsubmenu,
            id = wx.ID_ANY,
            text = ('Octave' + '\t' + 'Alt+Shift+Y'),
            helpString = ('Enable the octave panel and set the keyboard focus '
                + 'on the octave commands text label.'),
            kind = wx.ITEM_NORMAL
            )
        self._matfuncsubmenu.Append(self._octavemenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventoctaveselect,
            id = self._octavemenuitem.GetId()
            )
        # Create the average submenu
        self._averagesubmenu = wx.Menu()
        # Create the number of points menu item and append it to average
        # submenu
        self._avnumpointmenuitem = wx.MenuItem(
            parentMenu = self._averagesubmenu,
            id = wx.ID_ANY,
            text = ('Number of points' + '\t' + 'Alt+Shift+N'),
            helpString = ('Enable the panel and the element to set the number'
                + ' of points to apply the average function.'),
            kind = wx.ITEM_NORMAL
            )
        self._averagesubmenu.Append(self._avnumpointmenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventavnumpointselect,
            id = self._avnumpointmenuitem.GetId()
            )
        # Create the apply average menu item and append it to average submenu
        self._averagemfmenuitem = wx.MenuItem(
            parentMenu = self._averagesubmenu,
            id = wx.ID_ANY,
            text = ('Apply average' + '\t' + 'Alt+Shift+A'),
            helpString = ('Enable the panel and the element to set the number'
                + ' of points to apply the average function.'),
            kind = wx.ITEM_NORMAL
            )
        self._averagesubmenu.Append(self._averagemfmenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventaveragemf,
            id = self._averagemfmenuitem.GetId()
            )
        # Append the average submenu to mathematical functions submenu
        self._matfuncsubmenu.AppendSubMenu(
            submenu = self._averagesubmenu,
            text = 'Average',
            help = ('Show the items to set the number of points and apply '
                + 'the average function.')
            )
        # Append the mathematical functions submenu to data operations menu.
        self._menudataop.AppendSubMenu(
            submenu = self._matfuncsubmenu,
            text = 'Mathematical Functions',
            help = ('Show the items to apply predefined mathematical '
                + 'functions.')
            )
        # Append the data operations menu to the menu bar
        self._menubar.Append(
            menu = self._menudataop,
            title = 'Data Operations'
            )
        # Create the panels menu
        self._menuconfigpanels = wx.Menu()
        # Create the file menu item and append it to panels menu
        self._cpfilemenuitem = wx.MenuItem(
            parentMenu = self._menuconfigpanels,
            id = wx.ID_ANY,
            text = ('File' + '\t' + 'Ctrl+Alt+F'),
            helpString = ('Enable the file panel, which contain the file menu'
                + ' elements.'),
            kind = wx.ITEM_CHECK
            )
        self._menuconfigpanels.Append(self._cpfilemenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventcpfileselect,
            id = self._cpfilemenuitem.GetId()
            )
        # Create the data display menu item and append it to panels menu
        self._cpdatadisplaymenuitem = wx.MenuItem(
            parentMenu = self._menuconfigpanels,
            id = wx.ID_ANY,
            text = ('Data Display' + '\t' + 'Ctrl+Alt+D'),
            helpString = ('Enable the display panel, which contain the plot '
                + 'and the reproduction buttons.'),
            kind = wx.ITEM_CHECK
            )
        self._menuconfigpanels.Append(self._cpdatadisplaymenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventcpdatadisplayselect,
            id = self._cpdatadisplaymenuitem.GetId()
            )
        self._cpdatadisplaymenuitem.Check(True)
        # Create the data parameters menu item and append it to panels menu
        self._cpdataparamplotmenuitem = wx.MenuItem(
            parentMenu = self._menuconfigpanels,
            id = wx.ID_ANY,
            text = ('Data Parameters' + '\t' + 'Alt+Shift+G'),
            helpString = ('Enable the data parameters panel.'),
            kind = wx.ITEM_CHECK
            )
        self._menuconfigpanels.Append(self._cpdataparamplotmenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventcpdataparamplot,
            id = self._cpdataparamplotmenuitem.GetId()
            )
        # Create data operations submenu
        self._cpdataopsubmenu = wx.Menu()
        # Create all data operations submenu and append it to data operations
        # submenu
        self._cpdataopmenuitem = wx.MenuItem(
            parentMenu = self._cpdataopsubmenu,
            id = wx.ID_ANY,
            text = ('All Data Operations'+ '\t' + 'Ctrl+Alt+T'),
            helpString = ('Enable the data operation panel, which contain '
                + 'octave, cut sliders and mathematical functions panels.'),
            kind = wx.ITEM_CHECK
            )
        self._cpdataopsubmenu.Append(self._cpdataopmenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventcpdataopselect,
            id = self._cpdataopmenuitem.GetId()
            )
        # Create write funtionalities menu item and append it to data operation submenu
        self._cpdo_writecommandmenuitem = wx.MenuItem(
            parentMenu = self._cpdataopsubmenu,
            id = wx.ID_ANY,
            text = ('Write functionalities' + '\t' + ''),
            helpString = 'Enable the write command panel.',
            kind = wx.ITEM_CHECK
            )
        self._cpdataopsubmenu.Append(self._cpdo_writecommandmenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventcpdo_writecommandselect,
            id = self._cpdo_writecommandmenuitem.GetId()
            )
        self._cpdo_writecommandmenuitem.Check(True)
        # Create octave menu item and append it to data operation submenu
        self._cpdooctavemenuitem = wx.MenuItem(
            parentMenu = self._cpdataopsubmenu,
            id = wx.ID_ANY,
            text = ('Octave' + '\t' + 'Alt+Shift+Y'),
            helpString = 'Enable the octave panel.',
            kind = wx.ITEM_CHECK
            )
        self._cpdataopsubmenu.Append(self._cpdooctavemenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventcpdooctaveselect,
            id = self._cpdooctavemenuitem.GetId()
            )
        # Create slider and mathematical functions menu item and append it to
        # data operations submenu
        self._cpdocutslidermenuitem = wx.MenuItem(
            parentMenu = self._cpdataopsubmenu,
            id = wx.ID_ANY,
            text = ('Sliders and Mathematical Functions' + '\t'
                + 'Ctrl+Alt+X'),
            helpString = ('Enable the cut sliders and mathematical functions '
                + 'panel.'),
            kind = wx.ITEM_CHECK
            )
        self._cpdataopsubmenu.Append(self._cpdocutslidermenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventcpdocutsliderselect,
            id = self._cpdocutslidermenuitem.GetId()
            )
        # Append data operation submenu to panels menu
        self._menuconfigpanels.AppendSubMenu(
            submenu = self._cpdataopsubmenu,
            text = 'Data Operations',
            help = 'Contain octave and mathematical functions panels items.'
            )
        # Create configuration submenu
        self._cpconfigsubmenu = wx.Menu()
        # Create all configurations menu item and append it to configuration
        # submenu
        self._cpcallmenuitem = wx.MenuItem(
            parentMenu = self._cpconfigsubmenu,
            id = wx.ID_ANY,
            text = ('All configurations' + '\t' + 'Ctrl+Alt+C'),
            helpString = 'Enable sound and plot configurations panels.',
            kind = wx.ITEM_CHECK
            )
        self._cpconfigsubmenu.Append(self._cpcallmenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventcpcallselect,
            id = self._cpcallmenuitem.GetId()
            )
        # Create sound configurations menu item and append it to configurations
        # submenu
        self._cpconfigsoundmenuitem = wx.MenuItem(
            parentMenu = self._cpconfigsubmenu,
            id = wx.ID_ANY,
            text = ('Sound Configurations' + '\t' + 'Ctrl+Alt+L'),
            helpString = 'Enable sound configurations panel.',
            kind = wx.ITEM_CHECK
            )
        self._cpconfigsubmenu.Append(self._cpconfigsoundmenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventcpconfigsoundselect,
            id = self._cpconfigsoundmenuitem.GetId()
            )
        # Create special sound configurations menu item and append it to
        # configurations submenu
        # self._cpspecialconfigsoundmenuitem = wx.MenuItem(
        #     parentMenu = self._cpconfigsubmenu,
        #     id = wx.ID_ANY,
        #     text = ('Special Sound Configurations' + '\t' + 'Ctrl+Alt+1'),
        #     helpString = 'Enable special sound configurations panel.',
        #     kind = wx.ITEM_CHECK
        #     )
        # self._cpconfigsubmenu.Append(self._cpspecialconfigsoundmenuitem)
        # self.Bind(
        #     event = wx.EVT_MENU,
        #     handler = self._eventSpecialSoundConfig,
        #     id = self._cpspecialconfigsoundmenuitem.GetId()
        #     )
        # Create plot configurations menu item and append it to configurations
        # submenu
        self._cpconfigplotmenuitem = wx.MenuItem(
            parentMenu = self._cpconfigsubmenu,
            id = wx.ID_ANY,
            text = ('Plot Configurations' + '\t' + 'Ctrl+Alt+G'),
            helpString = 'Enable plot configurations panel.',
            kind = wx.ITEM_CHECK
            )
        self._cpconfigsubmenu.Append(self._cpconfigplotmenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventcpconfigplotselect,
            id = self._cpconfigplotmenuitem.GetId()
            )
        # Create visual configurations menu item and append it to
        # configuration submenu (this part is not implemented yet)
        self._cpconfigvisualmenuitem = wx.MenuItem(
            parentMenu = self._cpconfigsubmenu,
            id = wx.ID_ANY,
            text = ('Visual configuratons' + '\t' + 'Ctrl+Alt+V'),
            helpString = 'Enable visual configurations panel.',
            kind = wx.ITEM_CHECK
            )
        # self._cpconfigsubmenu.Append(self._cpconfigvisualmenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventcpconfigvisualselect,
            id = self._cpconfigvisualmenuitem.GetId()
            )
        # Append configuration submenu to panels menu
        self._menuconfigpanels.AppendSubMenu(
            submenu = self._cpconfigsubmenu,
            text = 'Configuration',
            help = 'Contain sound and plot configurations items.'
            )
        # Append panels menu to menu bar
        self._menubar.Append(
            menu = self._menuconfigpanels,
            title = 'Panels'
            )

        # Create settings menu
        self._menusettings = wx.Menu()
        # Create sound submenu
        self._soundsubmenu = wx.Menu()
        # Create volume menu item and append it to sound submenu
        self._ssvolumemenuitem = wx.MenuItem(
            parentMenu = self._soundsubmenu,
            id = wx.ID_ANY,
            text = 'Set Volume',
            helpString = ('Set the keyboard focus on volume slider text '
                + 'label.'),
            kind = wx.ITEM_NORMAL
            )
        self._soundsubmenu.Append(self._ssvolumemenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventssvolumeselect,
            id = self._ssvolumemenuitem.GetId()
            )
        #Create linear vs log sound scale menu items
        self._slinscale_menuitem = wx.MenuItem(
            parentMenu = self._soundsubmenu,
            id = wx.ID_ANY,
            text = 'Linear scale',
            helpString = ('Set linear sound scale for the data sonification.'),
            kind = wx.ITEM_CHECK
            )
        self._soundsubmenu.Append(self._slinscale_menuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventlinsoundscalechoice,
            id = self._slinscale_menuitem.GetId()
            )
        self._slinscale_menuitem.Check()
        #Create linear vs log sound scale menu items
        self._slogscale_menuitem = wx.MenuItem(
            parentMenu = self._soundsubmenu,
            id = wx.ID_ANY,
            text = 'Logarithmic scale',
            helpString = ('Set logarithmic sound scale for the data sonification.'),
            kind = wx.ITEM_CHECK
            )
        self._soundsubmenu.Append(self._slogscale_menuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventlogsoundscalechoice,
            id = self._slogscale_menuitem.GetId()
            )
        # Create cont vs disc sound menu item and append it to sound submenu
        self._scontmenuitem = wx.MenuItem(
            parentMenu = self._soundsubmenu,
            id = wx.ID_ANY,
            text = 'Continuous sound',
            helpString = ('Set continuous sound for the data sonification.'),
            kind = wx.ITEM_CHECK
            )
        self._soundsubmenu.Append(self._scontmenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventcontsoundchoice,
            id = self._scontmenuitem.GetId()
            )
        # Create cont vs disc sound menu item and append it to sound submenu
        self._sdiscretemenuitem = wx.MenuItem(
            parentMenu = self._soundsubmenu,
            id = wx.ID_ANY,
            text = 'Discrete sound',
            helpString = ('Set discrete sound for the data sonification.'),
            kind = wx.ITEM_CHECK
            )
        self._soundsubmenu.Append(self._sdiscretemenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventdiscsoundchoice,
            id = self._sdiscretemenuitem.GetId()
            )
        self._sdiscretemenuitem.Check()
        # Create min frequency menu item and append it to sound submenu
        self._ssfreqmappingmenuitem = wx.MenuItem(
            parentMenu = self._soundsubmenu,
            id = wx.ID_ANY,
            text = 'Frequency mapping',
            helpString = ('Set the keyboard focus on minimum frequency slider '
                + 'text label.'),
            kind = wx.ITEM_CHECK
            )
        self._soundsubmenu.Append(self._ssfreqmappingmenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventssfreqmappingselect,
            id = self._ssfreqmappingmenuitem.GetId()
            )
        self._ssfreqmappingmenuitem.Check(True)
        # Create max frequency menu item and append it to sound submenu
        self._ssvolmappingmenuitem = wx.MenuItem(
            parentMenu = self._soundsubmenu,
            id = wx.ID_ANY,
            text = 'Volume mapping',
            helpString = ('Set the keyboard focus on minimum volume slider '
                + 'text label.'),
            kind = wx.ITEM_CHECK
            )
        self._soundsubmenu.Append(self._ssvolmappingmenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventssvolmappingselect,
            id = self._ssvolmappingmenuitem.GetId()
            )
        # Create waveform menu item and append it to sound submenu
        self._sswaveformmenuitem = wx.MenuItem(
            parentMenu = self._soundsubmenu,
            id = wx.ID_ANY,
            text = 'Sound type',
            helpString = ('Set the keyboard focus on sound type dropdown '
                + 'element text label.'),
            kind = wx.ITEM_NORMAL
            )
        self._soundsubmenu.Append(self._sswaveformmenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventsswaveformselect,
            id = self._sswaveformmenuitem.GetId()
            )
        # Create special config menu item and append it to sound submenu
        self._ssspecialconfigmenuitem = wx.MenuItem(
            parentMenu = self._soundsubmenu,
            id = wx.ID_ANY,
            text = 'Sound envelope',
            helpString = ('Set the keyboard focus on Sound envelope sliders '
                + 'Panel.'),
            kind = wx.ITEM_CHECK
            )
        self._soundsubmenu.Append(self._ssspecialconfigmenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventSpecialSoundConfig,
            id = self._ssspecialconfigmenuitem.GetId()
            )
        # Append sound submenu to settings menu
        self._menusettings.AppendSubMenu(
            submenu = self._soundsubmenu,
            text = 'Sound',
            help = 'Contain the sound posible settings items.'
            )
        # Create plot submenu
        self._plotsubmenu = wx.Menu()
        # Create plot line style menu item and append it to plot style submenu
        self._splotlinemenuitem = wx.MenuItem(
            parentMenu = self._plotsubmenu,
            id = wx.ID_ANY,
            text = 'Plot line style',
            helpString = ('Set the keyboard focus on plot line style dropdown'
                + ' element text label.'),
            kind = wx.ITEM_NORMAL
            )
        self._plotsubmenu.Append(self._splotlinemenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventsplotlineselect,
            id = self._splotlinemenuitem.GetId()
            )
        # Create plot marker style menu item and append it to plot style
        # submenu
        self._splotmarkermenuitem = wx.MenuItem(
            parentMenu = self._plotsubmenu,
            id = wx.ID_ANY,
            text = 'Plot marker style',
            helpString = ('Set the keyboard focus on plot marker style '
                + 'dropdown element text label.'),
            kind = wx.ITEM_NORMAL
            )
        self._plotsubmenu.Append(self._splotmarkermenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventsplotmarkerselect,
            id = self._splotmarkermenuitem.GetId()
            )
        # Create the plot color style menu item and append it to plot style
        # submenu
        self._splotcolormenuitem = wx.MenuItem(
            parentMenu = self._plotsubmenu,
            id = wx.ID_ANY,
            text = 'Plot color style',
            helpString = ('Set the keyboard focus on plot color style '
                + 'dropdown element text label.'),
            kind = wx.ITEM_NORMAL
            )
        self._plotsubmenu.Append(self._splotcolormenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventsplotcolorselect,
            id = self._splotcolormenuitem.GetId()
            )
        # Create grid option menu item and append it to plot style submenu
        self._splotgridoptionmenuitem = wx.MenuItem(
            parentMenu = self._plotsubmenu,
            id = wx.ID_ANY,
            text = 'Grid option',
            helpString = ('Set the keyboard focus on grid option check item '
                + 'text label.'),
            kind = wx.ITEM_CHECK
            )
        self._plotsubmenu.Append(self._splotgridoptionmenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventsplotgridoptionselect,
            id = self._splotgridoptionmenuitem.GetId()
            )
        # Append plot style submenu to settings menu
        self._menusettings.AppendSubMenu(
            submenu = self._plotsubmenu,
            text = 'Plot Styles',
            help = 'Contain the plot style posible settings items.'
            )
        # Append setting menu to menu bar
        self._menubar.Append(
            menu = self._menusettings,
            title = 'Settings'
            )
        # Create help menu
        self._menuhelp = wx.Menu()
        # Create about menu item and append it to help menu
        self._aboutmenuitem = wx.MenuItem(
            parentMenu = self._menuhelp,
            id = wx.ID_ANY,
            text = ('About' + '\t' + 'Ctrl+Alt+H'),
            helpString = ('Show a message box with information about the '
                + 'application.'),
            kind = wx.ITEM_NORMAL
            )
        self._menuhelp.Append(self._aboutmenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventabout,
            id = self._aboutmenuitem.GetId()
            )
        # Create user manual menu item and append it to help menu
        self._manualmenuitem = wx.MenuItem(
            parentMenu = self._menuhelp,
            id = wx.ID_ANY,
            text = ('User manual' + '\t' + 'Ctrl+Alt+U'),
            helpString = ('Show a message box with the location and a link '
                + 'of the user manual file.'),
            kind = wx.ITEM_NORMAL
            )
        self._menuhelp.Append(self._manualmenuitem)
        self.Bind(
            event = wx.EVT_MENU,
            handler = self._eventmanual,
            id = self._manualmenuitem.GetId()
            )
        # Append help menu to menu bar
        self._menubar.Append(
            menu = self._menuhelp,
            title = 'Help'
            )
        # Set the menu bar
        self.SetMenuBar(self._menubar)

    def _createfilepanel(self, panel):

        """
        We have to continue with the code modification from here!
        """
        #crea el panel File con su sizer(row(5)col(2)) sin seccion expandida
        filepanel = wx.Panel( panel, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.TAB_TRAVERSAL )
        _fileFgSizer = wx.FlexGridSizer( 6, 1, 0, 0 )
        _fileFgSizer.SetFlexibleDirection( wx.BOTH )
        _fileFgSizer.SetNonFlexibleGrowMode( wx.FLEX_GROWMODE_SPECIFIED )
    #Crea el boton Open y lo agrega al sizer del panel File
        self._openButton = wx.Button( filepanel, wx.ID_ANY, u"&Open", wx.DefaultPosition, wx.DefaultSize, 0 )
        self._openButton.Bind( wx.EVT_BUTTON, self._eventopen )
        _fileFgSizer.Add( self._openButton, 0, wx.ALL, 5 )
    #Crea el boton Delete all marks y lo agrega al sizer del panel File
        self._deleteAllMarksButton = wx.Button( filepanel, wx.ID_ANY, u"&Delete all marks", wx.DefaultPosition, wx.DefaultSize, 0 )
        self._deleteAllMarksButton.Bind( wx.EVT_BUTTON, self._eventdeleteallmark )
        _fileFgSizer.Add( self._deleteAllMarksButton, 0, wx.ALL, 5 )
    #Crea el boton Save Data y lo agrega al sizer del panel File
        self._saveDataButton = wx.Button( filepanel, wx.ID_ANY, u"Save &Data", wx.DefaultPosition, wx.DefaultSize, 0 )
        self._saveDataButton.Bind( wx.EVT_BUTTON, self._eventsavedata )
        _fileFgSizer.Add( self._saveDataButton, 0, wx.ALL, 5 )
    #Crea el boton Save Marks y lo agrega al sizer del panel File
        self._saveMarksButton = wx.Button( filepanel, wx.ID_ANY, u"Save &Marks", wx.DefaultPosition, wx.DefaultSize, 0 )
        self._saveMarksButton.Bind( wx.EVT_BUTTON, self._eventsavemarks )
        _fileFgSizer.Add( self._saveMarksButton, 0, wx.ALL, 5 )
    #Crea el boton Save Sound y lo agrega al sizer del panel File
        self._saveSoundButton = wx.Button( filepanel, wx.ID_ANY, u"Save &Sound", wx.DefaultPosition, wx.DefaultSize, 0 )
        self._saveSoundButton.Bind( wx.EVT_BUTTON, self._eventsavesound )
        _fileFgSizer.Add( self._saveSoundButton, 0, wx.ALL, 5 )
        #self._saveSoundButton.Hide()
    #Crea el boton Save Plot y lo agrega al sizer del panel File
        self._savePlotButton = wx.Button( filepanel, wx.ID_ANY, u"Save &Plot", wx.DefaultPosition, wx.DefaultSize, 0 )
        self._savePlotButton.Bind( wx.EVT_BUTTON, self._eventsaveplot )
        _fileFgSizer.Add( self._savePlotButton, 0, wx.ALL, 5 )
    #Relaciona el sizer con el panel File y lo agrega al sizer del panel izquierdo
        filepanel.SetSizer( _fileFgSizer )
        filepanel.Layout()
        _fileFgSizer.Fit( filepanel )
        return filepanel

    def _createconfigpanel(self, panel):
        #crea el panel Configuraciones con su sizer(row(2)col(2)) sin seccion expandida
        congifpanel = wx.Panel( panel, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.TAB_TRAVERSAL )
        _configFgSizer = wx.FlexGridSizer( 3, 2, 0, 0 )
        _configFgSizer.SetFlexibleDirection( wx.BOTH )
        _configFgSizer.SetNonFlexibleGrowMode( wx.FLEX_GROWMODE_SPECIFIED )
    #Crea el boton de dos estados Sound Configurations, lo setea como presionado y lo agrega al sizer del panel Configuraciones
        self._configSoundToggleBtn = wx.ToggleButton( congifpanel, wx.ID_ANY, u"Show Sound\nConfiguraton", wx.DefaultPosition, wx.DefaultSize, 0 )
        self._configSoundToggleBtn.Bind( wx.EVT_TOGGLEBUTTON, self._eventConfigSound )
        self._configSoundToggleBtn.SetValue( False )
        _configFgSizer.Add( self._configSoundToggleBtn, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL , 5 )
    #Crea el panel para desplegar las configuraciones de sonido y su sizer(row(8)col(1)) sin seccion expandida
        self._soundFontPanel = wx.Panel(congifpanel, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.TAB_TRAVERSAL )
        _soundFontFgSizer = wx.FlexGridSizer( 9, 1, 0, 0 )
        _soundFontFgSizer.SetFlexibleDirection( wx.BOTH )

        #Crea el espacio de texto con el label Volume y lo agrega al sizer del panel de configuración de sonido
        self._volumeTextCtrl = wx.TextCtrl( self._soundFontPanel, wx.ID_ANY, u"Volume:", wx.DefaultPosition, wx.Size( 90,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL )
        self._volumeTextCtrl.SetEditable(0)
        _soundFontFgSizer.Add( self._volumeTextCtrl, 0, wx.ALL, 5 )
        #Crea la slider para el volumen
        self._soundvolumnslider = wx.Slider( self._soundFontPanel, wx.ID_ANY, 50, 0, 100, wx.DefaultPosition, wx.DefaultSize, wx.SL_HORIZONTAL | wx.SL_LABELS )
        self._soundvolumnslider.Bind( wx.EVT_KEY_UP, self._eventsoundvolumn )
        self._soundvolumnslider.Bind( wx.EVT_SCROLL, self._eventsoundvolumn )
        _soundFontFgSizer.Add( self._soundvolumnslider, 0, wx.ALL|wx.EXPAND, 5 )
        
        #Crea el boton de dos estados lineal vs logaritmic scale
        self._linvslog_soundscale_togglebtn = wx.ToggleButton( self._soundFontPanel, wx.ID_ANY, u"Set logarithmic scale", wx.DefaultPosition, wx.DefaultSize, 0 )
        self._linvslog_soundscale_togglebtn.Bind( wx.EVT_TOGGLEBUTTON, self._event_linvslog_soundscalechoice )
        self._linvslog_soundscale_togglebtn.SetValue( False )
        _soundFontFgSizer.Add( self._linvslog_soundscale_togglebtn, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL , 5 )


        #Crea el boton
        self._contdiscsoundToggleBtn = wx.ToggleButton( self._soundFontPanel, wx.ID_ANY, u"Set continuous sound", wx.DefaultPosition, wx.DefaultSize, 0 )
        self._contdiscsoundToggleBtn.Bind( wx.EVT_TOGGLEBUTTON, self._eventcontdiscsoundchoice )
        self._contdiscsoundToggleBtn.SetValue( False )
        _soundFontFgSizer.Add( self._contdiscsoundToggleBtn, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL , 5 )


        #Genero una sizer para poner el selector y las sliders
        _mappingFgSizer = wx.FlexGridSizer( 2, 2, 0, 0 )
        _mappingFgSizer.SetFlexibleDirection( wx.BOTH )
        
        #Check box para elegir el mapeo en frecuencia
        self._freqmappingCheckBox = wx.CheckBox(
            parent=self._soundFontPanel,
            id=wx.ID_ANY,
            label='Frequency mapping',
            pos=wx.DefaultPosition,
            size=wx.DefaultSize,
            style=0,
            validator=wx.DefaultValidator,
            name='This check box set the sound mapping with frequency variation.'
            )
        self._freqmappingCheckBox.Bind(
            event=wx.EVT_CHECKBOX,
            handler=self._eventfreqmapping
            )
        _mappingFgSizer.Add(
            window=self._freqmappingCheckBox,
            proportion=0,
            flag=wx.ALL,
            border=5
            )
        self._freqmappingCheckBox.SetValue(True)
        
        #Panel y sizer para setear frecuencia mínima y máxima
        #crea el panel freq mapping con su sizer(row(2)col(2)) sin seccion expandida
        self._freqmappingPanel = wx.Panel( self._soundFontPanel, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.TAB_TRAVERSAL )
        _freqmappingFgSizer = wx.FlexGridSizer( 6, 1, 0, 0 )
        _freqmappingFgSizer.SetFlexibleDirection( wx.BOTH )

        #Crea el espacio de texto con el label frecuencia min y lo agrega al sizer del panel de configuración de sonido
        # self._soundfreqmintextctrl = wx.TextCtrl( self._freqmappingPanel, wx.ID_ANY, u"Min frequency:", wx.DefaultPosition, wx.Size( 90,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL )
        # self._soundfreqmintextctrl.SetEditable(0)
        # _freqmappingFgSizer.Add( self._soundfreqmintextctrl, 0, wx.ALL, 5 )
        
        #Crea la checkbox para la frecuencia maxima
        self._soundfreqmin_checkbox = wx.CheckBox(
            parent=self._freqmappingPanel,
            id=wx.ID_ANY,
            label='Min frequency:',
            pos=wx.DefaultPosition,
            size=wx.DefaultSize,
            style=0,
            validator=wx.DefaultValidator,
            name='This check box show the min frequency slider.'
            )
        self._soundfreqmin_checkbox.Bind(
            event=wx.EVT_CHECKBOX,
            handler=self._eventshow_soundfreqmin
            )
        _freqmappingFgSizer.Add(
            window=self._soundfreqmin_checkbox,
            proportion=0,
            flag=wx.ALL | wx.ALIGN_BOTTOM,
            border=5
            )
        
        #Creo panel y sizer para poder esconder la slider
        self._soundfreqmin_panel = wx.Panel(
            parent=self._freqmappingPanel,
            id=wx.ID_ANY,
            pos=wx.DefaultPosition,
            size=wx.DefaultSize,
            style=wx.TAB_TRAVERSAL
            )
        _soundfreqmin_fgsizer = wx.FlexGridSizer(2, 1, 0, 0)
        _soundfreqmin_fgsizer.SetFlexibleDirection(wx.BOTH)
        
        
        #Crea la slider para la frecuencia
        self._soundfreqminslider = wx.Slider( self._soundfreqmin_panel, wx.ID_ANY, 400, 0, 2900, wx.DefaultPosition, wx.DefaultSize, wx.SL_HORIZONTAL )
        self._soundfreqminslider.Bind( wx.EVT_KEY_UP, self._eventsoundfreqmin )
        self._soundfreqminslider.Bind( wx.EVT_SCROLL, self._eventsoundfreqmin )
        _soundfreqmin_fgsizer.Add( self._soundfreqminslider, 0, wx.ALL|wx.EXPAND, 5 )
        #Crea el sizer para contener las etiquetas de la slider de frecuencia
        _soundfreqminlabelsfgsizer = wx.FlexGridSizer( 1, 3, 0, 0 )
        _soundfreqminlabelsfgsizer.SetFlexibleDirection( wx.BOTH )
        _soundfreqminlabelsfgsizer.AddGrowableCol(1)
        #Creo el primer label de la slider de freq
        self._minsoundfreqmintextctrl = wx.TextCtrl( self._soundfreqmin_panel, wx.ID_ANY, u"100", wx.DefaultPosition, wx.Size( 50,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.ALIGN_LEFT )
        self._minsoundfreqmintextctrl.SetEditable(0)
        _soundfreqminlabelsfgsizer.Add( self._minsoundfreqmintextctrl, 0, wx.ALL | wx.ALIGN_LEFT, 5 )
        #Creo el segundo label de la slider de freq
        self._actualsoundfreqmintextctrl = wx.TextCtrl( self._soundfreqmin_panel, wx.ID_ANY, u"500", wx.DefaultPosition, wx.Size( 50,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.ALIGN_LEFT )
        self._actualsoundfreqmintextctrl.SetEditable(0)
        _soundfreqminlabelsfgsizer.Add( self._actualsoundfreqmintextctrl, 0, wx.ALL | wx.ALIGN_CENTRE, 5 )
        #Creo el tercer label de la slider de freq
        self._maxsoundfreqmintextctrl = wx.TextCtrl( self._soundfreqmin_panel, wx.ID_ANY, u"3000", wx.DefaultPosition, wx.Size( 50,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.ALIGN_RIGHT )
        self._maxsoundfreqmintextctrl.SetEditable(0)
        _soundfreqminlabelsfgsizer.Add( self._maxsoundfreqmintextctrl, 0, wx.ALL | wx.ALIGN_RIGHT, 5 )
        #Relaciona el sizer con el sizer del sonido
        _soundfreqmin_fgsizer.Add( _soundfreqminlabelsfgsizer, 1, wx.EXPAND, 5 )
        
        #Relaciona el sizer con el panel
        self._soundfreqmin_panel.SetSizer( _soundfreqmin_fgsizer )
        self._soundfreqmin_panel.Layout()
        _soundfreqmin_fgsizer.Fit( self._soundfreqmin_panel )
        _freqmappingFgSizer.Add( self._soundfreqmin_panel, 1, wx.EXPAND |wx.ALL, 5 )
        self._soundfreqmin_panel.Hide()


        #Crea el espacio de texto con el label frecuencia max y lo agrega al sizer del panel de configuración de sonido
        # self._soundfreqmaxtextctrl = wx.TextCtrl( self._freqmappingPanel, wx.ID_ANY, u"Max frequency:", wx.DefaultPosition, wx.Size( 90,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL )
        # self._soundfreqmaxtextctrl.SetEditable(0)
        # _freqmappingFgSizer.Add( self._soundfreqmaxtextctrl, 0, wx.ALL, 5 )
        
        #Crea la checkbox para la frecuencia maxima
        self._soundfreqmax_checkbox = wx.CheckBox(
            parent=self._freqmappingPanel,
            id=wx.ID_ANY,
            label='Max frequency:',
            pos=wx.DefaultPosition,
            size=wx.DefaultSize,
            style=0,
            validator=wx.DefaultValidator,
            name='This check box show the max frequency slider.'
            )
        self._soundfreqmax_checkbox.Bind(
            event=wx.EVT_CHECKBOX,
            handler=self._eventshow_soundfreqmax
            )
        _freqmappingFgSizer.Add(
            window=self._soundfreqmax_checkbox,
            proportion=0,
            flag=wx.ALL | wx.ALIGN_BOTTOM,
            border=5
            )
        
        #Creo panel y sizer para poder esconder la slider
        self._soundfreqmax_panel = wx.Panel(
            parent=self._freqmappingPanel,
            id=wx.ID_ANY,
            pos=wx.DefaultPosition,
            size=wx.DefaultSize,
            style=wx.TAB_TRAVERSAL
            )
        _soundfreqmax_fgsizer = wx.FlexGridSizer(2, 1, 0, 0)
        _soundfreqmax_fgsizer.SetFlexibleDirection(wx.BOTH)
        
        #Crea la slider para la frecuencia
        self._soundfreqmaxslider = wx.Slider( self._soundfreqmax_panel, wx.ID_ANY, 2500, 0, 2500, wx.DefaultPosition, wx.DefaultSize, wx.SL_HORIZONTAL )
        self._soundfreqmaxslider.Bind( wx.EVT_KEY_UP, self._eventsoundfreqmax )
        self._soundfreqmaxslider.Bind( wx.EVT_SCROLL, self._eventsoundfreqmax )
        _soundfreqmax_fgsizer.Add( self._soundfreqmaxslider, 0, wx.ALL|wx.EXPAND, 5 )
        #Crea el sizer para contener las etiquetas de la slider de frecuencia
        _soundfreqmaxlabelsfgsizer = wx.FlexGridSizer( 1, 3, 0, 0 )
        _soundfreqmaxlabelsfgsizer.SetFlexibleDirection( wx.BOTH )
        _soundfreqmaxlabelsfgsizer.AddGrowableCol(1)
        #Creo el primer label de la slider de freq
        self._minsoundfreqmaxtextctrl = wx.TextCtrl( self._soundfreqmax_panel, wx.ID_ANY, u"500", wx.DefaultPosition, wx.Size( 50,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.ALIGN_LEFT )
        self._minsoundfreqmaxtextctrl.SetEditable(0)
        _soundfreqmaxlabelsfgsizer.Add( self._minsoundfreqmaxtextctrl, 0, wx.ALL | wx.ALIGN_LEFT, 5 )
        #Creo el segundo label de la slider de freq
        self._actualsoundfreqmaxtextctrl = wx.TextCtrl( self._soundfreqmax_panel, wx.ID_ANY, u"3000", wx.DefaultPosition, wx.Size( 50,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.ALIGN_LEFT )
        self._actualsoundfreqmaxtextctrl.SetEditable(0)
        _soundfreqmaxlabelsfgsizer.Add( self._actualsoundfreqmaxtextctrl, 0, wx.ALL | wx.ALIGN_CENTRE, 5 )
        #Creo el tercer label de la slider de freq
        self._maxsoundfreqmaxtextctrl = wx.TextCtrl( self._soundfreqmax_panel, wx.ID_ANY, u"3000", wx.DefaultPosition, wx.Size( 50,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.ALIGN_RIGHT )
        self._maxsoundfreqmaxtextctrl.SetEditable(0)
        _soundfreqmaxlabelsfgsizer.Add( self._maxsoundfreqmaxtextctrl, 0, wx.ALL | wx.ALIGN_RIGHT, 5 )
        #Relaciona el sizer con el sizer del sonido
        _soundfreqmax_fgsizer.Add( _soundfreqmaxlabelsfgsizer, 1, wx.EXPAND, 5 )

        #Relaciona el sizer con el panel
        self._soundfreqmax_panel.SetSizer( _soundfreqmax_fgsizer )
        self._soundfreqmax_panel.Layout()
        _soundfreqmax_fgsizer.Fit( self._soundfreqmax_panel )
        _freqmappingFgSizer.Add( self._soundfreqmax_panel, 1, wx.EXPAND |wx.ALL, 5 )
        self._soundfreqmax_panel.Hide()

        #Relaciona el sizer con el panel
        self._freqmappingPanel.SetSizer( _freqmappingFgSizer )
        self._freqmappingPanel.Layout()
        _freqmappingFgSizer.Fit( self._freqmappingPanel )
        _mappingFgSizer.Add( self._freqmappingPanel, 1, wx.EXPAND |wx.ALL, 5 )
        
        #Check box para elegir el mapeo en volumen
        self._volmappingCheckBox = wx.CheckBox(
            parent=self._soundFontPanel,
            id=wx.ID_ANY,
            label='Volume mapping',
            pos=wx.DefaultPosition,
            size=wx.DefaultSize,
            style=0,
            validator=wx.DefaultValidator,
            name='This check box set the sound mapping with volume variation.'
            )
        self._volmappingCheckBox.Bind(
            event=wx.EVT_CHECKBOX,
            handler=self._eventvolmapping
            )
        _mappingFgSizer.Add(
            window=self._volmappingCheckBox,
            proportion=0,
            flag=wx.ALL | wx.ALIGN_BOTTOM,
            border=5
            )
        
        #Panel y sizer para setear volumen mínima y máxima
        #crea el panel vol mapping con su sizer(row(2)col(2)) sin seccion expandida
        self._volmappingPanel = wx.Panel( self._soundFontPanel, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.TAB_TRAVERSAL )
        _volmappingFgSizer = wx.FlexGridSizer( 9, 1, 0, 0 )
        _volmappingFgSizer.SetFlexibleDirection( wx.BOTH )

        #Crea el espacio de texto con el label frecuencia para mapeo en volumen
        #y lo agrega al sizer del panel de configuración de sonido
        # self._soundvolfreqtextctrl = wx.TextCtrl(
        #     parent=self._volmappingPanel,
        #     id=wx.ID_ANY,
        #     value='Frequency of volume mapping:',
        #     pos=wx.DefaultPosition,
        #     size=wx.Size( 170,15 ),
        #     style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL
        #     )
        # self._soundvolfreqtextctrl.SetEditable(0)
        # _volmappingFgSizer.Add( self._soundvolfreqtextctrl, 0, wx.ALL, 5 )
        
        #Crea la checkbox para la variacion en freq del volumen
        self._soundvolfreq_checkbox = wx.CheckBox(
            parent=self._volmappingPanel,
            id=wx.ID_ANY,
            label='Frequency of volume mapping:',
            pos=wx.DefaultPosition,
            size=wx.DefaultSize,
            style=0,
            validator=wx.DefaultValidator,
            name='This check box show the frequency slider of volume mapping.'
            )
        self._soundvolfreq_checkbox.SetValue(True)
        self._soundvolfreq_checkbox.Bind(
            event=wx.EVT_CHECKBOX,
            handler=self._eventshow_soundvolfreq
            )
        _volmappingFgSizer.Add(
            window=self._soundvolfreq_checkbox,
            proportion=0,
            flag=wx.ALL | wx.ALIGN_BOTTOM,
            border=5
            )
        
        #Creo panel y sizer para poder esconder la slider
        self._soundvolfreq_panel = wx.Panel(
            parent=self._volmappingPanel,
            id=wx.ID_ANY,
            pos=wx.DefaultPosition,
            size=wx.DefaultSize,
            style=wx.TAB_TRAVERSAL
            )
        _soundvolfreq_fgsizer = wx.FlexGridSizer(2, 1, 0, 0)
        _soundvolfreq_fgsizer.SetFlexibleDirection(wx.BOTH)
        
        
        #Crea la slider para la frecuencia del mapeo en volumen
        self._soundvolfreq_slider = wx.Slider(
            self._soundvolfreq_panel,
            wx.ID_ANY,
            500,
            0,
            2900,
            wx.DefaultPosition,
            wx.DefaultSize,
            wx.SL_HORIZONTAL
            )
        self._soundvolfreq_slider.Bind( wx.EVT_KEY_UP, self._eventsoundvolfreq )
        self._soundvolfreq_slider.Bind( wx.EVT_SCROLL, self._eventsoundvolfreq )
        _soundvolfreq_fgsizer.Add( self._soundvolfreq_slider, 0, wx.ALL|wx.EXPAND, 5 )
        #Crea el sizer para contener las etiquetas de la slider de frecuencia
        _soundvolfreqlabels_fgsizer = wx.FlexGridSizer( 1, 3, 0, 0 )
        _soundvolfreqlabels_fgsizer.SetFlexibleDirection( wx.BOTH )
        _soundvolfreqlabels_fgsizer.AddGrowableCol(1)
        #Creo el primer label de la slider de freq
        self._minsoundvolfreqtextctrl = wx.TextCtrl( self._soundvolfreq_panel, wx.ID_ANY, u"100", wx.DefaultPosition, wx.Size( 50,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.ALIGN_LEFT )
        self._minsoundvolfreqtextctrl.SetEditable(0)
        _soundvolfreqlabels_fgsizer.Add( self._minsoundvolfreqtextctrl, 0, wx.ALL | wx.ALIGN_LEFT, 5 )
        #Creo el segundo label de la slider de freq
        self._actualsoundvolfreq_textctrl = wx.TextCtrl( self._soundvolfreq_panel, wx.ID_ANY, u"600", wx.DefaultPosition, wx.Size( 50,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.ALIGN_LEFT )
        self._actualsoundvolfreq_textctrl.SetEditable(0)
        _soundvolfreqlabels_fgsizer.Add( self._actualsoundvolfreq_textctrl, 0, wx.ALL | wx.ALIGN_CENTRE, 5 )
        #Creo el tercer label de la slider de freq
        self._maxsoundvolfreq_textctrl = wx.TextCtrl( self._soundvolfreq_panel, wx.ID_ANY, u"3000", wx.DefaultPosition, wx.Size( 50,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.ALIGN_RIGHT )
        self._maxsoundvolfreq_textctrl.SetEditable(0)
        _soundvolfreqlabels_fgsizer.Add( self._maxsoundvolfreq_textctrl, 0, wx.ALL | wx.ALIGN_RIGHT, 5 )
        #Relaciona el sizer con el sizer del sonido
        _soundvolfreq_fgsizer.Add( _soundvolfreqlabels_fgsizer, 1, wx.EXPAND, 5 )
        
        #Relaciona el sizer con el panel
        self._soundvolfreq_panel.SetSizer( _soundvolfreq_fgsizer )
        self._soundvolfreq_panel.Layout()
        _soundvolfreq_fgsizer.Fit( self._soundvolfreq_panel )
        _volmappingFgSizer.Add( self._soundvolfreq_panel, 1, wx.EXPAND |wx.ALL, 5 )
        # self._soundvolfreq_panel.Hide()
        

        #Crea el espacio de texto con el label vol min y
        # self._soundvolmintextctrl = wx.TextCtrl(
        #     self._volmappingPanel,
        #     wx.ID_ANY,
        #     u"Min volume:",
        #     wx.DefaultPosition,
        #     wx.Size( 90,15 ),
        #     style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL
        #     )
        # self._soundvolmintextctrl.SetEditable(0)
        # _volmappingFgSizer.Add( self._soundvolmintextctrl, 0, wx.ALL, 5 )
        
        #Crea la checkbox para el volumen minimo
        self._soundvolmin_checkbox = wx.CheckBox(
            parent=self._volmappingPanel,
            id=wx.ID_ANY,
            label='Min volume:',
            pos=wx.DefaultPosition,
            size=wx.DefaultSize,
            style=0,
            validator=wx.DefaultValidator,
            name='This check box show the min volume slider.'
            )
        self._soundvolmin_checkbox.Bind(
            event=wx.EVT_CHECKBOX,
            handler=self._eventshow_soundvolmin
            )
        _volmappingFgSizer.Add(
            window=self._soundvolmin_checkbox,
            proportion=0,
            flag=wx.ALL | wx.ALIGN_BOTTOM,
            border=5
            )
        
        #Creo panel y sizer para poder esconder la slider
        self._soundvolmin_panel = wx.Panel(
            parent=self._volmappingPanel,
            id=wx.ID_ANY,
            pos=wx.DefaultPosition,
            size=wx.DefaultSize,
            style=wx.TAB_TRAVERSAL
            )
        _soundvolmin_fgsizer = wx.FlexGridSizer(2, 1, 0, 0)
        _soundvolmin_fgsizer.SetFlexibleDirection(wx.BOTH)
        
        
        #Crea la slider para el volumen min
        self._soundvolminslider = wx.Slider(
            self._soundvolmin_panel,
            wx.ID_ANY,
            0,
            0,
            100,
            wx.DefaultPosition,
            wx.DefaultSize,
            wx.SL_HORIZONTAL
            )
        self._soundvolminslider.Bind( wx.EVT_KEY_UP, self._eventsoundvolmin )
        self._soundvolminslider.Bind( wx.EVT_SCROLL, self._eventsoundvolmin )
        _soundvolmin_fgsizer.Add( self._soundvolminslider, 0, wx.ALL|wx.EXPAND, 5 )
        #Crea el sizer para contener las etiquetas de la slider de volumen
        _soundvolminlabelsfgsizer = wx.FlexGridSizer( 1, 3, 0, 0 )
        _soundvolminlabelsfgsizer.SetFlexibleDirection( wx.BOTH )
        _soundvolminlabelsfgsizer.AddGrowableCol(1)
        #Creo el primer label de la slider de freq
        self._minsoundvolmintextctrl = wx.TextCtrl( self._soundvolmin_panel, wx.ID_ANY, u"0", wx.DefaultPosition, wx.Size( 50,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.ALIGN_LEFT )
        self._minsoundvolmintextctrl.SetEditable(0)
        _soundvolminlabelsfgsizer.Add( self._minsoundvolmintextctrl, 0, wx.ALL | wx.ALIGN_LEFT, 5 )
        #Creo el segundo label de la slider de freq
        self._actualsoundvolmintextctrl = wx.TextCtrl( self._soundvolmin_panel, wx.ID_ANY, u"0", wx.DefaultPosition, wx.Size( 50,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.ALIGN_LEFT )
        self._actualsoundvolmintextctrl.SetEditable(0)
        _soundvolminlabelsfgsizer.Add( self._actualsoundvolmintextctrl, 0, wx.ALL | wx.ALIGN_CENTRE, 5 )
        #Creo el tercer label de la slider de freq
        self._maxsoundvolmintextctrl = wx.TextCtrl( self._soundvolmin_panel, wx.ID_ANY, u"100", wx.DefaultPosition, wx.Size( 50,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.ALIGN_RIGHT )
        self._maxsoundvolmintextctrl.SetEditable(0)
        _soundvolminlabelsfgsizer.Add( self._maxsoundvolmintextctrl, 0, wx.ALL | wx.ALIGN_RIGHT, 5 )
        #Relaciona el sizer con el sizer del sonido
        _soundvolmin_fgsizer.Add( _soundvolminlabelsfgsizer, 1, wx.EXPAND, 5 )
        
        #Relaciona el sizer con el panel
        self._soundvolmin_panel.SetSizer( _soundvolmin_fgsizer )
        self._soundvolmin_panel.Layout()
        _soundvolmin_fgsizer.Fit( self._soundvolmin_panel )
        _volmappingFgSizer.Add( self._soundvolmin_panel, 1, wx.EXPAND |wx.ALL, 5 )
        self._soundvolmin_panel.Hide()
        

        #Crea el espacio de texto con el label frecuencia max y lo agrega al sizer del panel de configuración de sonido
        # self._soundvolmaxtextctrl = wx.TextCtrl( self._volmappingPanel, wx.ID_ANY, u"Max volume:", wx.DefaultPosition, wx.Size( 90,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL )
        # self._soundvolmaxtextctrl.SetEditable(0)
        # _volmappingFgSizer.Add( self._soundvolmaxtextctrl, 0, wx.ALL, 5 )
        
        #Check box para elegir el volumen maximo
        self._soundvolmax_checkbox = wx.CheckBox(
            parent=self._volmappingPanel,
            id=wx.ID_ANY,
            label='Max volume:',
            pos=wx.DefaultPosition,
            size=wx.DefaultSize,
            style=0,
            validator=wx.DefaultValidator,
            name='This check box show the max volume slider.'
            )
        self._soundvolmax_checkbox.Bind(
            event=wx.EVT_CHECKBOX,
            handler=self._eventshow_soundvolmax
            )
        _volmappingFgSizer.Add(
            window=self._soundvolmax_checkbox,
            proportion=0,
            flag=wx.ALL | wx.ALIGN_BOTTOM,
            border=5
            )
        
        #Creo panel y sizer para poder esconder la slider
        self._soundvolmax_panel = wx.Panel(
            parent=self._volmappingPanel,
            id=wx.ID_ANY,
            pos=wx.DefaultPosition,
            size=wx.DefaultSize,
            style=wx.TAB_TRAVERSAL
            )
        _soundvolmax_fgsizer = wx.FlexGridSizer(2, 1, 0, 0)
        _soundvolmax_fgsizer.SetFlexibleDirection(wx.BOTH)
        
        #Crea la slider para la frecuencia
        self._soundvolmaxslider = wx.Slider(
            self._soundvolmax_panel,
            wx.ID_ANY,
            100,
            0,
            100,
            wx.DefaultPosition,
            wx.DefaultSize,
            wx.SL_HORIZONTAL
            )
        self._soundvolmaxslider.Bind( wx.EVT_KEY_UP, self._eventsoundvolmax )
        self._soundvolmaxslider.Bind( wx.EVT_SCROLL, self._eventsoundvolmax )
        _soundvolmax_fgsizer.Add( self._soundvolmaxslider, 0, wx.ALL|wx.EXPAND, 5 )
        #Crea el sizer para contener las etiquetas de la slider de frecuencia
        _soundvolmaxlabelsfgsizer = wx.FlexGridSizer( 1, 3, 0, 0 )
        _soundvolmaxlabelsfgsizer.SetFlexibleDirection( wx.BOTH )
        _soundvolmaxlabelsfgsizer.AddGrowableCol(1)
        #Creo el primer label de la slider de freq
        self._minsoundvolmaxtextctrl = wx.TextCtrl( self._soundvolmax_panel, wx.ID_ANY, u"0", wx.DefaultPosition, wx.Size( 50,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.ALIGN_LEFT )
        self._minsoundvolmaxtextctrl.SetEditable(0)
        _soundvolmaxlabelsfgsizer.Add( self._minsoundvolmaxtextctrl, 0, wx.ALL | wx.ALIGN_LEFT, 5 )
        #Creo el segundo label de la slider de freq
        self._actualsoundvolmaxtextctrl = wx.TextCtrl( self._soundvolmax_panel, wx.ID_ANY, u"100", wx.DefaultPosition, wx.Size( 50,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.ALIGN_LEFT )
        self._actualsoundvolmaxtextctrl.SetEditable(0)
        _soundvolmaxlabelsfgsizer.Add( self._actualsoundvolmaxtextctrl, 0, wx.ALL | wx.ALIGN_CENTRE, 5 )
        #Creo el tercer label de la slider de freq
        self._maxsoundvolmaxtextctrl = wx.TextCtrl( self._soundvolmax_panel, wx.ID_ANY, u"100", wx.DefaultPosition, wx.Size( 50,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.ALIGN_RIGHT )
        self._maxsoundvolmaxtextctrl.SetEditable(0)
        _soundvolmaxlabelsfgsizer.Add( self._maxsoundvolmaxtextctrl, 0, wx.ALL | wx.ALIGN_RIGHT, 5 )
        
        #Relaciona el sizer con el sizer del sonido
        _soundvolmax_fgsizer.Add( _soundvolmaxlabelsfgsizer, 1, wx.EXPAND, 5 )
        
        #Relaciona el sizer con el panel
        self._soundvolmax_panel.SetSizer( _soundvolmax_fgsizer )
        self._soundvolmax_panel.Layout()
        _soundvolmax_fgsizer.Fit( self._soundvolmax_panel )
        _volmappingFgSizer.Add( self._soundvolmax_panel, 1, wx.EXPAND |wx.ALL, 5 )
        self._soundvolmax_panel.Hide()
        

        #Relaciona el sizer con el panel
        self._volmappingPanel.SetSizer( _volmappingFgSizer )
        self._volmappingPanel.Layout()
        _volmappingFgSizer.Fit( self._volmappingPanel )
        _mappingFgSizer.Add( self._volmappingPanel, 1, wx.EXPAND |wx.ALL, 5 )
        self._volmappingPanel.Hide()

        _soundFontFgSizer.Add( _mappingFgSizer, 0, wx.ALL , 5 )

        #Aqui abajo se pondra la forma de onda
        #Crea el espacio de texto con el label forma de onda y lo agrega al sizer del panel de configuración de sonido
        self._soundwaveformtextctrl = wx.TextCtrl( self._soundFontPanel, wx.ID_ANY, u"Sound type:", wx.DefaultPosition, wx.Size( 130,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL )
        self._soundwaveformtextctrl.SetEditable(0)
        _soundFontFgSizer.Add( self._soundwaveformtextctrl, 0, wx.ALL, 5 )
        #Crea un panel desplegable con una lista para poder seleccionar entre las formas de onda disponibles, y lo agrega al sizer del panel de configuración de sonido
        _swaveformlistboxchoices = [  ]
        self._swaveformlistbox = wx.ListBox( self._soundFontPanel, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, _swaveformlistboxchoices, wx.LB_ALWAYS_SB )
        self._swaveformlistbox.Bind( wx.EVT_LISTBOX, self._eventswaveform )
        _soundFontFgSizer.Add( self._swaveformlistbox, 0, wx.ALL|wx.EXPAND, 5 )
        
        # Aquí se colocará el checkbox para la envolvente y el panel de la envolvente
        #Check box para elegir la envolvente
        self._envelope_checkbox = wx.CheckBox(
            parent=self._soundFontPanel,
            id=wx.ID_ANY,
            label='Sound envelope configuration:',
            pos=wx.DefaultPosition,
            size=wx.DefaultSize,
            style=0,
            validator=wx.DefaultValidator,
            name='This check box show the envelope panel.'
            )
        self._envelope_checkbox.Bind(
            event=wx.EVT_CHECKBOX,
            handler=self._eventshowenvelope
            )
        _soundFontFgSizer.Add(
            window=self._envelope_checkbox,
            proportion=0,
            flag=wx.ALL | wx.ALIGN_BOTTOM,
            border=5
            )
        
        #crea el panel Configuraciones especiales de sonido con su sizer(row(2)col(2)) sin seccion expandida
        #self._specialsoundcongifpanel = wx.Panel( self._soundFontPanel, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.TAB_TRAVERSAL )
        self._specialsoundcongifpanel = wx.ScrolledWindow(
        parent = self._soundFontPanel,
        id = wx.ID_ANY,
        pos = wx.DefaultPosition,
        size = wx.DefaultSize,
        style = wx.HSCROLL | wx.VSCROLL | wx.TAB_TRAVERSAL,
        name = 'Principal scrolled window.'
        )
        _specialsoundconfigFgSizer = wx.FlexGridSizer( 14, 1, 0, 0 )
        _specialsoundconfigFgSizer.SetFlexibleDirection( wx.BOTH )
        # #Crea el label sound envelope and append it to sound font config panel
        # self._soundspecialconfigtextctrl = wx.TextCtrl(
        #     self._specialsoundcongifpanel,
        #     wx.ID_ANY,
        #     u"Sound envelop configuration:",
        #     wx.DefaultPosition,
        #     wx.Size( 160,15 ),
        #     style = wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL
        #     )
        # self._soundspecialconfigtextctrl.SetEditable(0)
        # _specialsoundconfigFgSizer.Add( self._soundspecialconfigtextctrl, 0, wx.ALL, 5 )

        #Crea el espacio de texto con el label attack y lo agrega al sizer del panel de configuración de sonido
        self._soundattacktextctrl = wx.TextCtrl( self._specialsoundcongifpanel, wx.ID_ANY, u"Attack:", wx.DefaultPosition, wx.Size( 90,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL )
        self._soundattacktextctrl.SetEditable(0)
        _specialsoundconfigFgSizer.Add( self._soundattacktextctrl, 0, wx.ALL, 5 )
        #Crea la slider para el parametro attack
        self._soundattackslider = wx.Slider( self._specialsoundcongifpanel, wx.ID_ANY, 25, 1, 100, wx.DefaultPosition, wx.DefaultSize, wx.SL_HORIZONTAL )
        self._soundattackslider.Bind( wx.EVT_KEY_UP, self._eventsoundattack )
        self._soundattackslider.Bind( wx.EVT_SCROLL, self._eventsoundattack )
        _specialsoundconfigFgSizer.Add( self._soundattackslider, 0, wx.ALL|wx.EXPAND, 5 )
        #Crea el sizer para contener las etiquetas de la slider de attack
        _soundattacklabelsfgsizer = wx.FlexGridSizer( 1, 3, 0, 0 )
        _soundattacklabelsfgsizer.SetFlexibleDirection( wx.BOTH )
        _soundattacklabelsfgsizer.AddGrowableCol(1)
        #Creo el primer label de la slider de attack
        self._minattacktextctrl = wx.TextCtrl( self._specialsoundcongifpanel, wx.ID_ANY, u"0.01", wx.DefaultPosition, wx.Size( 50,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.ALIGN_LEFT )
        self._minattacktextctrl.SetEditable(0)
        _soundattacklabelsfgsizer.Add( self._minattacktextctrl, 0, wx.ALL | wx.ALIGN_LEFT, 5 )
        #Creo el segundo label de la slider de attack
        self._actualattacktextctrl = wx.TextCtrl( self._specialsoundcongifpanel, wx.ID_ANY, u"0.25", wx.DefaultPosition, wx.Size( 50,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.ALIGN_LEFT )
        self._actualattacktextctrl.SetEditable(0)
        _soundattacklabelsfgsizer.Add( self._actualattacktextctrl, 0, wx.ALL | wx.ALIGN_CENTRE, 5 )
        #Creo el tercer label de la slider de attack
        self._maxattacktextctrl = wx.TextCtrl( self._specialsoundcongifpanel, wx.ID_ANY, u"1", wx.DefaultPosition, wx.Size( 50,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.ALIGN_RIGHT )
        self._maxattacktextctrl.SetEditable(0)
        _soundattacklabelsfgsizer.Add( self._maxattacktextctrl, 0, wx.ALL | wx.ALIGN_RIGHT, 5 )
        #Relaciona el sizer con el sizer del sonido
        _specialsoundconfigFgSizer.Add( _soundattacklabelsfgsizer, 1, wx.EXPAND, 5 )
        #Crea el espacio de texto con el label decay y lo agrega al sizer del panel de configuración de sonido
        self._sounddecaytextctrl = wx.TextCtrl( self._specialsoundcongifpanel, wx.ID_ANY, u"Decay:", wx.DefaultPosition, wx.Size( 90,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL )
        self._sounddecaytextctrl.SetEditable(0)
        _specialsoundconfigFgSizer.Add( self._sounddecaytextctrl, 0, wx.ALL, 5 )
        #Crea la slider para el parametro decay
        self._sounddecayslider = wx.Slider( self._specialsoundcongifpanel, wx.ID_ANY, 25, 1, 100, wx.DefaultPosition, wx.DefaultSize, wx.SL_HORIZONTAL )
        self._sounddecayslider.Bind( wx.EVT_KEY_UP, self._eventsounddecay )
        self._sounddecayslider.Bind( wx.EVT_SCROLL, self._eventsounddecay )
        _specialsoundconfigFgSizer.Add( self._sounddecayslider, 0, wx.ALL|wx.EXPAND, 5 )
        #Crea el sizer para contener las etiquetas de la slider de decay
        _sounddecaylabelsfgsizer = wx.FlexGridSizer( 1, 3, 0, 0 )
        _sounddecaylabelsfgsizer.SetFlexibleDirection( wx.BOTH )
        _sounddecaylabelsfgsizer.AddGrowableCol(1)
        #Creo el primer label de la slider de decay
        self._mindecaytextctrl = wx.TextCtrl( self._specialsoundcongifpanel, wx.ID_ANY, u"0.01", wx.DefaultPosition, wx.Size( 50,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.ALIGN_LEFT )
        self._mindecaytextctrl.SetEditable(0)
        _sounddecaylabelsfgsizer.Add( self._mindecaytextctrl, 0, wx.ALL | wx.ALIGN_LEFT, 5 )
        #Creo el segundo label de la slider de decay
        self._actualdecaytextctrl = wx.TextCtrl( self._specialsoundcongifpanel, wx.ID_ANY, u"0.25", wx.DefaultPosition, wx.Size( 50,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.ALIGN_LEFT )
        self._actualdecaytextctrl.SetEditable(0)
        _sounddecaylabelsfgsizer.Add( self._actualdecaytextctrl, 0, wx.ALL | wx.ALIGN_CENTRE, 5 )
        #Creo el tercer label de la slider de decay
        self._maxdecaytextctrl = wx.TextCtrl( self._specialsoundcongifpanel, wx.ID_ANY, u"1", wx.DefaultPosition, wx.Size( 50,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.ALIGN_RIGHT )
        self._maxdecaytextctrl.SetEditable(0)
        _sounddecaylabelsfgsizer.Add( self._maxdecaytextctrl, 0, wx.ALL | wx.ALIGN_RIGHT, 5 )
        #Relaciona el sizer con el sizer del sonido
        _specialsoundconfigFgSizer.Add( _sounddecaylabelsfgsizer, 1, wx.EXPAND, 5 )
        #Crea el espacio de texto con el label sustain y lo agrega al sizer del panel de configuración de sonido
        self._soundsustaintextctrl = wx.TextCtrl( self._specialsoundcongifpanel, wx.ID_ANY, u"Sustain:", wx.DefaultPosition, wx.Size( 90,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL )
        self._soundsustaintextctrl.SetEditable(0)
        _specialsoundconfigFgSizer.Add( self._soundsustaintextctrl, 0, wx.ALL, 5 )
        #Crea la slider para el parametro sustain
        self._soundsustainslider = wx.Slider( self._specialsoundcongifpanel, wx.ID_ANY, 50, 0, 100, wx.DefaultPosition, wx.DefaultSize, wx.SL_HORIZONTAL )
        self._soundsustainslider.Bind( wx.EVT_KEY_UP, self._eventsoundsustain )
        self._soundsustainslider.Bind( wx.EVT_SCROLL, self._eventsoundsustain )
        _specialsoundconfigFgSizer.Add( self._soundsustainslider, 0, wx.ALL|wx.EXPAND, 5 )
        #Crea el sizer para contener las etiquetas de la slider de sustain
        _soundsustainlabelsfgsizer = wx.FlexGridSizer( 1, 3, 0, 0 )
        _soundsustainlabelsfgsizer.SetFlexibleDirection( wx.BOTH )
        _soundsustainlabelsfgsizer.AddGrowableCol(1)
        #Creo el primer label de la slider de sustain
        self._minsustaintextctrl = wx.TextCtrl( self._specialsoundcongifpanel, wx.ID_ANY, u"0", wx.DefaultPosition, wx.Size( 50,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.ALIGN_LEFT )
        self._minsustaintextctrl.SetEditable(0)
        _soundsustainlabelsfgsizer.Add( self._minsustaintextctrl, 0, wx.ALL | wx.ALIGN_LEFT, 5 )
        #Creo el segundo label de la slider de sustain
        self._actualsustaintextctrl = wx.TextCtrl( self._specialsoundcongifpanel, wx.ID_ANY, u"50", wx.DefaultPosition, wx.Size( 50,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.ALIGN_LEFT )
        self._actualsustaintextctrl.SetEditable(0)
        _soundsustainlabelsfgsizer.Add( self._actualsustaintextctrl, 0, wx.ALL | wx.ALIGN_CENTRE, 5 )
        #Creo el tercer label de la slider de sustain
        self._maxsustaintextctrl = wx.TextCtrl( self._specialsoundcongifpanel, wx.ID_ANY, u"100", wx.DefaultPosition, wx.Size( 50,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.ALIGN_RIGHT )
        self._maxsustaintextctrl.SetEditable(0)
        _soundsustainlabelsfgsizer.Add( self._maxsustaintextctrl, 0, wx.ALL | wx.ALIGN_RIGHT, 5 )
        #Relaciona el sizer con el sizer del sonido
        _specialsoundconfigFgSizer.Add( _soundsustainlabelsfgsizer, 1, wx.EXPAND, 5 )
        #Crea el espacio de texto con el label release y lo agrega al sizer del panel de configuración de sonido
        self._soundreleasetextctrl = wx.TextCtrl( self._specialsoundcongifpanel, wx.ID_ANY, u"Release:", wx.DefaultPosition, wx.Size( 90,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL )
        self._soundreleasetextctrl.SetEditable(0)
        _specialsoundconfigFgSizer.Add( self._soundreleasetextctrl, 0, wx.ALL, 5 )
        #Crea la slider para el parametro release
        self._soundreleaseslider = wx.Slider( self._specialsoundcongifpanel, wx.ID_ANY, 25, 1, 100, wx.DefaultPosition, wx.DefaultSize, wx.SL_HORIZONTAL )
        self._soundreleaseslider.Bind( wx.EVT_KEY_UP, self._eventsoundrelease )
        self._soundreleaseslider.Bind( wx.EVT_SCROLL, self._eventsoundrelease )
        _specialsoundconfigFgSizer.Add( self._soundreleaseslider, 0, wx.ALL|wx.EXPAND, 5 )
        #Crea el sizer para contener las etiquetas de la slider de release
        _soundreleaselabelsfgsizer = wx.FlexGridSizer( 1, 3, 0, 0 )
        _soundreleaselabelsfgsizer.SetFlexibleDirection( wx.BOTH )
        _soundreleaselabelsfgsizer.AddGrowableCol(1)
        #Creo el primer label de la slider de release
        self._minreleasetextctrl = wx.TextCtrl( self._specialsoundcongifpanel, wx.ID_ANY, u"0.01", wx.DefaultPosition, wx.Size( 50,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.ALIGN_LEFT )
        self._minreleasetextctrl.SetEditable(0)
        _soundreleaselabelsfgsizer.Add( self._minreleasetextctrl, 0, wx.ALL | wx.ALIGN_LEFT, 5 )
        #Creo el segundo label de la slider de release
        self._actualreleasetextctrl = wx.TextCtrl( self._specialsoundcongifpanel, wx.ID_ANY, u"0.25", wx.DefaultPosition, wx.Size( 50,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.ALIGN_LEFT )
        self._actualreleasetextctrl.SetEditable(0)
        _soundreleaselabelsfgsizer.Add( self._actualreleasetextctrl, 0, wx.ALL | wx.ALIGN_CENTRE, 5 )
        #Creo el tercer label de la slider de release
        self._maxreleasetextctrl = wx.TextCtrl( self._specialsoundcongifpanel, wx.ID_ANY, u"1", wx.DefaultPosition, wx.Size( 50,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.ALIGN_RIGHT )
        self._maxreleasetextctrl.SetEditable(0)
        _soundreleaselabelsfgsizer.Add( self._maxreleasetextctrl, 0, wx.ALL | wx.ALIGN_RIGHT, 5 )
        #Relaciona el sizer con el sizer del sonido
        _specialsoundconfigFgSizer.Add( _soundreleaselabelsfgsizer, 1, wx.EXPAND, 5 )
        
        #Crea el sizer para contener las etiquetas de la slider de attack
        _soundenvelopebuttonsfgsizer = wx.FlexGridSizer( 1, 2, 0, 0 )
        _soundenvelopebuttonsfgsizer.SetFlexibleDirection( wx.BOTH )
        #Crea el boton de dos estados para ocultar la grafica de la envolvente
        self._envelopegraphtogglebtn = wx.ToggleButton(
            parent = self._specialsoundcongifpanel,
            id = wx.ID_ANY,
            label = 'Hide envelope\nplot',
            pos = wx.DefaultPosition,
            size = wx.DefaultSize,
            style = 0,
            name = 'Envelope plot toggle button'
            )
        self._envelopegraphtogglebtn.Bind(
            event = wx.EVT_TOGGLEBUTTON,
            handler = self._eventenvelopegraph
            )
        self._envelopegraphtogglebtn.SetValue(True)
        _soundenvelopebuttonsfgsizer.Add(
            window = self._envelopegraphtogglebtn,
            proportion = 1,
            flag = wx.ALL | wx.ALIGN_CENTER_HORIZONTAL,
            border = 5
            )
        
        #Crea el boton de dos estados para reproducir la grafica de la envolvente
        self._envelopeplaytogglebtn = wx.ToggleButton(
            parent = self._specialsoundcongifpanel,
            id = wx.ID_ANY,
            label = 'Play envelope\nsound',
            pos = wx.DefaultPosition,
            size = wx.DefaultSize,
            style = 0,
            name = 'Play/Stop envelope toggle button'
            )
        self._envelopeplaytogglebtn.Bind(
            event = wx.EVT_TOGGLEBUTTON,
            handler = self._eventenvelopeplay
            )
        self._envelopeplaytogglebtn.SetValue(False)
        _soundenvelopebuttonsfgsizer.Add(
            window = self._envelopeplaytogglebtn,
            proportion = 1,
            flag = wx.ALL | wx.ALIGN_CENTER_HORIZONTAL,
            border = 5
            )
        
        _specialsoundconfigFgSizer.Add( _soundenvelopebuttonsfgsizer, 1, wx.EXPAND, 5 )
        
        # Crea el panel para contener el grafico de la envolvente y un sizer
        # para contenerlo
        self._envelopegraphpanel = wx.Panel(
            parent = self._specialsoundcongifpanel,
            id = wx.ID_ANY,
            pos = wx.DefaultPosition,
            size = wx.Size(300,150),
            style = wx.TAB_TRAVERSAL,
            name = 'Envelope graph panel'
            )
        _envelopegraphsizer = wx.FlexGridSizer(
            rows = 1,
            cols = 1,
            vgap = 0,
            hgap = 0
            )
        _envelopegraphsizer.AddGrowableCol(0)
        _envelopegraphsizer.AddGrowableRow(0)
        _envelopegraphsizer.SetFlexibleDirection(direction = wx.BOTH)
        # Crea la figura, el canvas que la contiene y agrega un subplot llamado
        # axes que se utilizara en el codigo principal
        self._envelopefigure = Figure()
        self._axesenvelopegraph = self._envelopefigure.add_subplot(111)
        self._envelopecanvas = FigureCanvas(self._envelopegraphpanel, -1, self._envelopefigure)
        self._envelopecanvas.SetMinSize(wx.Size(10,10))
        self._envelopecanvas.SetToolTip('Displays the envelope of the sound setted by the user.')
        #Agrega el canvas que relaciona la figura con el panel al sizer del panel del grafico
        _envelopegraphsizer.Add( self._envelopecanvas, 1, wx.EXPAND |wx.ALL, 5 )
        #Relaciona el panel del grafico con su propio sizer y lo agrega al sizer del panel Display
        self._envelopegraphpanel.SetSizer( _envelopegraphsizer )
        self._envelopegraphpanel.Layout()
        _envelopegraphsizer.Fit( self._envelopegraphpanel )
        _specialsoundconfigFgSizer.Add( self._envelopegraphpanel, 1, wx.EXPAND |wx.ALL, 5 )

        #Relaciona el panel de configuraciones con su propio sizer y lo agrega al sizer del panel izquierdo
        self._specialsoundcongifpanel.SetSizer( _specialsoundconfigFgSizer )
        self._specialsoundcongifpanel.Layout()
        _specialsoundconfigFgSizer.Fit( self._specialsoundcongifpanel )
        _soundFontFgSizer.Add( self._specialsoundcongifpanel, 1, wx.EXPAND |wx.ALL, 5 )
        self._specialsoundcongifpanel.Hide()


        #Relaciona el sizer con el panel de las configuraciones de sonido y lo agrega al sizer del panel de configuraciones
        self._soundFontPanel.SetSizer( _soundFontFgSizer )
        self._soundFontPanel.Layout()
        _soundFontFgSizer.Fit( self._soundFontPanel )
        _configFgSizer.Add( self._soundFontPanel, 1, wx.EXPAND |wx.ALL, 5 )
        self._soundFontPanel.Hide()

        # #Crea el boton de dos estados para abrir el panel de configuracion
        # #especial de sonido
        # self._specialConfigSoundToggleBtn = wx.ToggleButton( congifpanel, wx.ID_ANY, u"Show Special Sound\nConfigurations", wx.DefaultPosition, wx.DefaultSize, 0 )
        # self._specialConfigSoundToggleBtn.Bind( wx.EVT_TOGGLEBUTTON, self._eventSpecialSoundConfig )
        # self._specialConfigSoundToggleBtn.SetValue( False )
        # _configFgSizer.Add( self._specialConfigSoundToggleBtn, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL , 5 )

        # #crea el panel Configuraciones especiales de sonido con su sizer(row(2)col(2)) sin seccion expandida
        # self._specialsoundcongifpanel = wx.Panel( congifpanel, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.TAB_TRAVERSAL )
        # _specialsoundconfigFgSizer = wx.FlexGridSizer( 15, 1, 0, 0 )
        # _specialsoundconfigFgSizer.SetFlexibleDirection( wx.BOTH )
        # _specialsoundconfigFgSizer.SetNonFlexibleGrowMode( wx.FLEX_GROWMODE_SPECIFIED )
        # #Crea el label sound envelope and append it to sound font config panel
        # self._soundspecialconfigtextctrl = wx.TextCtrl(
        #     self._specialsoundcongifpanel,
        #     wx.ID_ANY,
        #     u"Sound envelop configuration:",
        #     wx.DefaultPosition,
        #     wx.Size( 160,15 ),
        #     style = wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL
        #     )
        # self._soundspecialconfigtextctrl.SetEditable(0)
        # _specialsoundconfigFgSizer.Add( self._soundspecialconfigtextctrl, 0, wx.ALL, 5 )

        # #Crea el espacio de texto con el label attack y lo agrega al sizer del panel de configuración de sonido
        # self._soundattacktextctrl = wx.TextCtrl( self._specialsoundcongifpanel, wx.ID_ANY, u"Attack:", wx.DefaultPosition, wx.Size( 90,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL )
        # self._soundattacktextctrl.SetEditable(0)
        # _specialsoundconfigFgSizer.Add( self._soundattacktextctrl, 0, wx.ALL, 5 )
        # #Crea la slider para el parametro attack
        # self._soundattackslider = wx.Slider( self._specialsoundcongifpanel, wx.ID_ANY, 25, 1, 100, wx.DefaultPosition, wx.DefaultSize, wx.SL_HORIZONTAL )
        # self._soundattackslider.Bind( wx.EVT_KEY_UP, self._eventsoundattack )
        # self._soundattackslider.Bind( wx.EVT_SCROLL, self._eventsoundattack )
        # _specialsoundconfigFgSizer.Add( self._soundattackslider, 0, wx.ALL|wx.EXPAND, 5 )
        # #Crea el sizer para contener las etiquetas de la slider de attack
        # _soundattacklabelsfgsizer = wx.FlexGridSizer( 1, 3, 0, 0 )
        # _soundattacklabelsfgsizer.SetFlexibleDirection( wx.BOTH )
        # _soundattacklabelsfgsizer.AddGrowableCol(1)
        # #Creo el primer label de la slider de attack
        # self._minattacktextctrl = wx.TextCtrl( self._specialsoundcongifpanel, wx.ID_ANY, u"0.01", wx.DefaultPosition, wx.Size( 50,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.ALIGN_LEFT )
        # self._minattacktextctrl.SetEditable(0)
        # _soundattacklabelsfgsizer.Add( self._minattacktextctrl, 0, wx.ALL | wx.ALIGN_LEFT, 5 )
        # #Creo el segundo label de la slider de attack
        # self._actualattacktextctrl = wx.TextCtrl( self._specialsoundcongifpanel, wx.ID_ANY, u"0.25", wx.DefaultPosition, wx.Size( 50,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.ALIGN_LEFT )
        # self._actualattacktextctrl.SetEditable(0)
        # _soundattacklabelsfgsizer.Add( self._actualattacktextctrl, 0, wx.ALL | wx.ALIGN_CENTRE, 5 )
        # #Creo el tercer label de la slider de attack
        # self._maxattacktextctrl = wx.TextCtrl( self._specialsoundcongifpanel, wx.ID_ANY, u"1", wx.DefaultPosition, wx.Size( 50,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.ALIGN_RIGHT )
        # self._maxattacktextctrl.SetEditable(0)
        # _soundattacklabelsfgsizer.Add( self._maxattacktextctrl, 0, wx.ALL | wx.ALIGN_RIGHT, 5 )
        # #Relaciona el sizer con el sizer del sonido
        # _specialsoundconfigFgSizer.Add( _soundattacklabelsfgsizer, 1, wx.EXPAND, 5 )
        # #Crea el espacio de texto con el label decay y lo agrega al sizer del panel de configuración de sonido
        # self._sounddecaytextctrl = wx.TextCtrl( self._specialsoundcongifpanel, wx.ID_ANY, u"Decay:", wx.DefaultPosition, wx.Size( 90,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL )
        # self._sounddecaytextctrl.SetEditable(0)
        # _specialsoundconfigFgSizer.Add( self._sounddecaytextctrl, 0, wx.ALL, 5 )
        # #Crea la slider para el parametro decay
        # self._sounddecayslider = wx.Slider( self._specialsoundcongifpanel, wx.ID_ANY, 25, 1, 100, wx.DefaultPosition, wx.DefaultSize, wx.SL_HORIZONTAL )
        # self._sounddecayslider.Bind( wx.EVT_KEY_UP, self._eventsounddecay )
        # self._sounddecayslider.Bind( wx.EVT_SCROLL, self._eventsounddecay )
        # _specialsoundconfigFgSizer.Add( self._sounddecayslider, 0, wx.ALL|wx.EXPAND, 5 )
        # #Crea el sizer para contener las etiquetas de la slider de decay
        # _sounddecaylabelsfgsizer = wx.FlexGridSizer( 1, 3, 0, 0 )
        # _sounddecaylabelsfgsizer.SetFlexibleDirection( wx.BOTH )
        # _sounddecaylabelsfgsizer.AddGrowableCol(1)
        # #Creo el primer label de la slider de decay
        # self._mindecaytextctrl = wx.TextCtrl( self._specialsoundcongifpanel, wx.ID_ANY, u"0.01", wx.DefaultPosition, wx.Size( 50,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.ALIGN_LEFT )
        # self._mindecaytextctrl.SetEditable(0)
        # _sounddecaylabelsfgsizer.Add( self._mindecaytextctrl, 0, wx.ALL | wx.ALIGN_LEFT, 5 )
        # #Creo el segundo label de la slider de decay
        # self._actualdecaytextctrl = wx.TextCtrl( self._specialsoundcongifpanel, wx.ID_ANY, u"0.25", wx.DefaultPosition, wx.Size( 50,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.ALIGN_LEFT )
        # self._actualdecaytextctrl.SetEditable(0)
        # _sounddecaylabelsfgsizer.Add( self._actualdecaytextctrl, 0, wx.ALL | wx.ALIGN_CENTRE, 5 )
        # #Creo el tercer label de la slider de decay
        # self._maxdecaytextctrl = wx.TextCtrl( self._specialsoundcongifpanel, wx.ID_ANY, u"1", wx.DefaultPosition, wx.Size( 50,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.ALIGN_RIGHT )
        # self._maxdecaytextctrl.SetEditable(0)
        # _sounddecaylabelsfgsizer.Add( self._maxdecaytextctrl, 0, wx.ALL | wx.ALIGN_RIGHT, 5 )
        # #Relaciona el sizer con el sizer del sonido
        # _specialsoundconfigFgSizer.Add( _sounddecaylabelsfgsizer, 1, wx.EXPAND, 5 )
        # #Crea el espacio de texto con el label sustain y lo agrega al sizer del panel de configuración de sonido
        # self._soundsustaintextctrl = wx.TextCtrl( self._specialsoundcongifpanel, wx.ID_ANY, u"Sustain:", wx.DefaultPosition, wx.Size( 90,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL )
        # self._soundsustaintextctrl.SetEditable(0)
        # _specialsoundconfigFgSizer.Add( self._soundsustaintextctrl, 0, wx.ALL, 5 )
        # #Crea la slider para el parametro sustain
        # self._soundsustainslider = wx.Slider( self._specialsoundcongifpanel, wx.ID_ANY, 50, 0, 100, wx.DefaultPosition, wx.DefaultSize, wx.SL_HORIZONTAL )
        # self._soundsustainslider.Bind( wx.EVT_KEY_UP, self._eventsoundsustain )
        # self._soundsustainslider.Bind( wx.EVT_SCROLL, self._eventsoundsustain )
        # _specialsoundconfigFgSizer.Add( self._soundsustainslider, 0, wx.ALL|wx.EXPAND, 5 )
        # #Crea el sizer para contener las etiquetas de la slider de sustain
        # _soundsustainlabelsfgsizer = wx.FlexGridSizer( 1, 3, 0, 0 )
        # _soundsustainlabelsfgsizer.SetFlexibleDirection( wx.BOTH )
        # _soundsustainlabelsfgsizer.AddGrowableCol(1)
        # #Creo el primer label de la slider de sustain
        # self._minsustaintextctrl = wx.TextCtrl( self._specialsoundcongifpanel, wx.ID_ANY, u"0", wx.DefaultPosition, wx.Size( 50,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.ALIGN_LEFT )
        # self._minsustaintextctrl.SetEditable(0)
        # _soundsustainlabelsfgsizer.Add( self._minsustaintextctrl, 0, wx.ALL | wx.ALIGN_LEFT, 5 )
        # #Creo el segundo label de la slider de sustain
        # self._actualsustaintextctrl = wx.TextCtrl( self._specialsoundcongifpanel, wx.ID_ANY, u"50", wx.DefaultPosition, wx.Size( 50,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.ALIGN_LEFT )
        # self._actualsustaintextctrl.SetEditable(0)
        # _soundsustainlabelsfgsizer.Add( self._actualsustaintextctrl, 0, wx.ALL | wx.ALIGN_CENTRE, 5 )
        # #Creo el tercer label de la slider de sustain
        # self._maxsustaintextctrl = wx.TextCtrl( self._specialsoundcongifpanel, wx.ID_ANY, u"100", wx.DefaultPosition, wx.Size( 50,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.ALIGN_RIGHT )
        # self._maxsustaintextctrl.SetEditable(0)
        # _soundsustainlabelsfgsizer.Add( self._maxsustaintextctrl, 0, wx.ALL | wx.ALIGN_RIGHT, 5 )
        # #Relaciona el sizer con el sizer del sonido
        # _specialsoundconfigFgSizer.Add( _soundsustainlabelsfgsizer, 1, wx.EXPAND, 5 )
        # #Crea el espacio de texto con el label release y lo agrega al sizer del panel de configuración de sonido
        # self._soundreleasetextctrl = wx.TextCtrl( self._specialsoundcongifpanel, wx.ID_ANY, u"Release:", wx.DefaultPosition, wx.Size( 90,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL )
        # self._soundreleasetextctrl.SetEditable(0)
        # _specialsoundconfigFgSizer.Add( self._soundreleasetextctrl, 0, wx.ALL, 5 )
        # #Crea la slider para el parametro release
        # self._soundreleaseslider = wx.Slider( self._specialsoundcongifpanel, wx.ID_ANY, 25, 1, 100, wx.DefaultPosition, wx.DefaultSize, wx.SL_HORIZONTAL )
        # self._soundreleaseslider.Bind( wx.EVT_KEY_UP, self._eventsoundrelease )
        # self._soundreleaseslider.Bind( wx.EVT_SCROLL, self._eventsoundrelease )
        # _specialsoundconfigFgSizer.Add( self._soundreleaseslider, 0, wx.ALL|wx.EXPAND, 5 )
        # #Crea el sizer para contener las etiquetas de la slider de release
        # _soundreleaselabelsfgsizer = wx.FlexGridSizer( 1, 3, 0, 0 )
        # _soundreleaselabelsfgsizer.SetFlexibleDirection( wx.BOTH )
        # _soundreleaselabelsfgsizer.AddGrowableCol(1)
        # #Creo el primer label de la slider de release
        # self._minreleasetextctrl = wx.TextCtrl( self._specialsoundcongifpanel, wx.ID_ANY, u"0.01", wx.DefaultPosition, wx.Size( 50,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.ALIGN_LEFT )
        # self._minreleasetextctrl.SetEditable(0)
        # _soundreleaselabelsfgsizer.Add( self._minreleasetextctrl, 0, wx.ALL | wx.ALIGN_LEFT, 5 )
        # #Creo el segundo label de la slider de release
        # self._actualreleasetextctrl = wx.TextCtrl( self._specialsoundcongifpanel, wx.ID_ANY, u"0.25", wx.DefaultPosition, wx.Size( 50,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.ALIGN_LEFT )
        # self._actualreleasetextctrl.SetEditable(0)
        # _soundreleaselabelsfgsizer.Add( self._actualreleasetextctrl, 0, wx.ALL | wx.ALIGN_CENTRE, 5 )
        # #Creo el tercer label de la slider de release
        # self._maxreleasetextctrl = wx.TextCtrl( self._specialsoundcongifpanel, wx.ID_ANY, u"1", wx.DefaultPosition, wx.Size( 50,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.ALIGN_RIGHT )
        # self._maxreleasetextctrl.SetEditable(0)
        # _soundreleaselabelsfgsizer.Add( self._maxreleasetextctrl, 0, wx.ALL | wx.ALIGN_RIGHT, 5 )
        # #Relaciona el sizer con el sizer del sonido
        # _specialsoundconfigFgSizer.Add( _soundreleaselabelsfgsizer, 1, wx.EXPAND, 5 )
        # #Crea el boton de dos estados para ocultar la grafica de la envolvente
        # self._envelopegraphtogglebtn = wx.ToggleButton(
        #     parent = self._specialsoundcongifpanel,
        #     id = wx.ID_ANY,
        #     label = 'Hide envelope\nplot',
        #     pos = wx.DefaultPosition,
        #     size = wx.DefaultSize,
        #     style = 0,
        #     name = 'Envelope plot toggle button'
        #     )
        # self._envelopegraphtogglebtn.Bind(
        #     event = wx.EVT_TOGGLEBUTTON,
        #     handler = self._eventenvelopegraph
        #     )
        # self._envelopegraphtogglebtn.SetValue(True)
        # _specialsoundconfigFgSizer.Add(
        #     window = self._envelopegraphtogglebtn,
        #     proportion = 1,
        #     flag = wx.ALL | wx.ALIGN_CENTER_HORIZONTAL,
        #     border = 5
        #     )
        # # Crea el panel para contener el grafico de la envolvente y un sizer
        # # para contenerlo
        # self._envelopegraphpanel = wx.Panel(
        #     parent = self._specialsoundcongifpanel,
        #     id = wx.ID_ANY,
        #     pos = wx.DefaultPosition,
        #     size = wx.Size(300,150),
        #     style = wx.TAB_TRAVERSAL,
        #     name = 'Envelope graph panel'
        #     )
        # _envelopegraphsizer = wx.FlexGridSizer(
        #     rows = 1,
        #     cols = 1,
        #     vgap = 0,
        #     hgap = 0
        #     )
        # _envelopegraphsizer.SetFlexibleDirection(direction = wx.BOTH)
        # # Crea la figura, el canvas que la contiene y agrega un subplot llamado
        # # axes que se utilizara en el codigo principal
        # self._envelopefigure = Figure()
        # self._axesenvelopegraph = self._envelopefigure.add_subplot(111)
        # self._envelopecanvas = FigureCanvas(self._envelopegraphpanel, -1, self._envelopefigure)
        # self._envelopecanvas.SetToolTip('Displays the envelope of the sound setted by the user.')
        # #Agrega el canvas que relaciona la figura con el panel al sizer del panel del grafico
        # _envelopegraphsizer.Add( self._envelopecanvas, 1, wx.EXPAND |wx.ALL, 5 )
        # #Relaciona el panel del grafico con su propio sizer y lo agrega al sizer del panel Display
        # self._envelopegraphpanel.SetSizer( _envelopegraphsizer )
        # self._envelopegraphpanel.Layout()
        # _envelopegraphsizer.Fit( self._envelopegraphpanel )
        # _specialsoundconfigFgSizer.Add( self._envelopegraphpanel, 1, wx.EXPAND |wx.ALL, 5 )

        # #Relaciona el panel de configuraciones con su propio sizer y lo agrega al sizer del panel izquierdo
        # self._specialsoundcongifpanel.SetSizer( _specialsoundconfigFgSizer )
        # self._specialsoundcongifpanel.Layout()
        # _specialsoundconfigFgSizer.Fit( self._specialsoundcongifpanel )
        # _configFgSizer.Add( self._specialsoundcongifpanel, 1, wx.EXPAND |wx.ALL, 5 )
        # self._specialsoundcongifpanel.Hide()

    #Crea el boton de dos estados Plot Configurations, lo setea como presionado y lo agrega al sizer del panel Configuraciones
        self._configPlotToggleBtn = wx.ToggleButton( congifpanel, wx.ID_ANY, u"Show Plot\nConfigurations", wx.DefaultPosition, wx.DefaultSize, 0 )
        self._configPlotToggleBtn.Bind( wx.EVT_TOGGLEBUTTON, self._eventConfigPlot )
        self._configPlotToggleBtn.SetValue( False )
        _configFgSizer.Add( self._configPlotToggleBtn, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL , 5 )
    #Crea el panel para desplegar las configuraciones del grafico y su sizer(row(4)col(2)) sin seccion expandida
        self._configPlotPanel = wx.Panel( congifpanel, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.TAB_TRAVERSAL )
        _configPlotFgSizer = wx.FlexGridSizer( 4, 2, 0, 0 )
        _configPlotFgSizer.SetFlexibleDirection( wx.BOTH )
        _configPlotFgSizer.SetNonFlexibleGrowMode( wx.FLEX_GROWMODE_SPECIFIED )
        #Crea el texto estatico Line Style y lo agrega al sizer del panel de configuraciones del grafico
        self._lineStileTextCtrl = wx.TextCtrl( self._configPlotPanel, wx.ID_ANY, u"Line Style:", wx.DefaultPosition, wx.Size( 90,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL )
        self._lineStileTextCtrl.SetEditable(0)
        _configPlotFgSizer.Add( self._lineStileTextCtrl, 0, wx.ALL, 5 )
        #Crea el cuadro de seleccion entre opciones de estilo de linea para el grafico, setea una eleccion por defecto y lo agrega al sizer del panel de configuraciones del grafico
        _lineStyleChoiceChoices = [ u"Discreet", u"Solid line", u"Dashed line", u"Dash-dot line", u"Dotted line" ]
        self._lineStyleChoice = wx.Choice( self._configPlotPanel, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, _lineStyleChoiceChoices, 0 )
        self._lineStyleChoice.Bind( wx.EVT_CHOICE, self._eventLineStyleConfig )
        self._lineStyleChoice.SetSelection( 1 )
        _configPlotFgSizer.Add( self._lineStyleChoice, 0, wx.ALL, 5 )
        #Crea el texto estatico Marker Style y lo agrega al sizer del panel de configuraciones del grafico
        self._markerTextCtrl = wx.TextCtrl( self._configPlotPanel, wx.ID_ANY, u"Marker Style:", wx.DefaultPosition, wx.Size( 90,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL )
        self._markerTextCtrl.SetEditable(0)
        _configPlotFgSizer.Add( self._markerTextCtrl, 0, wx.ALL, 5 )
        #Crea el cuadro de seleccion entre opciones de estilo de marcadores para el grafico, setea una eleccion por defecto y lo agrega al sizer del panel de configuraciones del grafico
        _markerStyleChoiceChoices = [ u"Point", u"Pixel", u"Circle", u"Triangle down", u"Triangle up", u"Triangle left", u"Triangle right", u"Tri down", u"Tri up", u"Tri left", u"Tri right", u"Square", u"Pentagon", u"Star", u"Hexagon 1", u"Hexagon 2", u"Plus", u"X", u"Diamond", u"Thin diamond", u"Vertical line", u"Horizontal line", u"Any" ]
        self._markerStyleChoice = wx.Choice( self._configPlotPanel, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, _markerStyleChoiceChoices, 0 )
        self._markerStyleChoice.Bind( wx.EVT_CHOICE, self._eventMarkerStyleConfig )
        self._markerStyleChoice.SetSelection( 22 )
        _configPlotFgSizer.Add( self._markerStyleChoice, 0, wx.ALL, 5 )
        #Crea el texto estatico Color Style y lo agrega al sizer del panel de configuraciones del grafico
        #Cambiar static text
        self._colorTextCtrl = wx.TextCtrl( self._configPlotPanel, wx.ID_ANY, u"Color Style:", wx.DefaultPosition, wx.Size( 90,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL )
        self._colorTextCtrl.SetEditable(0)
        _configPlotFgSizer.Add( self._colorTextCtrl, 0, wx.ALL, 5 )
        #Crea el cuadro de seleccion entre opciones de colores para el grafico, setea una eleccion por defecto y lo agrega al sizer del panel de configuraciones del grafico
        _colorStyleChoiceChoices = [ u"Blue", u"Green", u"Red", u"Cyan", u"Magenta", u"Yellow", u"Black" ]
        self._colorStyleChoice = wx.Choice( self._configPlotPanel, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, _colorStyleChoiceChoices, 0 )
        self._colorStyleChoice.Bind( wx.EVT_CHOICE, self._eventColorStyleConfig )
        self._colorStyleChoice.SetSelection( 0 )
        _configPlotFgSizer.Add( self._colorStyleChoice, 0, wx.ALL, 5 )
        #Agregamos configuración para la Grid
        self._gridChoice = wx.CheckBox( self._configPlotPanel, wx.ID_ANY, label=u"Grid option: ", pos=wx.DefaultPosition, size=wx.DefaultSize, style=wx.ALIGN_RIGHT, name=u"Grid check box")
        self._gridChoice.Bind( wx.EVT_CHECKBOX, self._eventGridChoice )
        _configPlotFgSizer.Add( self._gridChoice, 0, wx.ALL, 5)
        self._gridChoice.SetValue(False)
        #Panel de los stylos de grid
        self._plotGridPanel = wx.Panel( self._configPlotPanel, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.TAB_TRAVERSAL )
        _plotGridFgSizer = wx.FlexGridSizer( 3, 2, 0, 0 )
        _plotGridFgSizer.SetFlexibleDirection( wx.BOTH )
        _plotGridFgSizer.SetNonFlexibleGrowMode( wx.FLEX_GROWMODE_SPECIFIED )
        #Color style
        self._gridColorTextCtrl = wx.TextCtrl( self._plotGridPanel, wx.ID_ANY, u"Color:", wx.DefaultPosition, wx.Size( 50,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL )
        self._gridColorTextCtrl.SetEditable(0)
        _plotGridFgSizer.Add( self._gridColorTextCtrl, 0, wx.ALL, 5 )
        _gridColorChoiceChoices = [ u"Blue", u"Green", u"Red", u"Cyan", u"Magenta", u"Yellow", u"Black", u"White" ]
        self._gridColorChoice = wx.Choice( self._plotGridPanel, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, _gridColorChoiceChoices, 0 )
        self._gridColorChoice.Bind( wx.EVT_CHOICE, self._eventGridColorChoice )
        self._gridColorChoice.SetSelection( 6 )
        _plotGridFgSizer.Add( self._gridColorChoice, 0, wx.ALL, 5 )
        #Line style
        self._gridLineTextCtrl = wx.TextCtrl( self._plotGridPanel, wx.ID_ANY, u"Line:", wx.DefaultPosition, wx.Size( 50,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL )
        self._gridLineTextCtrl.SetEditable(0)
        _plotGridFgSizer.Add( self._gridLineTextCtrl, 0, wx.ALL, 5 )
        _gridLineChoiceChoices = [ u"Solid line", u"Dashed line", u"Dash-dot line", u"Dotted line" ]
        self._gridLineChoice = wx.Choice( self._plotGridPanel, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, _gridLineChoiceChoices, 0 )
        self._gridLineChoice.Bind( wx.EVT_CHOICE, self._eventGridLineChoice )
        self._gridLineChoice.SetSelection( 1 )
        _plotGridFgSizer.Add( self._gridLineChoice, 0, wx.ALL, 5 )
        #Ancho
        self._gridWidthTextCtrl = wx.TextCtrl( self._plotGridPanel, wx.ID_ANY, u"Width:", wx.DefaultPosition, wx.Size( 50,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL )
        self._gridWidthTextCtrl.SetEditable(0)
        _plotGridFgSizer.Add( self._gridWidthTextCtrl, 0, wx.ALL, 5 )
        self._gridWidthSpinCtrl = wx.SpinCtrlDouble( self._plotGridPanel, wx.ID_ANY, u" ", wx.DefaultPosition, wx.Size( 100,-1 ), wx.SP_ARROW_KEYS|wx.TE_PROCESS_ENTER, 0, 100, 0.5, 0.1, name=u"Grid width spin control" )
        self._gridWidthSpinCtrl.Bind( wx.EVT_SPINCTRLDOUBLE, self._eventGridWidthSpinCtrl )
        _plotGridFgSizer.Add( self._gridWidthSpinCtrl, 0, wx.ALL, 5 )
        #Relaciona el sizer con el panel
        self._plotGridPanel.SetSizer( _plotGridFgSizer )
        self._plotGridPanel.Layout()
        _plotGridFgSizer.Fit( self._plotGridPanel )
        _configPlotFgSizer.Add( self._plotGridPanel, 1, wx.EXPAND |wx.ALL, 5 )
        self._plotGridPanel.Hide()
        #Relaciona el sizer con el panel de las configuraciones del grafico y lo agrega al sizer del panel de configuraciones
        self._configPlotPanel.SetSizer( _configPlotFgSizer )
        self._configPlotPanel.Layout()
        _configPlotFgSizer.Fit( self._configPlotPanel )
        _configFgSizer.Add( self._configPlotPanel, 1, wx.EXPAND |wx.ALL, 5 )
        self._configPlotPanel.Hide()
        #Relaciona el panel de configuraciones con su propio sizer y lo agrega al sizer del panel izquierdo
        congifpanel.SetSizer( _configFgSizer )
        congifpanel.Layout()
        _configFgSizer.Fit( congifpanel )
        return congifpanel

    def _createdisplaypanel(self, panel):
        # Create the display panel with its sizer (row(3)col(1))
        # the frame (row(0)col(0)) is expanded
        displaypanel = wx.Panel(
            parent = panel,
            id = wx.ID_ANY,
            pos = wx.DefaultPosition,
            size = wx.DefaultSize,
            style = wx.TAB_TRAVERSAL
            )
        _displayFgSizer = wx.FlexGridSizer(
            rows = 3,
            cols = 1,
            vgap = 0,
            hgap = 0
            )
        _displayFgSizer.AddGrowableCol(idx=0)
        _displayFgSizer.AddGrowableRow(idx=0)
        _displayFgSizer.SetFlexibleDirection(direction=wx.BOTH)
        # Create the graphic panel with its sizer
        self._graphicPanel = wx.Panel(
            parent = displaypanel,
            id = wx.ID_ANY,
            pos = wx.DefaultPosition,
            size = wx.Size(400,200),
            style = wx.TAB_TRAVERSAL
            )
        _matplotlibSizer = wx.FlexGridSizer(
            rows = 1,
            cols = 2,
            vgap = 0,
            hgap = 0
            )
        _matplotlibSizer.AddGrowableCol(idx=1)
        _matplotlibSizer.AddGrowableRow(idx=0)
        _matplotlibSizer.SetFlexibleDirection(direction=wx.BOTH)
        # Create input data panel and its elements inside a function
        self._createInputDataDisplayPanel(self._graphicPanel)
        # Add the panel to the sizer
        _matplotlibSizer.Add(
            window = self._openPanel,
            proportion = 1,
            flag = wx.EXPAND|wx.ALL,
            border = 5
            )
        self._openPanel.Hide()

        self._plotPanel = wx.ScrolledWindow(
            parent = displaypanel,
            id = wx.ID_ANY,
            pos = wx.DefaultPosition,
            size = wx.Size(400,200),
            style = wx.HSCROLL | wx.VSCROLL | wx.TAB_TRAVERSAL
            )
        _plotSizer = wx.FlexGridSizer(
            rows = 1,
            cols = 1,
            vgap = 0,
            hgap = 0
            )
        _plotSizer.AddGrowableCol(idx=0)
        _plotSizer.AddGrowableRow(idx=0)
        #Crea la figura, el canvas que la contiene y agrega un subplot llamado axes que se utilizara el en codigo principal
        self._figure = Figure()
        self._axes = self._figure.add_subplot(111)
        self._canvas = FigureCanvas(self._plotPanel, -1, self._figure)
        self._canvas.SetMinSize(wx.Size(1,1))
        self._canvas.SetToolTip( u"Displays the plot of the data opened by the user." )
        #Agrega el canvas que relaciona la figura con el panel al sizer del panel del grafico
        _plotSizer.Add( self._canvas, 1, wx.EXPAND |wx.ALL, 5 )
        
        self._plotPanel.SetSizer( _plotSizer )
        self._plotPanel.Layout()
        _plotSizer.Fit( self._plotPanel )
        _matplotlibSizer.Add( self._plotPanel, 1, wx.EXPAND |wx.ALL, 5 )
        
        #Relaciona el panel del grafico con su propio sizer y lo agrega al sizer del panel Display
        self._graphicPanel.SetSizer( _matplotlibSizer )
        self._graphicPanel.Layout()
        _matplotlibSizer.Fit( self._graphicPanel )
        _displayFgSizer.Add( self._graphicPanel, 1, wx.EXPAND |wx.ALL, 5 )

    #Crea el sizer de las slider de abscisas y tempo sin panel contenedor (row(1)col(2))
        _sliderDisplayGSizer = wx.GridSizer( 1, 2, 0, 0 )
        #Crea un sizer para contener el label y la slider de la posicion en abscisas(row(1)col(2)), con la seccion (row(0)col(1)) expandida
        _absPosFgSizer = wx.FlexGridSizer( 1, 2, 0, 0 )
        _absPosFgSizer.AddGrowableCol( 1 )
        _absPosFgSizer.SetFlexibleDirection( wx.BOTH )
        _absPosFgSizer.SetNonFlexibleGrowMode( wx.FLEX_GROWMODE_SPECIFIED )
        #Crea un espacio de texto con el label Abscissa Position y lo agrega al sizer de objetos relacionados con la posicion de abscisas.
        self._absPosTextCtrl = wx.TextCtrl( displaypanel, wx.ID_ANY, u"Abscissa Position:", wx.DefaultPosition, wx.Size( 125,30 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.TE_READONLY )
        #self._absPosTextCtrl.SetEditable(0)
        self._absPosTextCtrl.SetToolTip( u"Abscissa position label." )
        _absPosFgSizer.Add( self._absPosTextCtrl, 0, wx.ALIGN_RIGHT|wx.ALL, 5 )
        
        # Genero un sizer con 3 filas para el label superior, la slider y el
        # label inferior
        _abslabels_fgsizer = wx.FlexGridSizer(
            rows=3,
            cols=1,
            vgap=0,
            hgap=0
            )
        _abslabels_fgsizer.AddGrowableCol(0)
        
        # Create the element to show the position and allow to change it
        self._absposlabel_textctrl = wx.TextCtrl(
            parent = displaypanel,
            id = wx.ID_ANY,
            value = '0',
            pos = wx.DefaultPosition,
            size = wx.Size( 125,15 ),
            style = (wx.TE_PROCESS_ENTER
                | wx.TE_CENTRE
                | wx.BORDER_NONE
                | wx.TE_NO_VSCROLL
                ),
            name = 'Text element where you can set the x position.'
            )
        self._absposlabel_textctrl.SetBackgroundColour(
            colour = displaypanel.GetBackgroundColour()
            )
        self._absposlabel_textctrl.Bind(
            event = wx.EVT_TEXT_ENTER,
            handler = self._eventabsposition
            )
        _abslabels_fgsizer.Add(
            window=self._absposlabel_textctrl,
            proportion=0,
            flag=wx.ALIGN_CENTER,
            border=5
            )
        self._absposlabel_textctrl.SetToolTip('Text element'
                + ' where you can set the x position.')
        
        # Create the abscisa position slider ans append it to its sizer
        self._abspos_slider = wx.Slider(
            parent=displaypanel,
            id=wx.ID_ANY,
            value=0,
            minValue=0,
            maxValue=100,
            pos=wx.DefaultPosition,
            size=wx.Size( -1,-1 ),
            style=wx.SL_HORIZONTAL,
            name='Abscisa position slider'
            )
        self._abspos_slider.SetToolTip(
            'Abscisa position slider'
            )
        self._abspos_slider.Bind(
            event=wx.EVT_SCROLL,
            handler=self._eventAbsPos
            )
        self._abspos_slider.Bind(
            event=wx.EVT_SLIDER,
            handler=self._eventAbsPos
            )
        self._abspos_slider.Bind(
            event=wx.EVT_KEY_DOWN,
            handler=self._eventAbsPos
            )
        _abslabels_fgsizer.Add(
            window=self._abspos_slider,
            proportion=0,
            flag=wx.ALL|wx.EXPAND,
            border=5
            )
        
        # Create a sizer to min and max abscisa value
        _absminmaxlabel_fgsizer = wx.GridSizer(
            rows=1,
            cols=2,
            vgap=0,
            hgap=0
            )
        # Create min abscisa value element, read only
        self._absminlabel_textctrl = wx.TextCtrl(
            parent = displaypanel,
            id = wx.ID_ANY,
            value = '0',
            pos = wx.DefaultPosition,
            size = wx.Size( 100,15 ),
            style = (
                wx.TE_LEFT
                | wx.BORDER_NONE
                | wx.TE_MULTILINE
                | wx.TE_NO_VSCROLL
                ),
            name = 'Text element where you can find the x min position.'
            )
        self._absminlabel_textctrl.SetBackgroundColour(
            colour = displaypanel.GetBackgroundColour()
            )
        _absminmaxlabel_fgsizer.Add(
            window=self._absminlabel_textctrl,
            proportion=0,
            flag=wx.ALIGN_LEFT|wx.EXPAND|wx.ALL,
            border=1
            )
        self._absminlabel_textctrl.SetToolTip(
            'Text element where you can find the x min position.'
            )
        
        # Create max abscisa value element, read only
        self._absmaxlabel_textctrl = wx.TextCtrl(
            parent = displaypanel,
            id = wx.ID_ANY,
            value = '100',
            pos = wx.DefaultPosition,
            size = wx.Size( 100,15 ),
            style = (
                wx.TE_RIGHT
                | wx.BORDER_NONE
                | wx.TE_MULTILINE
                | wx.TE_NO_VSCROLL
                ),
            name = 'Text element where you can find the x max position.'
            )
        self._absmaxlabel_textctrl.SetBackgroundColour(
            colour = displaypanel.GetBackgroundColour()
            )
        _absminmaxlabel_fgsizer.Add(
            window=self._absmaxlabel_textctrl,
            proportion=0,
            flag=wx.ALIGN_RIGHT|wx.EXPAND|wx.ALL,
            border=1
            )
        self._absmaxlabel_textctrl.SetToolTip(
            'Text element where you can find the x max position.'
            )
        
        # Add minmax labels sizer to the labels sizer
        _abslabels_fgsizer.Add(
            sizer=_absminmaxlabel_fgsizer,
            proportion=0,
            flag=wx.EXPAND | wx.ALL,
            border=1
            )
        
        #Relaciona el sizer de filas con el sizer general de abscisas.
        _absPosFgSizer.Add( _abslabels_fgsizer, 1, wx.EXPAND, 5 )
        
        #Relaciona el sizer de abscisas con el sizer de abscisas y tempo.
        _sliderDisplayGSizer.Add( _absPosFgSizer, 1, wx.EXPAND, 5 )
        #Crea el sizer para contener el label y la slider del tempo (row(1)col(2)), con la seccion (row(0)col(1)) expandida
        _soundVelFgSizer = wx.FlexGridSizer( 1, 2, 0, 0 )
        _soundVelFgSizer.AddGrowableCol( 1 )
        _soundVelFgSizer.SetFlexibleDirection( wx.BOTH )
        _soundVelFgSizer.SetNonFlexibleGrowMode( wx.FLEX_GROWMODE_SPECIFIED )
        #Crea un espacio de texto con el label Tempo y lo agrega al sizer contenedor de los objetos tempo
        self._soundVelTextCtrl = wx.TextCtrl( displaypanel, wx.ID_ANY, u"Tempo:", wx.DefaultPosition, wx.Size( 60,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.TE_RIGHT )
        self._soundVelTextCtrl.SetEditable(0)
        self._soundVelTextCtrl.NavigateIn()
        self._soundVelTextCtrl.SetToolTip('This is the label of the tempo slider.')
        _soundVelFgSizer.Add( self._soundVelTextCtrl, 0, wx.ALIGN_RIGHT|wx.ALL, 5 )
        
        
        # Genero un sizer con 3 filas para el label superior, la slider y el
        # label inferior
        _tempolabels_fgsizer = wx.FlexGridSizer(
            rows=3,
            cols=1,
            vgap=0,
            hgap=0
            )
        _tempolabels_fgsizer.AddGrowableCol(0)
        
        # Create the element to show the position and allow to change it
        self._tempoposlabel_textctrl = wx.TextCtrl(
            parent = displaypanel,
            id = wx.ID_ANY,
            value = '50',
            pos = wx.DefaultPosition,
            size = wx.Size( 125,15 ),
            style = (wx.TE_PROCESS_ENTER
                | wx.TE_CENTRE
                | wx.BORDER_NONE
                | wx.TE_NO_VSCROLL
                ),
            name = 'Text element where you can set the tempo position.'
            )
        self._tempoposlabel_textctrl.SetBackgroundColour(
            colour = displaypanel.GetBackgroundColour()
            )
        self._tempoposlabel_textctrl.Bind(
            event = wx.EVT_TEXT_ENTER,
            handler = self._eventtempoposition
            )
        _tempolabels_fgsizer.Add(
            window=self._tempoposlabel_textctrl,
            proportion=0,
            flag=wx.ALIGN_CENTER,
            border=5
            )
        self._tempoposlabel_textctrl.SetToolTip('Text element'
                + ' where you can set the tempo position.')
        
        
        #Crea una slider para modificar el tempo y la agrega al sizer contenedor de los objetos tempo
        self._soundVelSlider = wx.Slider( displaypanel, wx.ID_ANY, 0, 0, 100, wx.DefaultPosition, wx.DefaultSize, wx.SL_HORIZONTAL )
        self._soundVelSlider.Bind( wx.EVT_KEY_UP, self._eventSoundVel )
        self._soundVelSlider.Bind( wx.EVT_SCROLL, self._eventSoundVel )
        self._soundVelSlider.SetToolTip('Tempo slider')
        _tempolabels_fgsizer.Add( self._soundVelSlider, 0, wx.ALL|wx.EXPAND, 5 )
        
        
        # Create a sizer to min and max abscisa value
        _tempominmaxlabel_fgsizer = wx.GridSizer(
            rows=1,
            cols=2,
            vgap=0,
            hgap=0
            )
        # Create min abscisa value element, read only
        self._tempominlabel_textctrl = wx.TextCtrl(
            parent = displaypanel,
            id = wx.ID_ANY,
            value = '0',
            pos = wx.DefaultPosition,
            size = wx.Size( 100,15 ),
            style = (
                wx.TE_LEFT
                | wx.BORDER_NONE
                | wx.TE_MULTILINE
                | wx.TE_NO_VSCROLL
                ),
            name = 'Text element where you can find the tempo min value.'
            )
        self._tempominlabel_textctrl.SetBackgroundColour(
            colour = displaypanel.GetBackgroundColour()
            )
        _tempominmaxlabel_fgsizer.Add(
            window=self._tempominlabel_textctrl,
            proportion=0,
            flag=wx.ALIGN_LEFT|wx.EXPAND|wx.ALL,
            border=1
            )
        self._tempominlabel_textctrl.SetToolTip(
            'Text element where you can find the tempo min value.'
            )
        
        # Create max abscisa value element, read only
        self._tempomaxlabel_textctrl = wx.TextCtrl(
            parent = displaypanel,
            id = wx.ID_ANY,
            value = '100',
            pos = wx.DefaultPosition,
            size = wx.Size( 100,15 ),
            style = (
                wx.TE_RIGHT
                | wx.BORDER_NONE
                | wx.TE_MULTILINE
                | wx.TE_NO_VSCROLL
                ),
            name = 'Text element where you can find the tempo max value.'
            )
        self._tempomaxlabel_textctrl.SetBackgroundColour(
            colour = displaypanel.GetBackgroundColour()
            )
        _tempominmaxlabel_fgsizer.Add(
            window=self._tempomaxlabel_textctrl,
            proportion=0,
            flag=wx.ALIGN_RIGHT|wx.EXPAND|wx.ALL,
            border=1
            )
        self._tempomaxlabel_textctrl.SetToolTip(
            'Text element where you can find the tempo max value.'
            )
        
        # Add minmax labels sizer to the labels sizer
        _tempolabels_fgsizer.Add(
            sizer=_tempominmaxlabel_fgsizer,
            proportion=0,
            flag=wx.EXPAND | wx.ALL,
            border=1
            )
        
        
        #Relaciona el sizer de filas con el sizer general de abscisas.
        _soundVelFgSizer.Add( _tempolabels_fgsizer, 1, wx.EXPAND, 5 )
        
        #Relaciona el sizer del tempo con el sizer de abscisas y tempo.
        _sliderDisplayGSizer.Add( _soundVelFgSizer, 1, wx.EXPAND, 5 )
        #Relaciona el sizer de las abscisas y tempo con el sizer del panel Display
        _displayFgSizer.Add( _sliderDisplayGSizer, 1, wx.EXPAND, 5 )

    #Crea el sizer de los botones de control de reproduccion sin panel contenedor (row(1)col(5))
        _buttonDisplayFgSizer = wx.FlexGridSizer( 1, 6, 0, 0 )
        _buttonDisplayFgSizer.SetFlexibleDirection( wx.BOTH )
        _buttonDisplayFgSizer.SetNonFlexibleGrowMode( wx.FLEX_GROWMODE_SPECIFIED )
        #Crea el boton Play y lo agrega al sizer de botones de control de reproduccion
        self._playButton = wx.ToggleButton( displaypanel, wx.ID_ANY, u"Play", wx.DefaultPosition, wx.DefaultSize, 0 )
        self._playButton.SetValue(False)
        self._playButton.Bind( wx.EVT_TOGGLEBUTTON, self._eventplay )
        self._playButton.SetToolTip('This button allow to play and pause the sound.')
        _buttonDisplayFgSizer.Add( self._playButton, 0, wx.ALL, 5 )
#        #Crea el boton Pause y lo agrega al sizer de botones de control de reproduccion
#        self._pauseButton = wx.Button( displaypanel, wx.ID_ANY, u"Pause", wx.DefaultPosition, wx.DefaultSize, 0 )
#        self._pauseButton.Bind( wx.EVT_BUTTON, self._eventPause )
#        _buttonDisplayFgSizer.Add( self._pauseButton, 0, wx.ALL, 5 )
        #Crea el boton Stop y lo agrega al sizer de botones de control de reproduccion
        self._stopButton = wx.Button( displaypanel, wx.ID_ANY, u"Stop", wx.DefaultPosition, wx.DefaultSize, 0 )
        self._stopButton.Bind( wx.EVT_BUTTON, self._eventstop )
        self._stopButton.SetToolTip('This button allow to stop the sound.')
        _buttonDisplayFgSizer.Add( self._stopButton, 0, wx.ALL, 5 )
        #Crea el boton Mark Point y lo agrega al sizer de botones de control de reproduccion
        self._markPtButton = wx.Button( displaypanel, wx.ID_ANY, u"Mark Point", wx.DefaultPosition, wx.DefaultSize, 0 )
        self._markPtButton.Bind( wx.EVT_BUTTON, self._eventmarkpoint )
        self._markPtButton.SetToolTip('This button allow to mark a point on the current position of the x slider bar.')
        _buttonDisplayFgSizer.Add( self._markPtButton, 0, wx.ALL, 5 )
        #Crea el boton Delete last mark y lo agrega al sizer de botones de control de reproduccion
        self._deleteLastPtButton = wx.Button( displaypanel, wx.ID_ANY, u"Delete last mark", wx.DefaultPosition, wx.DefaultSize, 0 )
        self._deleteLastPtButton.Bind( wx.EVT_BUTTON, self._eventdeletelastmark )
        self._deleteLastPtButton.SetToolTip('This button allow to delete the last mark done on the data.')
        _buttonDisplayFgSizer.Add( self._deleteLastPtButton, 0, wx.ALL, 5 )

        #Crea el boton de dos estados lineal vs logaritmic scale
        self._linvslog_soundscale_display_togglebtn = wx.ToggleButton( displaypanel, wx.ID_ANY, u"Set logarithmic scale", wx.DefaultPosition, wx.DefaultSize, 0 )
        self._linvslog_soundscale_display_togglebtn.Bind( wx.EVT_TOGGLEBUTTON, self._event_linvslog_soundscalechoice_display )
        self._linvslog_soundscale_display_togglebtn.SetValue( False )
        _buttonDisplayFgSizer.Add( self._linvslog_soundscale_display_togglebtn, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL , 5 )

        #Crea el boton
        self._contdiscsound_display_ToggleBtn = wx.ToggleButton( displaypanel, wx.ID_ANY, u"Set continuous sound", wx.DefaultPosition, wx.DefaultSize, 0 )
        self._contdiscsound_display_ToggleBtn.Bind( wx.EVT_TOGGLEBUTTON, self._eventcontdiscsoundchoice_display )
        self._contdiscsound_display_ToggleBtn.SetValue( False )
        _buttonDisplayFgSizer.Add( self._contdiscsound_display_ToggleBtn, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL , 5 )


        # #Crea el boton Plot Data Options y lo agrega al sizer de botones de control de reproduccion
        # self._dataParamPlotToggleBtn = wx.ToggleButton( displaypanel, wx.ID_ANY, u"Data Parameters", wx.DefaultPosition, wx.DefaultSize, 0 )
        # self._dataParamPlotToggleBtn.Bind( wx.EVT_TOGGLEBUTTON, self._eventcpdataparamplot )
        # self._dataParamPlotToggleBtn.SetToolTip('This button allow to show and hide the data information panel.')
        # _buttonDisplayFgSizer.Add( self._dataParamPlotToggleBtn, 0, wx.ALL, 5 )

        #Relaciona el sizer de botones de control de reproduccion con el sizer del panel Display
        _displayFgSizer.Add( _buttonDisplayFgSizer, 1, wx.ALIGN_CENTER, 5 )
        #Relaciona el panel Display con su propio sizer y lo agrega en el sizer del panel derecho
        displaypanel.SetSizer( _displayFgSizer )
        displaypanel.Layout()
        _displayFgSizer.Fit( displaypanel )
        return displaypanel

    def _createoperationpanel(self, panel):
        #Crea el panel Operation con su sizer(row(2)col(1)) y con el cuadro (row(0)col(0)) expandido
        operationpanel = wx.Panel( panel, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.TAB_TRAVERSAL )
        _operationFgSizer = wx.FlexGridSizer( 4, 1, 0, 0 )
        _operationFgSizer.AddGrowableCol( 0 )
        _operationFgSizer.AddGrowableRow( 1 )
        _operationFgSizer.SetFlexibleDirection( wx.BOTH )
        _operationFgSizer.SetNonFlexibleGrowMode( wx.FLEX_GROWMODE_SPECIFIED )

    #Crea el panel de la shell que se mantendrá oculto.
        self._pythonShellPanel = wx.Panel( operationpanel, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.TAB_TRAVERSAL )
        _pythonShellFgSizer = wx.FlexGridSizer( 1, 1, 0, 0 )
        _pythonShellFgSizer.AddGrowableCol( 0 )
        _pythonShellFgSizer.SetFlexibleDirection( wx.BOTH )
        _pythonShellFgSizer.SetNonFlexibleGrowMode( wx.FLEX_GROWMODE_SPECIFIED )
        self._createShell(self._pythonShellPanel)
        _pythonShellFgSizer.Add( self._pythonShell, 1, wx.EXPAND |wx.ALL, 5 )
        self._pythonShellPanel.Hide()
        #Relaciona el panel de operaciones con su sizer y lo agrega al sizer del panel principal derecho
        self._pythonShellPanel.SetSizer( _pythonShellFgSizer )
        self._pythonShellPanel.Layout()
        _pythonShellFgSizer.Fit( self._pythonShellPanel )
        _operationFgSizer.Add( self._pythonShellPanel, 1, wx.EXPAND |wx.ALL, 5 )

    #Crea el panel de la linea de comandos.
        self._writecommandpanel = wx.Panel( operationpanel, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.TAB_TRAVERSAL )
        _writecommandfgsizer = wx.FlexGridSizer(1, 2, 0, 0)
        _writecommandfgsizer.AddGrowableCol(1)
        _writecommandfgsizer.SetFlexibleDirection(wx.BOTH)
        #Aquí generamos los elementos, por ahora un text control que permite el
        #ingreso de texto
        self._writecommandlabeltextctrl = wx.TextCtrl(
            parent = self._writecommandpanel,
            id = wx.ID_ANY,
            value = 'Write functionality:',
            pos = wx.DefaultPosition,
            size = wx.Size(130, 20),
            style = wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.TE_RIGHT,
            name = ('Label of the text element where you can write the ')
                + ('functionalities.')
            )
        _writecommandfgsizer.Add(
            window = self._writecommandlabeltextctrl,
            proportion = 0,
            flag = wx.EXPAND|wx.ALL,
            border = 5
            )
        self._writecommandlabeltextctrl.SetToolTip('Label of the text element'
                + ' where you can write the functionalities.')
        self._writecommandlabeltextctrl.SetEditable(0)
        self._writecommandtextctrl = wx.TextCtrl(
            parent = self._writecommandpanel,
            id = wx.ID_ANY,
            value = '',
            pos = wx.DefaultPosition,
            size = wx.DefaultSize,
            style = wx.TE_PROCESS_ENTER,
            name = 'Text element where you can write the functionalities.'
            )
        self._writecommandtextctrl.Bind(
            event = wx.EVT_TEXT_ENTER,
            handler = self._eventwritecommand
            )
        _writecommandfgsizer.Add(
            window = self._writecommandtextctrl,
            proportion = 0,
            flag = wx.EXPAND|wx.ALL,
            border = 5
            )
        self._writecommandtextctrl.SetToolTip('Text element'
                + ' where you can write the functionalities.')

        #self._writecommandpanel.Hide()
        #Relaciona el panel de operaciones con su sizer y lo agrega al sizer del panel principal derecho
        self._writecommandpanel.SetSizer( _writecommandfgsizer )
        self._writecommandpanel.Layout()
        _writecommandfgsizer.Fit( self._writecommandpanel )
        _operationFgSizer.Add( self._writecommandpanel, 1, wx.EXPAND |wx.ALL, 5 )

    #Crea el panel Gnu Octave con su sizer (row(1)col(2)) y con el cuadro (row(1)col(0)) expandido
        self._gnuOctavePanel = wx.Panel( operationpanel, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.TAB_TRAVERSAL )
        _octaveFgSizer = wx.FlexGridSizer( 1, 2, 0, 0 )
        _octaveFgSizer.AddGrowableCol( 0 )
        _octaveFgSizer.SetFlexibleDirection( wx.BOTH )
        _octaveFgSizer.SetNonFlexibleGrowMode( wx.FLEX_GROWMODE_SPECIFIED )

        #Crea el sizer de los elementos izquierdos
        _octaveLeftFgSizer = wx.FlexGridSizer( 2, 2, 0, 0 )
        _octaveLeftFgSizer.AddGrowableCol( 1 )
        _octaveLeftFgSizer.AddGrowableRow( 1 )
        _octaveLeftFgSizer.SetFlexibleDirection( wx.BOTH )
        _octaveLeftFgSizer.SetNonFlexibleGrowMode( wx.FLEX_GROWMODE_SPECIFIED )
        #Crea el espacio de texto con el label Octave y lo agrega al sizer de GNU Octave
        self._octaveLabelInputTextCtrl = wx.TextCtrl( self._gnuOctavePanel, wx.ID_ANY, u"Octave command:", wx.DefaultPosition, wx.Size( 120,20 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.TE_RIGHT )
        _octaveLeftFgSizer.Add( self._octaveLabelInputTextCtrl, 0, wx.EXPAND | wx.ALL, 5 )
        self._octaveLabelInputTextCtrl.SetToolTip( u"" )
        self._octaveLabelInputTextCtrl.SetEditable(0)
        self._octaveInputTextCtrl = wx.TextCtrl( self._gnuOctavePanel, wx.ID_ANY, u" ", wx.DefaultPosition, wx.DefaultSize, wx.TE_PROCESS_ENTER )
        self._octaveInputTextCtrl.Bind( wx.EVT_TEXT_ENTER, self._eventOctaveInput )
        _octaveLeftFgSizer.Add( self._octaveInputTextCtrl, 0, wx.EXPAND | wx.ALL, 5 )
        self._octaveLabelInputTextCtrl.Hide()
        self._octaveInputTextCtrl.Hide()
        self._octaveLabelOutputTextCtrl = wx.TextCtrl( self._gnuOctavePanel, wx.ID_ANY, u"Octave info:", wx.DefaultPosition, wx.Size( 120,20 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.TE_RIGHT )
        _octaveLeftFgSizer.Add( self._octaveLabelOutputTextCtrl, 0, wx.EXPAND | wx.ALL, 5 )
        self._octaveLabelOutputTextCtrl.SetToolTip( u"" )
        self._octaveLabelOutputTextCtrl.SetEditable(0)
        self._octaveOutputTextCtrl = wx.TextCtrl( self._gnuOctavePanel, wx.ID_ANY, u" ", wx.DefaultPosition, wx.Size( -1,60 ), style=wx.TE_MULTILINE )
        _octaveLeftFgSizer.Add( self._octaveOutputTextCtrl, 0, wx.EXPAND | wx.ALL, 5 )
        self._octaveOutputTextCtrl.SetEditable(0)
        #Relaciona el sizer de la izquierda con el de octave
        _octaveFgSizer.Add( _octaveLeftFgSizer, 1, wx.EXPAND | wx.ALL, 5 )

#Se descartará esta parte por el momento para probar una forma más facil de comunicación.
        #Crea el sizer de los elementos derechos
        _octaveRightFgSizer = wx.FlexGridSizer( 3, 1, 0, 0 )
        _octaveRightFgSizer.SetFlexibleDirection( wx.BOTH )
        _octaveRightFgSizer.SetNonFlexibleGrowMode( wx.FLEX_GROWMODE_SPECIFIED )

#        #Crea el sizer para la parte superior
#        _octaveTopRightFgSizer = wx.FlexGridSizer( 1, 2, 0, 0 )
#        _octaveTopRightFgSizer.SetFlexibleDirection( wx.BOTH )
#        _octaveTopRightFgSizer.SetNonFlexibleGrowMode( wx.FLEX_GROWMODE_SPECIFIED )
#        #Crea los elementos para push
#        self._sendToOctaveLabelTextCtrl = wx.TextCtrl( self._gnuOctavePanel, wx.ID_ANY, u"Send to octave: ", wx.DefaultPosition, wx.Size( -1,30 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.TE_RIGHT )
#        _octaveTopRightFgSizer.Add( self._sendToOctaveLabelTextCtrl, 0, wx.EXPAND | wx.ALL, 5 )
#        self._sendToOctaveLabelTextCtrl.SetEditable(0)
#        self._sendToOctaveListBox = wx.ListBox( self._gnuOctavePanel, wx.ID_ANY, wx.DefaultPosition, wx.Size(-1,40), [""], 0 )
##        self._sendToOctaveListBox.Bind( wx.EVT_LISTBOX, self._eventSendToOctave )
#        self._sendToOctaveListBox.SetSelection( 0 )
#        _octaveTopRightFgSizer.Add( self._sendToOctaveListBox, 0, wx.ALL|wx.FIXED_MINSIZE, 5 )
#        #Relaciona el sizer de la parte superior con el de la derecha
#        _octaveRightFgSizer.Add( _octaveTopRightFgSizer, 1, wx.EXPAND | wx.ALL, 5 )

        #Crea el label de la parte central
        self._retFromOctaveLabelTextCtrl = wx.TextCtrl( self._gnuOctavePanel, wx.ID_ANY, u"Retrieve from octave:", wx.DefaultPosition, wx.Size( 120,20 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL )
        _octaveRightFgSizer.Add( self._retFromOctaveLabelTextCtrl, 0, wx.EXPAND | wx.ALL, 5 )
        self._retFromOctaveLabelTextCtrl.SetEditable(0)

        #Crea el sizer para la parte central
        _octaveCenterRightFgSizer = wx.FlexGridSizer( 2, 2, 0, 0 )
        _octaveCenterRightFgSizer.SetFlexibleDirection( wx.BOTH )
        _octaveCenterRightFgSizer.SetNonFlexibleGrowMode( wx.FLEX_GROWMODE_SPECIFIED )
        #Crea los elementos para pull
        self._xFromOctaveLabelTextCtrl = wx.TextCtrl( self._gnuOctavePanel, wx.ID_ANY, u"Name of x array: ", wx.DefaultPosition, wx.Size( 120,20 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.TE_RIGHT )
        _octaveCenterRightFgSizer.Add( self._xFromOctaveLabelTextCtrl, 0, wx.ALL, 5 )
        self._xFromOctaveLabelTextCtrl.SetEditable(0)
        self._xFromOctaveTextCtrl = wx.TextCtrl( self._gnuOctavePanel, wx.ID_ANY, u"", wx.DefaultPosition, wx.DefaultSize, wx.TE_PROCESS_ENTER )
        self._xFromOctaveTextCtrl.Bind( wx.EVT_TEXT_ENTER, self._eventXFromOctave )
        _octaveCenterRightFgSizer.Add( self._xFromOctaveTextCtrl, 0, wx.EXPAND | wx.ALL, 5 )
        self._yFromOctaveLabelTextCtrl = wx.TextCtrl( self._gnuOctavePanel, wx.ID_ANY, u"Name of y array: ", wx.DefaultPosition, wx.Size( 120,20 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.TE_RIGHT )
        _octaveCenterRightFgSizer.Add( self._yFromOctaveLabelTextCtrl, 0, wx.ALL, 5 )
        self._yFromOctaveLabelTextCtrl.SetEditable(0)
        self._yFromOctaveTextCtrl = wx.TextCtrl( self._gnuOctavePanel, wx.ID_ANY, u"", wx.DefaultPosition, wx.DefaultSize, wx.TE_PROCESS_ENTER )
        self._yFromOctaveTextCtrl.Bind( wx.EVT_TEXT_ENTER, self._eventYFromOctave )
        _octaveCenterRightFgSizer.Add( self._yFromOctaveTextCtrl, 0, wx.EXPAND | wx.ALL, 5 )
        #Relaciona el sizer de la parte central con el de la derecha
        _octaveRightFgSizer.Add( _octaveCenterRightFgSizer, 1, wx.EXPAND | wx.ALL, 5 )

        #Crea el botón para reiniciar la session
        self._octaveReplotButton = wx.Button( self._gnuOctavePanel, wx.ID_ANY, u"Refresh the plot", wx.DefaultPosition, wx.DefaultSize, 0 )
#        self._octaveReplotButton.Bind( wx.EVT_BUTTON, self._eventOctaveReplot )
        self._octaveReplotButton.Bind( wx.EVT_BUTTON, self._eventContinueReplotFromOctave )
        _octaveRightFgSizer.Add( self._octaveReplotButton, 0, wx.ALIGN_CENTER|wx.ALL, 5 )

        #Realciona el sizer de la derecha con el de octave
        _octaveFgSizer.Add( _octaveRightFgSizer, 1, wx.EXPAND | wx.ALL, 5 )

#        #Crea el botón para reiniciar la session
#        self._octaveReplotButton = wx.Button( self._gnuOctavePanel, wx.ID_ANY, u"Refresh the plot", wx.DefaultPosition, wx.DefaultSize, 0 )
#        self._octaveReplotButton.Bind( wx.EVT_BUTTON, self._eventOctaveReplot )
#        _octaveFgSizer.Add( self._octaveReplotButton, 0, wx.ALIGN_CENTER|wx.ALL, 5 )

        #Relaciona el panel GNU Octave con su sizer y lo agrega al sizer del panel operaciones
        self._gnuOctavePanel.SetSizer( _octaveFgSizer )
        self._gnuOctavePanel.Layout()
        _octaveFgSizer.Fit( self._gnuOctavePanel )
        _operationFgSizer.Add( self._gnuOctavePanel, 1, wx.EXPAND | wx.ALL, 5 )
        self._gnuOctavePanel.Hide()

    #Crea el panel de las funciones matematicas, se llama sizer porque contendra sizers dentro de sizers, crea el sizer correspondiente(row(1)col(2)) y con el cuadro (row(0)col(0)) expandido
        self._sizersMFPanel = wx.Panel( operationpanel, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.TAB_TRAVERSAL )
        _itemsOpFgSizer = wx.FlexGridSizer( 1, 2, 0, 0 )
        _itemsOpFgSizer.AddGrowableCol( 0 )
        _itemsOpFgSizer.AddGrowableRow( 0 )
        _itemsOpFgSizer.SetFlexibleDirection( wx.BOTH )
        _itemsOpFgSizer.SetNonFlexibleGrowMode( wx.FLEX_GROWMODE_SPECIFIED )
        #Crea un panel para contener las slider de corte de ejes cartesianos y el sizer correspondiente (row(4)col(1)) con la col(0) expandida
        self._sizersPanel = wx.Panel( self._sizersMFPanel, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.TAB_TRAVERSAL )
        _axisFgSizer = wx.FlexGridSizer( 2, 1, 0, 0 )
        _axisFgSizer.AddGrowableCol( 0 )
        _axisFgSizer.SetFlexibleDirection( wx.BOTH )
        _axisFgSizer.SetNonFlexibleGrowMode( wx.FLEX_GROWMODE_SPECIFIED )
#        #Crea el cuadro de texto con el label Vertical Axis y lo agrega al sizer del panel de las sliders
#        self._vAxisTextCtrl = wx.TextCtrl( self._sizersPanel, wx.ID_ANY, u"Vertical Axis:", wx.DefaultPosition, wx.Size( -1,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.TE_RIGHT )
#        _axisFgSizer.Add( self._vAxisTextCtrl, 0, wx.ALL, 5 )
#        #Crea un sizer (row(2)col(2)) para contener las slider del limite vertical, con la col(1) expandida
#        _vAxisFgSizer = wx.FlexGridSizer( 2, 2, 0, 0 )
#        _vAxisFgSizer.AddGrowableCol( 1 )
#        _vAxisFgSizer.SetFlexibleDirection( wx.BOTH )
#        _vAxisFgSizer.SetNonFlexibleGrowMode( wx.FLEX_GROWMODE_SPECIFIED )
#        #Crea un cuadro de texto con el label Lower Limit y lo agrega al sizer del limite vertical
#        self._lvLimitTextCtrl = wx.TextCtrl( self._sizersPanel, wx.ID_ANY, u"Lower Limit:", wx.DefaultPosition, wx.Size( -1,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.TE_RIGHT )
#        _vAxisFgSizer.Add( self._lvLimitTextCtrl, 0, wx.ALL, 5 )
#        #Crea una slider para indicar el parametro minimo de corte vertical y lo agrega al sizer del limite vertical
#        self._lVLimitSlider = wx.Slider( self._sizersPanel, wx.ID_ANY, 0, 0, 100, wx.DefaultPosition, wx.DefaultSize, wx.SL_HORIZONTAL | wx.SL_LABELS)
#        self._lVLimitSlider.Bind( wx.EVT_KEY_UP, self._eventLVLimitSlider )
#        self._lVLimitSlider.Bind( wx.EVT_SCROLL, self._eventLVLimitSlider )
#        _vAxisFgSizer.Add( self._lVLimitSlider, 0, wx.EXPAND, 5 )
#        #Crea un cuadro de texto con el label Upper Limit y lo agrega al sizer del limite vertical
#        self._uvLimitTextCtrl = wx.TextCtrl( self._sizersPanel, wx.ID_ANY, u"Upper Limit:", wx.DefaultPosition, wx.Size( -1,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.TE_RIGHT )
#        _vAxisFgSizer.Add( self._uvLimitTextCtrl, 0, wx.ALL, 5 )
#        #Crea una slider para indicar el parametro maximo de corte vertical y lo agrega al sizer del limite vertical
#        self._uVLimitSlider = wx.Slider( self._sizersPanel, wx.ID_ANY, 0, 0, 100, wx.DefaultPosition, wx.DefaultSize, wx.SL_HORIZONTAL | wx.SL_LABELS)
#        self._uVLimitSlider.Bind( wx.EVT_KEY_UP, self._eventUVLimitSlider )
#        self._uVLimitSlider.Bind( wx.EVT_SCROLL, self._eventUVLimitSlider )
#        _vAxisFgSizer.Add( self._uVLimitSlider, 0, wx.EXPAND, 5 )
#        #Relaciona el sizer de corte vertical con el sizer que contiene todas las slider de corte
#        _axisFgSizer.Add( _vAxisFgSizer, 1, wx.EXPAND, 5 )

        #Crea el cuadro de texto con el label Horizontal Axis y lo agrega al sizer del panel de las sliders de corte
        self._hAxisTextCtrl = wx.TextCtrl( self._sizersPanel, wx.ID_ANY, u"Horizontal Axis:", wx.DefaultPosition, wx.Size( 110,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.TE_RIGHT )
        self._hAxisTextCtrl.SetEditable(0)
        _axisFgSizer.Add( self._hAxisTextCtrl, 0, wx.ALL, 5 )
        #Crea un sizer (row(2)col(2)) para contener las slider del limite horizontal, con la col(1) expandida
        _hAxisFgSizer = wx.FlexGridSizer( 2, 2, 0, 0 )
        _hAxisFgSizer.AddGrowableCol( 1 )
        _hAxisFgSizer.SetFlexibleDirection( wx.BOTH )
        _hAxisFgSizer.SetNonFlexibleGrowMode( wx.FLEX_GROWMODE_SPECIFIED )
        #Crea un cuadro de texto con el label Lower Limit y lo agrega al sizer del limite horizontal
        self._lhLimitTextCtrl = wx.TextCtrl( self._sizersPanel, wx.ID_ANY, u"Lower Limit:", wx.DefaultPosition, wx.Size( 90,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.TE_RIGHT )
        self._lhLimitTextCtrl.SetEditable(0)
        _hAxisFgSizer.Add( self._lhLimitTextCtrl, 0, wx.ALL, 5 )
        #Crea una slider para indicar el parametro minimo de corte horizontal y lo agrega al sizer del limite horizontal
        self._lHLimitSlider = wx.Slider( self._sizersPanel, wx.ID_ANY, 0, 0, 100, wx.DefaultPosition, wx.DefaultSize, wx.SL_HORIZONTAL | wx.SL_LABELS )
        self._lHLimitSlider.Bind( wx.EVT_KEY_UP, self._eventLHLimitSlider )
        self._lHLimitSlider.Bind( wx.EVT_SCROLL, self._eventLHLimitSlider )
        _hAxisFgSizer.Add( self._lHLimitSlider, 0, wx.EXPAND, 5 )
        #Crea un cuadro de texto con el label Upper Limit y lo agrega al sizer del limite horizontal
        self._uhLimitTextCtrl = wx.TextCtrl( self._sizersPanel, wx.ID_ANY, u"Upper Limit:", wx.DefaultPosition, wx.Size( 90,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.TE_RIGHT )
        self._uhLimitTextCtrl.SetEditable(0)
        _hAxisFgSizer.Add( self._uhLimitTextCtrl, 0, wx.ALL, 5 )
        #Crea una slider para indicar el parametro maximo de corte horizontal y lo agrega al sizer del limite horizontal
        self._uHLimitSlider = wx.Slider( self._sizersPanel, wx.ID_ANY, 0, 0, 100, wx.DefaultPosition, wx.DefaultSize, wx.SL_HORIZONTAL | wx.SL_LABELS )
        self._uHLimitSlider.Bind( wx.EVT_KEY_UP, self._eventUHLimitSlider )
        self._uHLimitSlider.Bind( wx.EVT_SCROLL, self._eventUHLimitSlider )
        _hAxisFgSizer.Add( self._uHLimitSlider, 0, wx.EXPAND, 5 )
        #Relaciona el sizer de corte horizontal con el sizer que contiene todas las slider de corte
        _axisFgSizer.Add( _hAxisFgSizer, 1, wx.EXPAND, 5 )
        #Relaciona el panel de las slider con su sizer y lo agrega al sizer del panel de las funciones matematicas
        self._sizersPanel.SetSizer( _axisFgSizer )
        self._sizersPanel.Layout()
        _axisFgSizer.Fit( self._sizersPanel )
        _itemsOpFgSizer.Add( self._sizersPanel, 1, wx.EXPAND |wx.ALL, 5 )
        #Crea un panel para contener las funciones matematicas predefinidas y el sizer correspondiente (row(4)col(1)) con el cuadro (col(0)row(1)) expandido
        self._matFcPanel = wx.Panel( self._sizersMFPanel, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.TAB_TRAVERSAL )
        _matFcFgSizer = wx.FlexGridSizer( 4, 1, 0, 0 )
        _matFcFgSizer.AddGrowableCol( 0 )
        _matFcFgSizer.AddGrowableRow( 1 )
        _matFcFgSizer.SetFlexibleDirection( wx.BOTH )
        _matFcFgSizer.SetNonFlexibleGrowMode( wx.FLEX_GROWMODE_SPECIFIED )
        #Crea un cuadro de texto con el label Mathematical Functions y lo agrega al sizer de las funciones matematicas predefinidas
        self._matFcTextCtrl = wx.TextCtrl( self._matFcPanel, wx.ID_ANY, u"Mathematical Functions:", wx.DefaultPosition, wx.Size( 170,30 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.TE_LEFT )
        self._matFcTextCtrl.SetEditable(0)
        _matFcFgSizer.Add( self._matFcTextCtrl, 0, wx.ALL, 5 )
        #Crea una lista de funciones matematicas predefinidas, las carga en una lista desplegable y la agrega al sizer de las funciones matematicas predefinidas
        _matFcListBoxChoices = [ u"Last limits cut", u"Original", u"Inverse", u"Square", u"Square root", u"Logarithm", u"Average" ] #u"Play Backward",
        self._matFcListBox = wx.ListBox( self._matFcPanel, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, _matFcListBoxChoices, wx.LB_ALWAYS_SB )
        self._matFcListBox.Bind( wx.EVT_LISTBOX, self._eventMatFc )
        _matFcFgSizer.Add( self._matFcListBox, 0, wx.ALL|wx.EXPAND, 5 )
        #Crea un cuadro de texto con el label Average number of points y lo agrega al sizer de las funciones matematicas predefinidas
        self._avNPointsTextCtrl = wx.TextCtrl( self._matFcPanel, wx.ID_ANY, u"Average number of points:", wx.DefaultPosition, wx.Size( 120,30 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.TE_LEFT )#, u"Average number of points:" )
        self._avNPointsTextCtrl.SetEditable(0)
        _matFcFgSizer.Add( self._avNPointsTextCtrl, 0, wx.ALL, 5 )
        #Crea un campo de texto editable con botones para subir y bajar el valor, lo presetea en 1 y lo agrega al sizer de las funciones matematicas predefinidas
        self._avNPointsspinCtrl = wx.SpinCtrl( self._matFcPanel, wx.ID_ANY, u"1", wx.DefaultPosition, wx.DefaultSize, wx.SP_ARROW_KEYS|wx.TE_PROCESS_ENTER, 1, 1000, 0 )
        self._avNPointsspinCtrl.Bind( wx.EVT_SPINCTRL, self._eventAvNPoints )
        self._avNPointsspinCtrl.Bind( wx.EVT_TEXT_ENTER, self._eventAvNPoints )
        self._avNPointsspinCtrl.Enable(False)
        _matFcFgSizer.Add( self._avNPointsspinCtrl, 0, wx.ALL, 5 )
        #Relaciona el panel de las funciones matematicas con el propio sizer y lo agrega en el sizer del panel de sizers y funciones matematicas
        self._matFcPanel.SetSizer( _matFcFgSizer )
        self._matFcPanel.Layout()
        _matFcFgSizer.Fit( self._matFcPanel )
        _itemsOpFgSizer.Add( self._matFcPanel, 1, wx.EXPAND |wx.ALL, 5 )
        #Relaciona el panel de los sizer y las funciones matematicas con su sizer y lo agrega al sizer del panel de operaciones
        self._sizersMFPanel.SetSizer( _itemsOpFgSizer )
        self._sizersMFPanel.Layout()
        _itemsOpFgSizer.Fit( self._sizersMFPanel )
        _operationFgSizer.Add( self._sizersMFPanel, 1, wx.EXPAND |wx.ALL, 5 )
        self._sizersMFPanel.Hide()
        #Relaciona el panel de operaciones con su sizer y lo agrega al sizer del panel principal derecho
        operationpanel.SetSizer( _operationFgSizer )
        operationpanel.Layout()
        _operationFgSizer.Fit( operationpanel )
        return operationpanel

    def replotFromOctavePanel(self, panel):
        #Crea el panel
        self.retrieveFromOctavePanel = wx.Panel( panel, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.TAB_TRAVERSAL )
        #Crea el sizer para todo el dialog
        _retrieveFgSizer = wx.FlexGridSizer( 3, 2, 0, 0 )
        _retrieveFgSizer.SetFlexibleDirection( wx.BOTH )
        _retrieveFgSizer.SetNonFlexibleGrowMode( wx.FLEX_GROWMODE_SPECIFIED )

        #Crea los elementos para pull
        self._xFromOctaveLabelTextCtrl = wx.TextCtrl( self.retrieveFromOctavePanel, wx.ID_ANY, u"Name of x array: ", wx.DefaultPosition, wx.Size( 130,30 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.TE_RIGHT )
        _retrieveFgSizer.Add( self._xFromOctaveLabelTextCtrl, 0, wx.ALL, 5 )
        self._xFromOctaveLabelTextCtrl.SetEditable(0)
        self._xFromOctaveTextCtrl = wx.TextCtrl( self.retrieveFromOctavePanel, wx.ID_ANY, u"", wx.DefaultPosition, wx.DefaultSize, wx.TE_PROCESS_ENTER )
        self._xFromOctaveTextCtrl.Bind( wx.EVT_TEXT_ENTER, self._eventXFromOctave )
        _retrieveFgSizer.Add( self._xFromOctaveTextCtrl, 0, wx.EXPAND | wx.ALL, 5 )
        self._yFromOctaveLabelTextCtrl = wx.TextCtrl( self.retrieveFromOctavePanel, wx.ID_ANY, u"Name of y array: ", wx.DefaultPosition, wx.Size( 130,30 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.TE_RIGHT )
        _retrieveFgSizer.Add( self._yFromOctaveLabelTextCtrl, 0, wx.ALL, 5 )
        self._yFromOctaveLabelTextCtrl.SetEditable(0)
        self._yFromOctaveTextCtrl = wx.TextCtrl( self.retrieveFromOctavePanel, wx.ID_ANY, u"", wx.DefaultPosition, wx.DefaultSize, wx.TE_PROCESS_ENTER )
        self._yFromOctaveTextCtrl.Bind( wx.EVT_TEXT_ENTER, self._eventYFromOctave )
        _retrieveFgSizer.Add( self._yFromOctaveTextCtrl, 0, wx.EXPAND | wx.ALL, 5 )

        #Crea el botón ok
        self._continueButton = wx.Button( self.retrieveFromOctavePanel, wx.ID_ANY, u"Continue", wx.DefaultPosition, wx.DefaultSize, 0 )
        self._continueButton.Bind( wx.EVT_BUTTON, self._eventContinueReplotFromOctave )
        _retrieveFgSizer.Add( self._continueButton, 0, wx.ALIGN_CENTER|wx.ALL, 5 )

        #Crea el botón Close
        self._closeButton = wx.Button( self.retrieveFromOctavePanel, wx.ID_ANY, u"Close", wx.DefaultPosition, wx.DefaultSize, 0 )
        self._closeButton.Bind( wx.EVT_BUTTON, self._eventCloseReplotFromOctave )
        _retrieveFgSizer.Add( self._closeButton, 0, wx.ALIGN_CENTER|wx.ALL, 5 )


        #Relaciona el panel GNU Octave con su sizer y lo agrega al sizer del panel operaciones
        self.retrieveFromOctavePanel.SetSizer( _retrieveFgSizer )
        self.retrieveFromOctavePanel.Layout()
        _retrieveFgSizer.Fit( self.retrieveFromOctavePanel )


    def _createInputDataDisplayPanel(self, panel):
        # Create the panel which contain the input data elements
        self._openPanel = wx.ScrolledWindow(
            parent = panel,
            id = wx.ID_ANY,
            pos = wx.DefaultPosition,
            size = wx.DefaultSize,
            style = wx.HSCROLL|wx.VSCROLL|wx.TAB_TRAVERSAL
            )
        self._openPanel.SetScrollRate(5,5)
        self._openPanel.SetMinSize(wx.Size(350,200))
        _openButFgSizer = wx.FlexGridSizer(
            rows = 5,
            cols = 1,
            vgap = 0,
            hgap = 0
            )
        _openButFgSizer.SetFlexibleDirection(direction=wx.BOTH)
        # Create the sizer for data title.
        _titleDataFgSizer = wx.FlexGridSizer(
            rows = 1,
            cols = 2,
            vgap = 0,
            hgap = 0
            )
        _titleDataFgSizer.AddGrowableCol(idx=1)
        _titleDataFgSizer.SetFlexibleDirection(direction=wx.BOTH)
        # Create data title label
        self._titleDataTextCtrl = wx.TextCtrl(
            parent = self._openPanel,
            id = wx.ID_ANY,
            value = 'Data title:',
            pos = wx.DefaultPosition,
            size = wx.Size(70,15),
            style = wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL,
            name = 'Data title label')
        self._titleDataTextCtrl.SetEditable(0)
        self._titleDataTextCtrl.SetToolTip(
            'This is the label of the data title element.'
            )
        _titleDataFgSizer.Add(
            window = self._titleDataTextCtrl,
            proportion = 0,
            flag = wx.ALL,
            border = 5
            )
        # Create the data title element
        self._titleEdDataTextCtrl = wx.TextCtrl(
            parent = self._openPanel,
            id = wx.ID_ANY,
            value = wx.EmptyString,
            pos = wx.DefaultPosition,
            size = wx.DefaultSize,
            style = wx.TE_PROCESS_ENTER,
            name = 'Data title element'
            )
        self._titleEdDataTextCtrl.SetToolTip('Here you can find the data '
            + 'title and change it if you want.')
        self._titleEdDataTextCtrl.Bind(
            event = wx.EVT_TEXT_ENTER,
            handler = self._eventTitleEdData
            )
        _titleDataFgSizer.Add(
            window = self._titleEdDataTextCtrl,
            proportion = 0,
            flag = wx.EXPAND|wx.ALL,
            border = 5
            )
        _openButFgSizer.Add(
            sizer = _titleDataFgSizer,
            proportion = 0,
            flag = wx.EXPAND,
            border = 5
            )
        # Create a sizer for the grid elements.
        _gridboxfgsizer = wx.FlexGridSizer(
            rows = 1,
            cols = 3,
            vgap = 0,
            hgap = 0
            )
        _gridboxfgsizer.SetFlexibleDirection( wx.BOTH )
        # Create the grid panel and its sizer.
        self._datagridpanel = wx.ScrolledWindow( self._openPanel, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.HSCROLL|wx.VSCROLL|wx.TAB_TRAVERSAL )
        self._datagridpanel.SetScrollRate( 5, 5 )
        self._datagridpanel.SetMinSize( wx.Size( 250,150 ) )
        _datagridfgsizer = wx.FlexGridSizer( 1, 1, 0, 0 )
        _datagridfgsizer.SetFlexibleDirection( wx.BOTH )
        #Create the grid for the original data
        self._dataGrid = wx.grid.Grid( self._datagridpanel, wx.ID_ANY, wx.DefaultPosition, wx.Size( 240,140 ), 0 )
        # df = pd.DataFrame(data=np.zeros((10,5)))
        # table = DataTable(df)
        # self._dataGrid.SetTable(table, takeOwnership=True)
        # self._dataGrid.AutoSizeColumns()
        # _datagridfgsizer.Add( self._dataGrid, 0, wx.EXPAND | wx.ALL, 5 )
        # self._dataGrid.HideCol(0)
        # self._dataGrid.HideColLabels()
        # self._dataGrid.SetRowLabelSize(wx.grid.GRID_AUTOSIZE)

        # #Create the grid for the data update
        # self._dataupdategrid = wx.grid.Grid( self._datagridpanel, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, 0 )
        # self._dataupdategrid.SetTable(table, takeOwnership=True)
        # self._dataupdategrid.AutoSizeColumns()
        # _datagridfgsizer.Add( self._dataupdategrid, 0, wx.EXPAND | wx.ALL, 5 )
        # self._dataupdategrid.Hide()

        self._dataGrid.SetTabBehaviour(2)
        # Grid
        self._dataGrid.CreateGrid( 11, 2 )
        self._dataGrid.EnableEditing( True )
        self._dataGrid.EnableGridLines( True )
        self._dataGrid.EnableDragGridSize( False )
        self._dataGrid.SetMargins( 0, 0 )
        # Columns
        self._dataGrid.EnableDragColMove( False )
        self._dataGrid.EnableDragColSize( True )
        self._dataGrid.SetColLabelSize( 0 )
        self._dataGrid.SetColLabelAlignment( wx.ALIGN_CENTRE, wx.ALIGN_CENTRE )
        # Rows
        self._dataGrid.EnableDragRowSize( True )
        self._dataGrid.SetRowLabelSize( 50 )
        self._dataGrid.SetRowLabelAlignment( wx.ALIGN_CENTRE, wx.ALIGN_CENTRE )
        # Label Appearance
        # Cell Defaults
        self._dataGrid.SetDefaultCellAlignment( wx.ALIGN_LEFT, wx.ALIGN_TOP )
        self._dataGrid.SetMaxSize( wx.Size( 300,100 ) )
        
        self._dataGrid.SetToolTip('This is a grid element which contain tha data.')

        _datagridfgsizer.Add( self._dataGrid, 0, wx.EXPAND | wx.ALL, 5 )

        #Relaciona el sizer con el panel y lo agrega al sizer
        self._datagridpanel.SetSizer( _datagridfgsizer )
        self._datagridpanel.Layout()
        _datagridfgsizer.Fit( self._datagridpanel )
        _gridboxfgsizer.Add(self._datagridpanel, 0, wx.EXPAND | wx.ALL, 5)

        #Crea la slider para el parametro sustain
        self._datagridslider = wx.Slider( self._openPanel, wx.ID_ANY, 1, 1, 100, wx.DefaultPosition, wx.DefaultSize, wx.SL_VERTICAL )
        self._datagridslider.Bind( wx.EVT_KEY_UP, self._eventdatagridpage )
        self._datagridslider.Bind( wx.EVT_SCROLL, self._eventdatagridpage )
        self._datagridslider.SetToolTip('This slider bar allows to chage between data pages, each page contain 100 values.')
        _gridboxfgsizer.Add( self._datagridslider, 0, wx.ALL|wx.EXPAND, 5 )
        #Crea el sizer para contener las etiquetas de la slider de sustain
        _datagridsliderlabelsfgsizer = wx.FlexGridSizer( 3, 1, 0, 0 )
        _datagridsliderlabelsfgsizer.SetFlexibleDirection( wx.BOTH )
        _datagridsliderlabelsfgsizer.AddGrowableRow(1)
        #Creo el primer label de la slider de sustain
        self._mingridpagetextctrl = wx.TextCtrl( self._openPanel, wx.ID_ANY, u"1", wx.DefaultPosition, wx.Size( 50,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.ALIGN_LEFT )
        self._mingridpagetextctrl.SetEditable(0)
        self._mingridpagetextctrl.SetToolTip('This is the min value of the data grid slider bar.')
        _datagridsliderlabelsfgsizer.Add( self._mingridpagetextctrl, 0, wx.ALL | wx.ALIGN_LEFT, 5 )
        #Creo el segundo label de la slider de sustain
        self._actualgridpagetextctrl = wx.TextCtrl( self._openPanel, wx.ID_ANY, u"1", wx.DefaultPosition, wx.Size( 50,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.ALIGN_LEFT )
        self._actualgridpagetextctrl.SetEditable(0)
        self._actualgridpagetextctrl.SetToolTip('This is the actual value of the data grid slider bar.')
        _datagridsliderlabelsfgsizer.Add( self._actualgridpagetextctrl, 0, wx.ALL | wx.ALIGN_CENTRE, 5 )
        #Creo el tercer label de la slider de sustain
        self._maxgridpagetextctrl = wx.TextCtrl( self._openPanel, wx.ID_ANY, u"1", wx.DefaultPosition, wx.Size( 50,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.ALIGN_LEFT )
        self._maxgridpagetextctrl.SetEditable(0)
        self._maxgridpagetextctrl.SetToolTip('This is the max value of the data grid slider bar.')
        _datagridsliderlabelsfgsizer.Add( self._maxgridpagetextctrl, 0, wx.ALL | wx.ALIGN_RIGHT, 5 )
        #Relaciona el sizer con el sizer del sonido
        _gridboxfgsizer.Add( _datagridsliderlabelsfgsizer, 1, wx.EXPAND, 5 )


        _openButFgSizer.Add(_gridboxfgsizer, 0, wx.EXPAND | wx.ALL, 5)

        #Crea el sizer para los botones de la grilla
        _buttonsDataFgSizer = wx.FlexGridSizer( 1, 3, 0, 0 )
        _buttonsDataFgSizer.SetFlexibleDirection( wx.BOTH )
        _buttonsDataFgSizer.SetNonFlexibleGrowMode( wx.FLEX_GROWMODE_SPECIFIED )

        self._addGridChangesButton = wx.Button( self._openPanel, wx.ID_ANY, u"Update Column\n Names", wx.DefaultPosition, wx.DefaultSize, 0 )
        self._addGridChangesButton.Bind( wx.EVT_BUTTON, self._eventAddGridChanges )
        self._addGridChangesButton.SetToolTip('This button update the columns names with the modification made on the grid element.')
        _buttonsDataFgSizer.Add( self._addGridChangesButton, 0, wx.ALL, 5 )

        self._addGridUpdateButton = wx.Button( self._openPanel, wx.ID_ANY, u"Update Grid", wx.DefaultPosition, wx.DefaultSize, 0 )
        self._addGridUpdateButton.Bind( wx.EVT_BUTTON, self._eventUpdateGrid )
        self._addGridUpdateButton.SetToolTip('This button update the data gris with the x and y axis plotted.')
        _buttonsDataFgSizer.Add( self._addGridUpdateButton, 0, wx.ALL, 5 )

        self._addGridOriginalButton = wx.Button( self._openPanel, wx.ID_ANY, u"Original Array", wx.DefaultPosition, wx.DefaultSize, 0 )
        self._addGridOriginalButton.Bind( wx.EVT_BUTTON, self._eventOriginalGrid )
        self._addGridOriginalButton.SetToolTip('This button load the original data on the data grid element.')
        _buttonsDataFgSizer.Add( self._addGridOriginalButton, 0, wx.ALL, 5 )

        _openButFgSizer.Add( _buttonsDataFgSizer, 0, wx.EXPAND, 5 )

    #Crea el sizer de los desplegables para elegir los ejes
        _axisChoiceFgSizer = wx.FlexGridSizer( 2, 2, 0, 0 )

        _axisChoiceFgSizer.SetFlexibleDirection( wx.BOTH )
        _axisChoiceFgSizer.SetNonFlexibleGrowMode( wx.FLEX_GROWMODE_SPECIFIED )

        self._axisChoiceXTextCtrl = wx.TextCtrl( self._openPanel, wx.ID_ANY, u"Axis X selection:", wx.DefaultPosition, wx.Size( 120,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.TE_RIGHT )
        self._axisChoiceXTextCtrl.SetEditable(0)
        self._axisChoiceXTextCtrl.NavigateIn()
        self._axisChoiceXTextCtrl.SetToolTip('This is the label of the x selection element.')
        _axisChoiceFgSizer.Add( self._axisChoiceXTextCtrl, 0, wx.ALL|wx.FIXED_MINSIZE, 5 )

        self._axisChoiceX = wx.ListBox( self._openPanel, wx.ID_ANY, wx.DefaultPosition, wx.Size(120,60), [""], 0 )
        self._axisChoiceX.Bind( wx.EVT_LISTBOX, self._eventAxisChoiceX )
        self._axisChoiceX.SetSelection( 0 )
        self._axisChoiceX.SetToolTip('This element allow to choose between the columns to set as x values.')
        _axisChoiceFgSizer.Add( self._axisChoiceX, 0, wx.ALL|wx.FIXED_MINSIZE, 5 )

        self._axisChoiceYTextCtrl = wx.TextCtrl( self._openPanel, wx.ID_ANY, u"Axis Y selection:", wx.DefaultPosition, wx.Size( 120,15 ), style=wx.NO_BORDER|wx.TE_MULTILINE|wx.TE_NO_VSCROLL|wx.TE_RIGHT )
        self._axisChoiceYTextCtrl.SetEditable(0)
        self._axisChoiceYTextCtrl.NavigateIn()
        self._axisChoiceYTextCtrl.SetToolTip('This is the label of the y selection element.')
        _axisChoiceFgSizer.Add( self._axisChoiceYTextCtrl, 0, wx.ALL|wx.FIXED_MINSIZE, 5 )

        self._axisChoiceY = wx.ListBox( self._openPanel, wx.ID_ANY, wx.DefaultPosition, wx.Size(120,60), [""], 0 )
        self._axisChoiceY.Bind( wx.EVT_LISTBOX, self._eventAxisChoiceY )
        self._axisChoiceY.SetSelection( 0 )
        self._axisChoiceY.SetToolTip('This element allow to choose between the columns to set as y values.')
        _axisChoiceFgSizer.Add( self._axisChoiceY, 0, wx.ALL|wx.FIXED_MINSIZE, 5 )

        _openButFgSizer.Add( _axisChoiceFgSizer, 1, wx.ALL|wx.FIXED_MINSIZE, 5 )

        #Relaciona el sizer con el panel File y lo agrega al sizer del panel izquierdo
        self._openPanel.SetSizer( _openButFgSizer )
        self._openPanel.Layout()
        _openButFgSizer.Fit( self._openPanel )
        return self._openPanel

    def _createShell(self, panel):
        #Crea la shell
        all = dict(globals())
        all.update(locals())
        self._pythonShell = py.shell.Shell(panel, -1, introText="", locals=all, style=wx.RESIZE_BORDER)
        self._pythonShell.Execute("self._pythonShell.clear()")

#Setters!!!
    def _setDataFrame (self, data):
        self._expData.printoutput("Setting class variable dataFrame.")
        self._dataFrame = data

    def setXActual (self, x):
        self._expData.printoutput("Setting class variable X.")
        self.x = x

    def setYActual (self, y):
        self._expData.printoutput("Setting class variable Y.")
        self.y = y

    def _setXOrigin (self, xOrigin):
        self._expData.printoutput("Setting class variable xOrigin.")
        self._xOrigin = xOrigin

    def _setYOrigin (self, yOrigin):
        self._expData.printoutput("Setting class variable yOrigin.")
        self._yOrigin = yOrigin

    def _setNormXY (self, x, y):
        self._expData.printoutput("Setting class variables norm_x and norm_y.")
        self._norm_x, self._norm_y, status = self._matFc.normalize(x, y)

    def _setTimerIndex (self, index):
        self._expData.printoutput("Setting class variable timerIndex.")
        self._timerIndex = index
        
    def _settimerenvelopeindex(self, index):
        self._timerenvelopeindex = index

    def _setVelocity (self, vel):
        self._expData.printoutput("Setting class variable velocity.")
        self._velocity = vel

    def _setxPoints (self, points):
        self._expData.printoutput("Setting class variable xPoints.")
        self._xPoints = points

    def _setyPoints (self, points):
        self._expData.printoutput("Setting class variable yPoints.")
        self._yPoints = points

    def _setAbsMarkPoint (self, point):
        self._expData.printoutput("Setting class variable absPoint.")
        self._absPoint = point

    def _setOrdMarkPoint (self, point):
        self._expData.printoutput("Setting class variable ordPoint.")
        self._ordPoint = point

    def _setMatSelection (self, select):
        self._expData.printoutput("Setting class variable matSelection.")
        self._matSelection = select

    def _setHoriLower (self, hl):
        self._expData.printoutput("Setting class variable horiLower.")
        self._horiLower = hl

    def _setHoriUpper (self, hu):
        self._expData.printoutput("Setting class variable horiUpper.")
        self._horiUpper = hu

    def _setavNPoints (self, num):
        self._expData.printoutput("Setting class variable avNPoints.")
        self._avNPoints = num

    def _setMarkerStyleIndex (self, index):
        self._expData.printoutput("Setting class variable markerStyleIndex.")
        self._markerStyleIndex = index

    def _setLineChar (self, char):
        self._expData.printoutput("Setting class variable lineChar.")
        self._lineChar = char

    def _setMarkerChar (self, char):
        self._expData.printoutput("Setting class variable markerChar.")
        self._markerChar = char

    def _setColorChar (self, char):
        self._expData.printoutput("Setting class variable colorChar.")
        self._colorChar = char

    def set_soundvolumn(self, vol):
        self._expData.printoutput("Setting class variables soundvolumn.")
        self._soundvolumn = vol

    def _set_soundwaveformlist (self):
        self._expData.printoutput("Setting class variables waveform.")
        # self._soundwaveformlist = self._dataSound.reproductor.get_waveformlist()
        #Se esta probando la lista, despues el comando es el de arriba
        self._soundwaveformlist = self._dataSound.reproductor.get_available_waveforms()

    def _set_waveformnumber (self, num):
        self._expData.printoutput("Setting class variable waveformnumber.")
        self._waveformnumber = num

    def _setGridColor(self, color):
        self._expData.printoutput("Setting class variable gridColor.")
        if color=="Blue":
            self._gridColor = u'b'
        elif color=="Green":
            self._gridColor = 'g'
        elif color=="Red":
            self._gridColor = 'r'
        elif color=="Cyan":
            self._gridColor = 'c'
        elif color=="Magenta":
            self._gridColor = 'm'
        elif color=="Yellow":
            self._gridColor = 'y'
        elif color=="Black":
            self._gridColor = 'k'
        elif color=="White":
            self._gridColor = 'w'
        else:
            self._expData.writeinfo("The color selected is not valid.")

    def _setGridLinestyle(self, linestyle):
        self._expData.printoutput("Setting class variable gridLineStyle.")
        if linestyle == "Solid line":
            self._gridLinestyle = '-'
        elif linestyle == "Dashed line":
            self._gridLinestyle = '--'
        elif linestyle == "Dash-dot line":
            self._gridLinestyle = '-.'
        elif linestyle == "Dotted line":
            self._gridLinestyle = ':'
        else:
            self._expData.writeinfo("The line style selected is not valid.")

    def _setGridLinewidth(self, linewidth):
        self._expData.printoutput("Setting class variable gridLinewidth.")
        self._gridLinewidth = linewidth

    def _setXLabel(self, xlabel):
        self._expData.printoutput("Setting class variable xLabel.")
        self.xLabel = xlabel

    def _setYLabel(self, ylabel):
        self._expData.printoutput("Setting class variable yLabel.")
        self.yLabel = ylabel

    def _setXName(self, xName):
        self._expData.printoutput("Setting class variable xName.")
        self.xName = xName

    def _setYName(self, yName):
        self._expData.printoutput("Setting class variable yName.")
        self.yName = yName

    def _setXOctave(self, x):
        self._expData.printoutput("Setting class variable xOctave.")
        self.xOctave = x

    def _setYOctave(self, y):
        self._expData.printoutput("Setting class variable yOctave.")
        self.yOctave = y

    def setsoundattack(self, a):
        self._expData.printoutput("Setting class variable soundattack.")
        self.soundattack = a

    def setsounddecay(self, d):
        self._expData.printoutput("Setting class variable sounddecay.")
        self.sounddecay = d

    def setsoundsustain(self, s):
        self._expData.printoutput("Setting class variable soundsustain.")
        self.soundsustain = s

    def setsoundrelease(self, r):
        self._expData.printoutput("Setting class variable soundrelease.")
        self.soundrelease = r
        
    def setenvelope(self, env):
        self._expData.printoutput("Setting class variable soundenv.")
        self.soundenv = env

#Getters!!!
    def getDataFrame (self):
        self._expData.printoutput("Class variable dataFrame requested.")
        return self._dataFrame

    def getXActual (self):
        self._expData.printoutput("Class variable X requested.")
        if self.x.any() == None:
            self._expData.writeinfo("The class variable X has not yet been set.")
        return self.x

    def getYActual (self):
        self._expData.printoutput("Class variable Y requested.")
        if self.y.any() == None:
            self._expData.writeinfo("The class variable Y has not yet been set.")
        return self.y

    def getXOriginal (self):
        self._expData.printoutput("Class variable xOrigin requested.")
        if self._xOrigin.any() == None:
            self._expData.writeinfo("The class variable xOrigin has not yet been set.")
        return self._xOrigin

    def getYOriginal (self):
        self._expData.printoutput("Class variable yOrigin requested.")
        if self._yOrigin.any() == None:
            self._expData.writeinfo("The class variable yOrigin has not yet been set.")
        return self._yOrigin

    def _getTimerIndex (self):
        self._expData.printoutput("Class variable timerIndex requested.")
        return self._timerIndex
    
    def _gettimerenvelopeindex(self):
        return self._timerenvelopeindex

    def _getNormX (self):
        self._expData.printoutput("Class variable norm_x requested.")
        return self._norm_x

    def _getNormY (self):
        self._expData.printoutput("Class variable norm_y requested.")
        return self._norm_y

    def _getVelocity (self):
        self._expData.printoutput("Class variable velocity requested.")
        index = [i for i in range(100, -1, -1)]
        return index[self._velocity]

    def _getxPoints (self):
        self._expData.printoutput("Class variable xPoints requested.")
        return self._xPoints

    def _getyPoints (self):
        self._expData.printoutput("Class variable yPoints requested.")
        return self._yPoints

    def _getAbsMarkPoint (self):
        self._expData.printoutput("Class variable absPoint requested.")
        return self._absPoint

    def _getOrdMarkPoint (self):
        self._expData.printoutput("Class variable ordPoint requested.")
        return self._ordPoint

    def _getMatSelection (self):
        self._expData.printoutput("Class variable matSelection requested.")
        return self._matSelection

    def _getHoriLower (self):
        self._expData.printoutput("Class variable horiLower requested.")
        return self._horiLower

    def _getHoriUpper (self):
        self._expData.printoutput("Class variable horiUpper requested.")
        return self._horiUpper

    def _getavNPoints (self):
        self._expData.printoutput("Class variable avNPoints requested.")
        return self._avNPoints

    def _getMarkerStyleIndex (self):
        self._expData.printoutput("Class variable markerStyleIndex requested.")
        return self._markerStyleIndex

    def _getLineChar (self):
        self._expData.printoutput("Class variable lineChar requested.")
        return self._lineChar

    def _getMarkerChar (self):
        self._expData.printoutput("Class variable markerChar requested.")
        return self._markerChar

    def _getColorChar (self):
        self._expData.printoutput("Class variable colorChar requested.")
        return self._colorChar

    def _getPlotStile (self):
        self._expData.printoutput("Graphic style requested.")
        return (self._getColorChar() + self._getMarkerChar() + self._getLineChar())

    def get_soundvolumn(self):
        return self._soundvolumn

    def _get_soundwaveformlist(self):
        self._expData.printoutput("Class variable waveform requested.")
        return self._soundwaveformlist

    def _get_waveformnumber (self):
        self._expData.printoutput("Class variable waveformnumber requested.")
        return self._waveformnumber

    def _getGridColor(self):
        self._expData.printoutput("Class variable gridColor requested.")
        return self._gridColor

    def _getGridLinestyle(self):
        self._expData.printoutput("Class variable gridLinestyle requested.")
        return self._gridLinestyle

    def _getGridLinewidth(self):
        self._expData.printoutput("Class variable gridLinewidth requested.")
        return self._gridLinewidth

    def getXLabel(self):
        self._expData.printoutput("Class variable xLabel requested.")
        return self.xLabel

    def getYLabel(self):
        self._expData.printoutput("Class variable yLabel requested.")
        return self.yLabel

    def getXName(self):
        self._expData.printoutput("Class variable xName requested.")
        return self.xName

    def getYName(self):
        self._expData.printoutput("Class variable yName requested.")
        return self.yName

    def getXOctave(self):
        self._expData.printoutput("Class variable xOctave requested.")
        return self.xOctave

    def getYOctave(self):
        self._expData.printoutput("Class variable yOctave requested.")
        return self.yOctave

    def getsoundattack(self):
        self._expData.printoutput("Class variable soundattack requested.")
        return self.soundattack

    def getsounddecay(self):
        self._expData.printoutput("Class variable sounddecay requested.")
        return self.sounddecay

    def getsoundsustain(self):
        self._expData.printoutput("Class variable soundsustain requested.")
        return self.soundsustain

    def getsoundrelease(self):
        self._expData.printoutput("Class variable soundrelease requested.")
        return self.soundrelease
    
    def getenvelope(self):
        self._expData.printoutput("Class variable soundenv requested.")
        return self.soundenv

#Interfaz!!! - funcionalización
    def setCutSliderLimits (self, xOrigin, yOrigin, x, y):
        self._expData.printoutput("Updating text control labels.")
        #Aún no se funcionalizarlo
#        try:
#            self._lVLimitSlider.SetMax(np.amax(yOrigin))
#            self._lVLimitSlider.SetMin(np.amin(yOrigin))
#            self._lVLimitSlider.SetValue(np.amin(y))
#        except Exception as e:
#            self._expData.writeexception(e)
#        try:
#            self._uVLimitSlider.SetMax(np.amax(yOrigin))
#            self._uVLimitSlider.SetMin(np.amin(yOrigin))
#            self._uVLimitSlider.SetValue(np.amax(y))
#        except Exception as e:
#            self._expData.writeexception(e)
        try:
#            self._lHLimitSlider.SetMax(np.amax(xOrigin))
#            self._lHLimitSlider.SetMin(np.amin(xOrigin))
#            self._lHLimitSlider.SetValue(np.amin(x))
            self._lHLimitSlider.SetMax(xOrigin.size)
            self._lHLimitSlider.SetMin(0)
            self._lHLimitSlider.SetValue(self._getHoriLower())
        except Exception as e:
            self._expData.writeexception(e)
        try:
            self._uHLimitSlider.SetMax(xOrigin.size)
            self._uHLimitSlider.SetMin(0)
            self._uHLimitSlider.SetValue(self._getHoriUpper())
        except Exception as e:
            self._expData.writeexception(e)
        self.SendSizeEvent()

    def setArrayLimits (self, x, y):
        self._expData.printoutput("Setting the Upper and Lower limits.")
        try:
            limitVLower = np.amin(y)
        except Exception as e:
            self._expData.writeexception(e)
        try:
            limitVUpper = np.amax(y)
        except Exception as e:
            self._expData.writeexception(e)
        try:
            limitHLower = np.amin(x)
        except Exception as e:
            self._expData.writeexception(e)
        try:
            limitHUpper = np.amax(x)
        except Exception as e:
            self._expData.writeexception(e)
        return limitVLower, limitVUpper, limitHLower, limitHUpper

    def setAbsSliderLimits (self, x):
        self._expData.printoutput("Setting the slider limits.")
        try:
            self._abspos_slider.SetMax(x.size)
            self._abspos_slider.SetMin(0)

            # Set abscisa textctrls
            self._absminlabel_textctrl.SetValue(str(round(x[0],4)))
            self._absmaxlabel_textctrl.SetValue(str(round(x[x.size-1],4)))
            self._absposlabel_textctrl.SetValue(str(round(x[self._abspos_slider.GetValue()],4)))

            self.SendSizeEvent()
        except Exception as e:
            self._expData.writeexception(e)

        #Para python 3:Sound
        try:
            if(x[x.size-1]<10000):
                name="Abscissa Position:\n"+str("{0:.2f}".format(x[0]))+" to "+ \
                str("{0:.2f}".format(x[x.size-1]))
            else:
                name="Abscissa Position:\n"+str("{0:.2f}".format(x[0]))+" to "+ \
                str("{0:.2f}".format(x[x.size-1]))
                self._absPosTextCtrl.SetMinSize(wx.Size( 120,30 ))
            self._absPosTextCtrl.SetValue(name)
        except Exception as e:
            self._expData.writeexception(e)

        #Para python 2:
        """
        try:
            if(x[x.size-1]<10000):
                name="Abscissa Position:\n"+str(x[0])+" to "+ \
                str(x[x.size-1])
            else:
                name="Abscissa Position:\n"+str(x[0])+" to "+ \
                str(x[x.size-1])
                self._absPosTextCtrl.SetMinSize(wx.Size( 120,40 ))
            self._absPosTextCtrl.SetValue(name)
        except Exception as e:
            self._expData.writeexception(e)
            """
    def plotTitles(self):
        self._expData.printoutput("Setting the titles and labels.")
        try:
            self.panel.set_title(self._titleEdDataTextCtrl.GetValue())
        except Exception as e:
            self._expData.writeexception(e)
        try:
            #self.panel.set_xlabel( self._axisChoiceX.GetString(self.getXLabel()) )
            #text=self.getXName()+'\n'+self.getYName()
            #wx.MessageBox(text, 'Info', wx.OK | wx.ICON_INFORMATION)
            self.panel.set_xlabel( self.getXName() )
        except Exception as e:
            self._expData.writeexception(e)
        try:
            #self.panel.set_ylabel( self._axisChoiceX.GetString(self.getYLabel()) )
            self.panel.set_ylabel( self.getYName() )
        except Exception as e:
            self._expData.writeexception(e)

    def plot2D (self, x, y):
        #para graficar cambios con los datos originales
        self._expData.printoutput("Plot the graph.")
        try:
            if self._gridChoice.IsChecked():
                self.panel.grid(color=self._getGridColor(), linestyle=self._getGridLinestyle(), linewidth=self._getGridLinewidth())
        except Exception as e:
            self._expData.writeexception(e)
        try:
            style = self._getPlotStile()
            self._lines = self.panel.plot(x, y, style)
            self._plotCounter = self._plotCounter + 1
        except Exception as e:
            self._expData.writeexception(e)

        #Se pone una variable de estado en lugar de enviarlo directamente para no ralentizar los procesos.
        self.dataUpdateToOctave = True
#        try:
#            self._sendToOctave()
#        except Exception as e:
#            self._expData.writeexception(e)Sound

        self._figure.tight_layout()
        self._figure.canvas.draw()

    def plotRedLine (self, abscisa, ordenada):
        self._expData.printoutput("Plot the red line.")
        try:
            if not self._lineExist:
                #plot the line the first time
                self._lineExist = True
            else:
                #update the line and generate de sound
                self.panel.lines.remove(self._wr())
            self.panel.plot(abscisa, ordenada, 'r')
            self._wr = ref(self.panel.lines[self._plotCounter])
        except Exception as e:
            self._expData.writeexception(e)
        self._figure.tight_layout()
        self._figure.canvas.draw()

    def plotMarkLine (self):
        self._expData.printoutput("Plot the mark line.")
        try:
            self.panel.plot(self._getAbsMarkPoint(), self._getOrdMarkPoint(), 'k')
            self._plotCounter = self._plotCounter + 1
        except Exception as e:
            self._expData.writeexception(e)

    def replot2D (self, x, y):
        if x.any()==None or y.any()==None:
            self._expData.writeinfo("The data has not been imported yet.")
        else:
            self._expData.printoutput("Clean and plot the graph")
            self._lineExist = False
            self.panel.cla()
            self._figure.canvas.draw()
            self.panel.lines = []
            self._plotCounter = 0
            try:
                markX = self._getxPoints()
                for i in range (0, markX.size):
                    self._setAbsMarkPoint( np.array([float(markX[i]), float(markX[i])]) )
                    self._setOrdMarkPoint( np.array([float(np.amin(y)), float(np.amax(y))]) )
                    self.plotMarkLine()
            except Exception as e:
                self._expData.writeexception(e)
            try:
                timerIndex = self._getTimerIndex()
                if not timerIndex==0:
                    ordenada = np.array([float(np.amin(y)), float(np.amax(y))])
                    abscisa = np.array([float(x[timerIndex]), float(x[timerIndex])])
                    self.plotRedLine(abscisa, ordenada)
            except Exception as e:
                self._expData.writeexception(e)

            if self.inverseFunc:
                self.panel.invert_yaxis()
                self._figure.canvas.draw()

            try:
                self.plotTitles()
                self.plot2D(x, y)
            except AttributeError as e:
                self._expData.writeinfo("The data has not been imported yet.")
                self._expData.writeexception(e)
            except Exception as e:
                self._expData.writeexception(e)
            try:
                self.SendSizeEvent()
            except Exception as e:
                self._expData.writeexception(e)

    def _sonoPlot (self, event):
        if self.getXActual().any()==None or self.getYActual().any()==None:
            self._expData.writeinfo("The data has not been imported yet.")
        else:
            self._expData.printoutput("Generate the sound and refresh plot.")
            timerIndex = self._getTimerIndex()
            x=self.getXActual()
            y=self.getYActual()
            try:
                ordenada = np.array([float(np.amin(y)), float(np.amax(y))])
                abscisa = np.array([float(x[timerIndex]), float(x[timerIndex])])
            except Exception as e:
                self._expData.writeexception(e)
            try:
                self.plotRedLine(abscisa, ordenada)
            except Exception as e:
                self._expData.writeexception(e)
            try:
                self._abspos_slider.SetValue(timerIndex)
                self._absposlabel_textctrl.SetValue(str(round(x[self._abspos_slider.GetValue()],4)))
            except Exception as e:
                self._expData.writeexception(e)
            try:
                self._dataSound.make_sound(self._getNormY(), timerIndex)
            except Exception as e:
                self._expData.writeexception(e)
            self._setTimerIndex(timerIndex + 1)
            if timerIndex==(x.size-1):
                self.stopMethod()
                
    def _playenvelope_event(self, event):
        timerIndex = self._gettimerenvelopeindex()
        env = self.getenvelope()
        print('**************')
        print(env)
        n_samples = np.arange(0.0, env.size)
        norm_x, norm_y, status = self._matFc.normalize(n_samples, env)
        self._dataSound.make_sound(norm_y, timerIndex)
        self._settimerenvelopeindex(timerIndex + 1)
        if timerIndex==(env.size-1):
            self._envelopeplaytogglebtn.SetLabel('Play envelope\nsound')
            self._envelopeplaytogglebtn.SetValue(False)
            self._settimerenvelopeindex(0)
            self._timer_envelope.Stop()

    def openMethod(self):
        if self._timer.IsRunning():
            self.stopMethod()
            wx.MessageBox("The previous reproduction of the data has been stopped.",
                          'Information', wx.OK | wx.ICON_INFORMATION)
        if not self._askPoints:
            self.askSavePoints()

#        if not self._firstOpen:
#            self._sendToOctaveListBox.Clear()
#            self._sendToOctaveListBox.InsertItems(["X","Y","Original X","Original Y"], 0)
        self.setArrayLimits(0,0)
        # self._askLabelDataCheckBox.SetValue(True)
        try:
            pathName, fileTipe, pathstatus = self._openData.get_datapath()

            data, status, msg = self._openData.set_arrayfromfile(pathName, fileTipe)
            # if fileTipe == "txt":
            #     data, status = self._openData.setArraysFromTxt(pathName)
            # else:
            #     if fileTipe == "csv":
            #         data, status = self._openData.setArraysFromCsv(pathName)
            #     else:
            #         self._expData.writeinfo("Error: the file type not match with txt or csv.")
            if not status:
                wx.MessageBox("The data file can't be opened, the software continue with the previous data if exist. \nCheck the problem and contact the development team if you need help.\n\nThe problem is:\n"+msg+"\n\nContact mail: sonounoteam@gmail.com.",
                          'Information', wx.OK | wx.ICON_INFORMATION)
            else:
                #aquí las nuevas opciones
                # #Chequeo si tienen nombre de columnas
                # if not type(data.loc[0,0]) == str:
                #     #Se debe colocar un for
                #     for a in range (0,data.shape[1]):
                #         if a==0:
                #             xLabel = pd.DataFrame({a:["Column "+str(a)]})
                #         else:
                #             xLabel.loc[:, a] = "Column "+str(a)
                #     data = pd.concat([xLabel, data]).reset_index(drop=True)
                #     self._setDataFrame(data)
                # #Chequeo si los nombres de columnas tienen espacios y se borran
                # for i in range (0, data.shape[1]):
                #     data.iloc[0,i] = data.iloc[0,i].replace(" ","")
                #Continuo seteando parametros relacionados con los datos
                self._titleEdDataTextCtrl.SetValue(self._openData.get_datafilename()[:-4])
                self._setDataFrame(data)
                x, y, status1 = self.dataSelection(data)
                if status1:
                    self.setXActual(x)
                    self.setYActual(y)
                    self._setXOrigin(x)
                    self._setYOrigin(y)
                    self._setHoriLower(0)
                    self._setHoriUpper(x.size)
                    self.setCutSliderLimits(x, y, x, y)
                    self.setArrayLimits(x, y)
                    self.setAbsSliderLimits(x)
                    self._sendAllToOctave()
                    self.replot2D(x, y)
                    self._expData.printoutput("Data imported and graphed.")
                else:
                    wx.MessageBox("The data file can't be opened, the software continue with the previous data if exist. \nCheck the file and contact the development team if you need help.\nContact mail: sonounoteam@gmail.com.",
                          'Information', wx.OK | wx.ICON_INFORMATION)
        except Exception as e:
            self._expData.writeexception(e)

    def _setdatagridpage(self, pos):
        data = self.getDataFrame()
        if data.shape[1]<2:
            return False

        # #Chequeo si los datos son menos de cierto valor
        # if self.limitDataToLoad < data.shape[0]:
        #     rowNumber = self.limitDataToLoad
        # else:
        #     rowNumber = data.shape[0]

        if pos == 1:
            if data.shape[0] < self.limitDataToLoad :
                #los datos son menos de 100
                rows = data.shape[0]
                initialnumber = 0
                self._setgridsize(rows, data.shape[1])
                self._loadintogrid(data, initialnumber, rows, data.shape[1])
            else:
                #cargar los primeros 100 datos
                rows = 101
                initialnumber = 0
                self._setgridsize(rows, data.shape[1])
                self._loadintogrid(data, initialnumber, rows, data.shape[1])
        else:
            gridpages = int(data.shape[0]/self.limitDataToLoad)
            if pos > gridpages:
                #cargar la ultima pagina
                rows = data.shape[0] - gridpages*100
                initialnumber = gridpages*100
                self._setgridsize(rows, data.shape[1])
                self._loadintogrid(data, initialnumber, rows, data.shape[1])
            else:
                #detectar pagina y cargar 100 datos
                rows = 101
                initialnumber = (pos-1)*100
                self._setgridsize(rows, data.shape[1])
                self._loadintogrid(data, initialnumber, rows, data.shape[1])

    def _setgridsize(self, rows, cols):
        #Redimencionamos la grilla
        if cols>self._dataGrid.GetNumberCols():
            self._dataGrid.AppendCols(cols-self._dataGrid.GetNumberCols())
        elif cols<self._dataGrid.GetNumberCols():
            self._dataGrid.DeleteCols( numCols=(self._dataGrid.GetNumberCols()-cols) )
        if rows>self._dataGrid.GetNumberRows():
            self._dataGrid.AppendRows(rows-self._dataGrid.GetNumberRows())
        elif rows<self._dataGrid.GetNumberRows():
            self._dataGrid.DeleteRows( numRows=(self._dataGrid.GetNumberRows()-rows) )

    def _loadintogrid(self, data, init, rows, cols):
        for j in range (init,(rows+init)): #recorre filas
            for i in range (0,cols): #recorre columnas
                self._dataGrid.SetCellValue (j-init, i, str(data.iloc[j,i]))
                if not j-init == 0:
                    self._dataGrid.SetReadOnly(j-init, i, isReadOnly=True)
                    self._dataGrid.SetRowLabelValue(j-init, str(j))
                else:
                    self._dataGrid.SetReadOnly(j-init, i, isReadOnly=False)
                    self._dataGrid.SetCellValue (j-init, i, str(data.iloc[j-init,i]))
                    self._dataGrid.SetRowLabelValue(j-init, ' ')

    def dataSelection(self, data):
        # if self.limitDataToLoad < data.shape[0]:
        #     if wx.MessageBox("The data file have more than 5000 values, the software might delay to show all the data array on a grid element. Do you want to display all the values on the grid element anyway?\n\nNOTE: The other functionalities (plot, math fuctions, etc) use all the values of the array in any case.", "Information", wx.ICON_QUESTION | wx.YES_NO, self) == wx.NO:
        #         rowNumber = self.limitDataToLoad
        #     else:
        #         rowNumber = data.shape[0]
        # else:
        #     rowNumber = data.shape[0]

        if data.shape[1]<2:
            return None, None, False

        # #Chequeo si los datos son menos de cierto valor
        # if self.limitDataToLoad < data.shape[0]:
        #     rowNumber = self.limitDataToLoad
        # else:
        #     rowNumber = data.shape[0]

        #Limpio la grilla
        self._dataGrid.ClearGrid()
        pages = int(data.shape[0]/100)+1
        self._datagridslider.SetMax(pages)
        self._maxgridpagetextctrl.SetValue(str(pages))
        self._setdatagridpage(self._datagridslider.GetValue())
        # #Redimencionamos la grilla
        # if data.shape[1]>self._dataGrid.GetNumberCols():
        #     self._dataGrid.AppendCols(data.shape[1]-self._dataGrid.GetNumberCols())
        # elif data.shape[1]<self._dataGrid.GetNumberCols():
        #     self._dataGrid.DeleteCols( numCols=(self._dataGrid.GetNumberCols()-data.shape[1]) )
        # if rowNumber>self._dataGrid.GetNumberRows():
        #     self._dataGrid.AppendRows(rowNumber-self._dataGrid.GetNumberRows())
        # elif rowNumber<self._dataGrid.GetNumberRows():
        #     self._dataGrid.DeleteRows( numRows=(self._dataGrid.GetNumberRows()-rowNumber) )
#        #Lo coloco en la grilla
        #dlg = wx.ProgressDialog("Loading data to the grid", " ", maximum=data.shape[0], style=wx.PD_APP_MODAL | wx.PD_AUTO_HIDE | wx.PD_CAN_ABORT)
        #dlg.Show()
        # table = DataTable(data)
        # self._dataGrid.SetTable(table, takeOwnership=True)
        # self._dataGrid.AutoSizeColumns()
        # self._dataGrid.HideCol(0)

        # if data.shape[0] < rowNumber:
        #     for j in range (0,data.shape[0]):
        #         for i in range (0,data.shape[1]):
        #             self._dataGrid.SetCellValue (j, i, str(data.iloc[j,i]))
        #             if not j == 0:
        #                 self._dataGrid.SetReadOnly(j, i, isReadOnly=True)
        #             else:
        #                 self._dataGrid.SetReadOnly(j, i, isReadOnly=False)
        #         dlg.Pulse("Loading data")
        #         #dlg.Update(j, "Loading data")
        #         #dlg.Update (j, "%i of %i"%(j, int(data.shape[0])))
        #         if dlg.WasCancelled():
        #             break
        # else:
        #     for j in range (0,rowNumber):
        #         for i in range (0,data.shape[1]):
        #             self._dataGrid.SetCellValue (j, i, str(data.iloc[j,i]))
        #             if not j == 0:
        #                 self._dataGrid.SetReadOnly(j, i, isReadOnly=True)
        #             else:
        #                 self._dataGrid.SetReadOnly(j, i, isReadOnly=False)
        #         #dlg.Update(j, "Loading data")
        #         dlg.Pulse("Loading data")
        #         #dlg.Update (j, "%i of %i"%(j, int(data.shape[0])))
        #         if dlg.WasCancelled():
        #             break
        #dlg.Destroy()
        self._axisChoiceX.Clear()
        self._axisChoiceY.Clear()
        #Inserto los titulos de los ejes en los cuadros de opciones de ejes
        for a in range (0,data.shape[1]):
            self._axisChoiceX.InsertItems([str(data.iloc[0,a])],a)
            self._axisChoiceY.InsertItems([str(data.iloc[0,a])],a)
        #Se actualizan los valores
        self._axisChoiceX.Update()
        self._axisChoiceY.Update()
        #Por defecto como X se selecciona la primer columna y como Y la segunda
        self._axisChoiceX.SetSelection(0)
        self._axisChoiceY.SetSelection(1)

        #Se generan los numpy array de las primeras dos columnas y se devuelven
        try:
            self._setXLabel(0)
            self._setYLabel(1)
            self._setXName(data.iloc[0,0])
            self._setYName(data.iloc[0,1])
            #text=self.getXName()+'\n'+self.getYName()
            #wx.MessageBox(text, 'Info', wx.OK | wx.ICON_INFORMATION)
            x = data.loc[1:,0]
            xnumpy = x.values.astype(np.float64)
            y = data.loc[1:,1]
            ynumpy = y.values.astype(np.float64)
            status=True
        except Exception as e:
            status=False
            xnumpy=np.array(None)
            ynumpy=np.array(None)
            self._expData.writeexception(e)

        self.del_xy = np.array([0,1])
        index1 = [i for i in range(0, len(self.del_xy))]
        if not self.del_xy.size==0:
            self.del_xy=np.delete(self.del_xy,index1)

        if status:
            delNum=False
            try:
                for i in range (0, xnumpy.size):
                    #if xnumpy[i] == nan or ynumpy[i] == nan:
                    if math.isnan(xnumpy[i]) or math.isnan(ynumpy[i]):
                        self.del_xy = np.append(self.del_xy, i)
                        delNum=True
            except Exception as e:
                self._expData.writeexception(e)
            try:
                if delNum:
                    text="Algunos puntos se han importado vacios y han tenido que eliminarse. Los mismos estaban en las direcciones: ["
                    for i in range (0, self.del_xy.size):
                        if i != (self.del_xy.size-1):
                            text=text+str(self.del_xy[i]+1)+" ; "
                        else:
                            text=text+str(self.del_xy[i]+1)
                    text=text+"] del archivo original."
                    wx.MessageBox(text,
                                  'Information', wx.OK | wx.ICON_INFORMATION)
                    delNum=False
                    xnumpy=np.delete(xnumpy, self.del_xy)
                    ynumpy=np.delete(ynumpy, self.del_xy)
            except Exception as e:
                self._expData.writeexception(e)

        return xnumpy, ynumpy, status

    def pandasToNumpy(self, x):
        #Se generan los numpy array de las primeras dos columnas y se devuelven
        try:
            xnumpy = x.values.astype(np.float64)
            status=True
        except Exception as e:
            status=False
            xnumpy=np.array(None)
            self._expData.writeexception(e)

        self.del_xy = np.array([0,1])
        index1 = [i for i in range(0, len(self.del_xy))]
        if not self.del_xy.size==0:
            self.del_xy=np.delete(self.del_xy,index1)

        if status:
            delNum=False
            try:
                for i in range (0, xnumpy.size):
                    #if xnumpy[i] == nan or ynumpy[i] == nan:
                    if math.isnan(xnumpy[i]):
                        self.del_xy = np.append(self.del_xy, i)
                        delNum=True
            except Exception as e:
                self._expData.writeexception(e)
            try:
                if delNum:
                    text="Algunos puntos se han importado vacios y han tenido que eliminarse. Los mismos estaban en las direcciones: ["
                    for i in range (0, self.del_xy.size):
                        if i != (self.del_xy.size-1):
                            text=text+str(self.del_xy[i]+1)+" ; "
                        else:
                            text=text+str(self.del_xy[i]+1)
                    text=text+"] del archivo original."
                    #wx.MessageBox(text,
                     #             'Info', wx.OK | wx.ICON_INFORMATION)
                    delNum=False
                    xnumpy=np.delete(xnumpy, self.del_xy)
            except Exception as e:
                self._expData.writeexception(e)

        return xnumpy, status

    def titleEdData(self):
        #Fijarse si es aquí donde se pierden los labels
        self.panel.set_title(self._titleEdDataTextCtrl.GetValue())
        self._figure.tight_layout()
        self._figure.canvas.draw()

    # def askLabelData(self):
    #     if self.getDataFrame() is not None:
    #         data = self.getDataFrame()
    #         if not self._askLabelDataCheckBox.IsChecked():
    #             self._dataGrid.InsertRows()
    #             for i in range (0,data.shape[1]):
    #                 self._dataGrid.SetReadOnly(1, i, isReadOnly=True)
    #         else:
    #             if self._dataGrid.GetNumberRows() > self.limitDataToLoad:
    #                 self._dataGrid.DeleteRows()
    #                 for i in range (0,data.shape[1]):
    #                     self._dataGrid.SetReadOnly(0, i, isReadOnly=False)
    #     else:
    #         self._expData.writeinfo("The data has not been opened yet.")
    #         wx.MessageBox("The data has not been opened yet.",
    #                       'Info', wx.OK | wx.ICON_INFORMATION)

    def dataGridChange(self):
        #Cambia los nombres de columnas modificados en la grilla, pero aun no los
        #guarda en el array de datos
        if self.getDataFrame() is not None:
            data = self.getDataFrame()
            if data.shape[1] == self._dataGrid.GetNumberCols():
                self._axisChoiceX.Clear()
                self._axisChoiceY.Clear()

                #for a in range (0,data.shape[1]):
                for a in range (0, self._dataGrid.GetNumberCols()):
                    self._axisChoiceX.InsertItems([self._dataGrid.GetCellValue(0,a)],a)
                    self._axisChoiceY.InsertItems([self._dataGrid.GetCellValue(0,a)],a)
                    data.at[0, a] = self._dataGrid.GetCellValue(0,a)

                self._setXName(self._dataGrid.GetCellValue(0,self.getXLabel()))
                self._setYName(self._dataGrid.GetCellValue(0,self.getYLabel()))

                self._axisChoiceX.Update()
                self._axisChoiceY.Update()
                self.plotTitles()
                self._figure.tight_layout()
                self._figure.canvas.draw()
            else:
                wx.MessageBox("The column numbers of data and grid don't match.",
                    'Info', wx.OK | wx.ICON_INFORMATION)

    def _loadintogrid_array(self, x, y, init, rows):
        for j in range (1+init,rows+init):
            self._dataGrid.SetCellValue (j-init, 0, str(x[j-1]))
            self._dataGrid.SetCellValue (j-init, 1, str(y[j-1]))
            self._dataGrid.SetReadOnly(j-init, 0, isReadOnly=True)
            self._dataGrid.SetReadOnly(j-init, 1, isReadOnly=True)

        # for j in range (init,(rows+init)): #recorre filas
        #     for i in range (0,cols): #recorre columnas
        #         self._dataGrid.SetCellValue (j-init, i, str(data.iloc[j,i]))
        #         if not j-init == 0:
        #             self._dataGrid.SetReadOnly(j-init, i, isReadOnly=True)
        #         else:
        #             self._dataGrid.SetReadOnly(j-init, i, isReadOnly=False)
        #             self._dataGrid.SetCellValue (j-init, i, str(data.iloc[j-init,i]))

    def dataGridUpdate(self):
        if self.getXActual().any()==None or self.getYActual().any()==None:
            self._expData.writeinfo("The data has not been imported yet.")
        else:
            x = self.getXActual()
            y = self.getYActual()

            # if self.limitDataToLoad < x.shape[0]:
            #     if wx.MessageBox("The data file have more than 5000 values, the software might delay to show all the data array on a grid element. Do you want to display all the values on the grid element anyway?\n\nNOTE: The other functionalities (plot, math fuctions, etc) use all the values of the array in any case.", "Information", wx.ICON_QUESTION | wx.YES_NO, self) == wx.NO:
            #         rowNumber = self.limitDataToLoad
            #     else:
            #         rowNumber = x.shape[0]
            # else:
            #     rowNumber = x.shape[0]

            #Limpio la grilla
            self._dataGrid.ClearGrid()

            pos = self._datagridslider.GetValue()
            if pos == 1:
                if x.shape[0] < self.limitDataToLoad :
                    #los datos son menos de 100
                    rows = x.shape[0]
                    initialnumber = 0
                    self._setgridsize(rows, 2)
                    self._loadintogrid_array(x, y, initialnumber, rows)
                else:
                    #cargar los primeros 100 datos
                    rows = 101
                    initialnumber = 0
                    self._setgridsize(rows, 2)
                    self._loadintogrid_array(x, y, initialnumber, rows)
            else:
                gridpages = int(x.shape[0]/self.limitDataToLoad)
                if pos > gridpages:
                    #cargar la ultima pagina
                    rows = x.shape[0] - gridpages*100
                    initialnumber = gridpages*100
                    self._setgridsize(rows, 2)
                    self._loadintogrid_array(x, y, initialnumber, rows)
                else:
                    #detectar pagina y cargar 100 datos
                    rows = 101
                    initialnumber = (pos-1)*100
                    self._setgridsize(rows, 2)
                    self._loadintogrid_array(x, y, initialnumber, rows)

            #Redimencionamos la grilla

            # if 2>self._dataGrid.GetNumberCols():
            #     self._dataGrid.AppendCols(2-self._dataGrid.GetNumberCols())
            # elif 2<self._dataGrid.GetNumberCols():
            #     self._dataGrid.DeleteCols( numCols=(self._dataGrid.GetNumberCols()-2) )
            # if rowNumber>self._dataGrid.GetNumberRows():
            #     self._dataGrid.AppendRows(rowNumber-self._dataGrid.GetNumberRows())
            # elif rowNumber<self._dataGrid.GetNumberRows():
            #     self._dataGrid.DeleteRows( numRows=(self._dataGrid.GetNumberRows()-rowNumber) )

            #Detectar los titulos de columna
            data = self.getDataFrame()
            self._dataGrid.SetCellValue (0, 0, str(data.iloc[0,self._axisChoiceX.GetSelection()]))
            self._dataGrid.SetCellValue (0, 1, str(data.iloc[0,self._axisChoiceY.GetSelection()]))
            self._dataGrid.SetReadOnly(0, 0, isReadOnly=True)
            self._dataGrid.SetReadOnly(0, 1, isReadOnly=True)

            #Lo coloco en la grilla

            # dlg = wx.ProgressDialog("Loading data to the grid", " ", maximum=data.shape[0], style=wx.PD_APP_MODAL | wx.PD_AUTO_HIDE | wx.PD_CAN_ABORT)
            # dlg.Show()
            # if x.shape[0] < rowNumber:
            #     for j in range (1,x.shape):
            #         self._dataGrid.SetCellValue (j, 0, str(x[j-1]))
            #         self._dataGrid.SetCellValue (j, 1, str(y[j-1]))
            #         self._dataGrid.SetReadOnly(j, 0, isReadOnly=True)
            #         self._dataGrid.SetReadOnly(j, 1, isReadOnly=True)
            #         dlg.Pulse("Loading data")
            #         #dlg.Update(j, "Loading data")
            #         #dlg.Update (j, "%i of %i"%(j, int(data.shape[0])))
            #         if dlg.WasCancelled():
            #             break
            # else:
            #     for j in range (1,rowNumber):
            #         self._dataGrid.SetCellValue (j, 0, str(x[j-1]))
            #         self._dataGrid.SetCellValue (j, 1, str(y[j-1]))
            #         self._dataGrid.SetReadOnly(j, 0, isReadOnly=True)
            #         self._dataGrid.SetReadOnly(j, 1, isReadOnly=True)
            #         dlg.Pulse("Loading data")
            #         #dlg.Update(j, "Loading data")
            #         #dlg.Update (j, "%i of %i"%(j, int(data.shape[0])))
            #         if dlg.WasCancelled():
            #             break
            # dlg.Destroy()

    def dataGridOriginal(self):
        if self.getDataFrame() is not None:
            data = self.getDataFrame()

            if self.limitDataToLoad < data.shape[0]:
                if wx.MessageBox("The data file have more than 5000 values, the software might delay to show all the data array on a grid element. Do you want to display all the values on the grid element anyway?\n\nNOTE: The other functionalities (plot, math fuctions, etc) use all the values of the array in any case.", "Information", wx.ICON_QUESTION | wx.YES_NO, self) == wx.NO:
                    rowNumber = self.limitDataToLoad
                else:
                    rowNumber = data.shape[0]
            else:
                rowNumber = data.shape[0]

            #Limpio la grilla
            self._dataGrid.ClearGrid()
            #Redimencionamos la grilla
            if data.shape[1]>self._dataGrid.GetNumberCols():
                self._dataGrid.AppendCols(data.shape[1]-self._dataGrid.GetNumberCols())
            elif data.shape[1]<self._dataGrid.GetNumberCols():
                self._dataGrid.DeleteCols( numCols=(self._dataGrid.GetNumberCols()-data.shape[1]) )
            if rowNumber>self._dataGrid.GetNumberRows():
                self._dataGrid.AppendRows(rowNumber-self._dataGrid.GetNumberRows())
            elif rowNumber<self._dataGrid.GetNumberRows():
                self._dataGrid.DeleteRows( numRows=(self._dataGrid.GetNumberRows()-rowNumber) )

            #Lo coloco en la grilla
            dlg = wx.ProgressDialog("Loading data to the grid", " ", maximum=data.shape[0], style=wx.PD_APP_MODAL | wx.PD_AUTO_HIDE | wx.PD_CAN_ABORT)
            dlg.Show()
            if data.shape[0] < rowNumber:
                for j in range (0,data.shape[0]):
                    for i in range (0,data.shape[1]):
                        self._dataGrid.SetCellValue (j, i, str(data.iloc[j,i]))
                        if not j == 0:
                            self._dataGrid.SetReadOnly(j, i, isReadOnly=True)
                        else:
                            self._dataGrid.SetReadOnly(j, i, isReadOnly=False)
                    dlg.Pulse("Loading data")
                    #dlg.Update(j, "Loading data")
                    #dlg.Update (j, "%i of %i"%(j, int(data.shape[0])))
                    if dlg.WasCancelled():
                        break
            else:
                for j in range (0,rowNumber):
                    for i in range (0,data.shape[1]):
                        self._dataGrid.SetCellValue (j, i, str(data.iloc[j,i]))
                        if not j == 0:
                            self._dataGrid.SetReadOnly(j, i, isReadOnly=True)
                        else:
                            self._dataGrid.SetReadOnly(j, i, isReadOnly=False)
                    dlg.Pulse("Loading data")
                    #dlg.Update(j, "Loading data")
                    #dlg.Update (j, "%i of %i"%(j, int(data.shape[0])))
                    if dlg.WasCancelled():
                        break
            dlg.Destroy()

    def axisChoiceXMethod(self):
        if self.getDataFrame() is not None:
            if not self._askPoints:
                self.askSavePoints()
            data = self.getDataFrame()
            self._setXLabel(self._axisChoiceX.GetSelection())
            self._setXName(self._axisChoiceX.GetString(self._axisChoiceX.GetSelection()))
            #wx.MessageBox(self.getXName(), 'Info', wx.OK | wx.ICON_INFORMATION)
            x1 = data.loc[1:,self._axisChoiceX.GetSelection()]
            x = x1.values.astype(np.float64)
            self.setXActual(x)
            self._setXOrigin(x)
            y = self.getYOriginal()
            self._setHoriLower(0)
            self._setHoriUpper(x.size)
            self.setCutSliderLimits(x, y, x, y)
            self.setArrayLimits(x, y)
            self.setAbsSliderLimits(x)
            self.replot2D(x, y)

    def axisChoiceYMethod(self):
        if self.getXOriginal().any()==None:
            self._expData.writeinfo("The data has not been imported yet.")
        else:
            if self.getDataFrame() is not None:
                if not self._askPoints:
                    self.askSavePoints()
                data = self.getDataFrame()
                self._setYLabel(self._axisChoiceY.GetSelection())
                self._setYName(self._axisChoiceY.GetString(self._axisChoiceY.GetSelection()))
                #wx.MessageBox(self.getYName(), 'Info', wx.OK | wx.ICON_INFORMATION)
                y1 = data.loc[1:,self._axisChoiceY.GetSelection()]
                y = y1.values.astype(np.float64)
                self.setYActual(y)
                self._setYOrigin(y)
                x = self.getXOriginal()
                self._setHoriLower(0)
                self._setHoriUpper(x.size)
                self.setCutSliderLimits(x, y, x, y)
                self.setArrayLimits(x, y)
                self.setAbsSliderLimits(x)
                self.replot2D(x, y)

    def eSound (self):
        if self.getXActual().any()==None or self.getYActual().any()==None:
            self._expData.writeinfo("The data has not been imported yet.")
        else:
            #wx.MessageBox('The software do not save the sound for the moment, the development team are working on that.',
            #              'Problem saving the sound:', wx.OK | wx.ICON_INFORMATION)
            eSoundPath=self._expData.setpath("Save sound file", "Sound files |*.wav")
            x = self.getXActual()
            y = self.getYActual()
            try:
                #self._dataSound.reproductor.setInstrument(self._get_waveformnumber())
                norm_x, norm_y, status = self._matFc.normalize(x, y)
                self._dataSound.save_sound(eSoundPath, norm_x, norm_y)
            except AttributeError as e:
                self._expData.writeinfo("The data has not been imported yet.")
                self._expData.writeexception(e)
            except Exception as e:
                self._expData.r(e)

    def savePlot(self):
        plotPath = self._expData.setpath("Save plot file", "Image files |*.png")
        try:
            self._figure.savefig(plotPath)
        except Exception as e:
            self._expData.writeexception(e)

    def play(self):
        if self.getXActual().any()==None or self.getYActual().any()==None:
            self._expData.writeinfo("The data has not been imported yet.")
        else:
            if self._timer_envelope.IsRunning():
                self._timer_envelope.Stop()
                self._settimerenvelopeindex(0)
                self._envelopeplaytogglebtn.SetLabel('Play envelope\nsound')
                self._envelopeplaytogglebtn.SetValue(False)
            if not self._timer.IsRunning():
                # try:
                #     waveform = self._swaveformlistbox.GetString(self._swaveformlistbox.GetSelection())
                #     self._dataSound.reproductor.set_waveform(waveform)
                # except Exception as e:
                #     self._expData.writeexception(e)
                try:
                    x = self.getXActual()
                    y = self.getYActual()
                    norm_x, norm_y, status = self._matFc.normalize(x, y)
                    self._expData.printoutput("Normalize the input data.")
                    self._setNormXY(norm_x, norm_y)
                except AttributeError as e:
                    self._expData.writeinfo("The data has not been imported yet.")
                    self._expData.writeexception(e)
                except Exception as e:
                    self._expData.writeexception(e)
                #Seteo el tempo dependiendo del tiempo del timer
                self._timer.Start((self._getVelocity()*2) + 10)
                self._dataSound.reproductor.set_time_base(self._timer.GetInterval()/1000.0)
            else:
                self._expData.printoutput("The timer is alredy on when the user press Play button.")

    def _playenvelope(self):
        env = self.getenvelope()
        print('**************')
        print(env)
        if env.size == 0:
            self._expData.writeinfo("The data has not been sonified yet.")
            wx.MessageBox("Any data set was sonified, you need to import and sonify a dataset to enable this functionality.",
                              'Information', wx.OK | wx.ICON_INFORMATION)
            self._envelopeplaytogglebtn.SetLabel('Play envelope\nsound')
            self._envelopeplaytogglebtn.SetValue(False)
        else:
            if self._timer.IsRunning():
                self.stopMethod()
                wx.MessageBox("The previous reproduction of the data has been stopped to reproduce the envelope of the sound.",
                              'Information', wx.OK | wx.ICON_INFORMATION)
            if not self._timer_envelope.IsRunning():
                self._timer_envelope.Start(10)
                self._dataSound.reproductor.set_time_base(self._timer_envelope.GetInterval()/1000.0)
            else:
                self._expData.printoutput("The envelope sound is alredy on when the user press Play envelope.")

    def playMethod(self):
        if self.getXActual().any()==None:
            self._expData.writeinfo("The data has not been imported yet.")
            self._playButton.SetValue(False)
            self._playmenuitem.Check(False)
        else:
            if not self._timer.IsRunning():
                self._expData.printoutput("Play button is pressed.")
                self._playButton.SetLabel("Pause")
                self._playButton.SetValue(True)
                self._playmenuitem.SetItemLabel('Pause' + '\t' + 'Alt+Shift+P')
                self._playmenuitem.Check(True)
                self.play()
            elif self._timer.IsRunning():
                self._expData.printoutput("Pause button is pressed.")
                self._playButton.SetLabel("Play")
                self._playButton.SetValue(False)
                self._playmenuitem.SetItemLabel('Play' + '\t' + 'Alt+Shift+P')
                self._playmenuitem.Check(False)
                #self._dataSound.make_sound(0, -1)
                self._timer.Stop()
            else:
                self._expData.writeinfo("Error con el contador del botón Play-Pausa")

    def stopMethod(self):
        self._playButton.SetValue(False)
        self._playmenuitem.Check(False)
        self._playButton.SetLabel("Play")
        self._playmenuitem.SetItemLabel('Play' + '\t' + 'Alt+Shift+P')

        if self.getXActual().any()==None or self.getYActual().any()==None:
            self._expData.writeinfo("The data has not been imported yet.")
        else:
            if self._timer.IsRunning():
                #self._dataSound.make_sound(0, -1)
                self._timer.Stop()
            self._setTimerIndex(0)
            self._abspos_slider.SetValue(0)
            self._absposlabel_textctrl.SetValue(str(round(self.getXActual()[self._abspos_slider.GetValue()],4)))
            self.replot2D(self.getXActual(), self.getYActual())

    def markPoints (self):
        if self.getXActual().any()==None or self.getYActual().any()==None:
            self._expData.writeinfo("The data has not been imported yet.")
        else:
            #Se eliminarán los datos cada vez que se guardan o que se ingresa un archivo de datos nuevo.
            x = self.getXActual()
            y = self.getYActual()
            xp = self._getxPoints()
            yp = self._getyPoints()
            try:
                index = self._getTimerIndex() - 1
                xp = np.append(xp, x[index])
                yp = np.append(yp, y[index])
                self._setxPoints(xp)
                self._setyPoints(yp)
            except Exception as e:
                self._expData.writeexception(e)
            self._askPoints = False
            #para graficar una línea
            try:
                self._setAbsMarkPoint( np.array([float(x[index]), float(x[index])]))
                self._setOrdMarkPoint( np.array([float(np.amin(y)), float(np.amax(y))]))
            except AttributeError as e:
                self._expData.writeinfo("The data has not been imported yet.")
                self._expData.writeexception(e)
            except Exception as e:
                self._expData.writeexception(e)
            self.plotMarkLine()

    def deleteLastMark (self):
        if self.getXActual().any()==None or self.getYActual().any()==None:
            self._expData.writeinfo("The data has not been imported yet.")
        else:
            try:
                xp = self._getxPoints()
                yp = self._getyPoints()
                xp = xp[:-1].copy()
                yp = yp[:-1].copy()
                self._setxPoints(xp)
                self._setyPoints(yp)
                self.replot2D(self.getXActual(),self.getYActual())
            except Exception as e:
                self._expData.writeexception(e)

    def deleteAllMark (self):
        if self.getXActual().any()==None or self.getYActual().any()==None:
            self._expData.writeinfo("The data has not been imported yet.")
        else:
            xp = self._getxPoints()
            yp = self._getyPoints()
            try:
                index = [i for i in range(0, len(xp))]
            except Exception as e:
                self._expData.writeexception(e)
            try:
                self._setxPoints(np.delete(xp,index))
                self._setyPoints(np.delete(yp,index))
            except Exception as e:
                self._expData.writeexception(e)
            try:
                self.replot2D(self.getXActual(), self.getYActual())
            except Exception as e:
                self._expData.writeexception(e)

    def saveData (self):
        if self.getXActual().any()==None or self.getYActual().any()==None:
            self._expData.writeinfo("The data has not been imported yet.")
        else:
            x = self.getXActual()
            y = self.getYActual()
            try:
                self._expData.writepointfile(x, y)
            except Exception as e:
                self._expData.writeexception(e)

    def saveMarks (self):
        if self.getXActual().any()==None or self.getYActual().any()==None:
            self._expData.writeinfo("The data has not been imported yet.")
        else:
            xp = self._getxPoints()
            yp = self._getyPoints()
            try:
                self._expData.writepointfile(xp, yp)
            except AttributeError as e:
                self._expData.writeinfo("The array with numbers of interest has not been created yet.")
                self._expData.writeexception(e)
            except Exception as e:
                self._expData.writeexception(e)
            index = [i for i in range(0, len(xp))]
            self._setxPoints(np.delete(xp,index))
            self._setyPoints(np.delete(yp,index))
            self.replot2D(self.getXActual(), self.getYActual())

    def absPosSetting (self):
        if self.getXActual().any()==None or self.getYActual().any()==None:
            self._expData.writeinfo("The data has not been imported yet.")
        else:
            #Set the red line to mark de points in the graph
            x = self.getXActual()
            y = self.getYActual()
            ordenada = np.array([float(np.amin(y)), float(np.amax(y))])
            abscisa = np.array([float(x[self._abspos_slider.GetValue()]), float(x[self._abspos_slider.GetValue()])])
            self.plotRedLine(abscisa, ordenada)

    def tempo(self):
        if self._timer.IsRunning():
            self._timer.Stop()
            self._timer.Start((self._getVelocity()*2) + 10)
            self._dataSound.reproductor.sound.stop()
            self._dataSound.reproductor.set_time_base(self._timer.GetInterval()/1000.0)

#    def cutVertical(self):
#        self.askSavePoints()
#        #Se debe realizar todo el mapeo para que reproduzca tick marks en los valores que exeden el límite y que se remapee el resto que si está en los límites.
#        try:
#            self.limitVLower = float(self._lVLimitSlider.GetValue())
#        except Exception as e:
#            self._expData.writeexception(e)
#        try:
#            self.limitVUpper = float(self._uVLimitSlider.GetValue())
#        except Exception as e:
#            self._expData.writeexception(e)

    def cutHorizontal (self):
        if self.getXOriginal().any()==None or self.getYOriginal().any()==None:
            self._expData.writeinfo("The data has not been imported yet.")
        else:
            if not self._askPoints:
                self.askSavePoints()
            try:
                lower = (self._lHLimitSlider.GetValue())
                self._setHoriLower(lower)
            except Exception as e:
                self._expData.writeexception(e)
            try:
                upper = (self._uHLimitSlider.GetValue())
                self._setHoriUpper(upper)
            except Exception as e:
                self._expData.writeexception(e)
            xo = self.getXOriginal()
            yo = self.getYOriginal()
            try:
                x = xo[lower:(upper+1)]
                y = yo[lower:(upper+1)]
                self.setXActual(x)
                self.setYActual(y)
            except AttributeError as e:
                self._expData.writeinfo("The data has not been imported yet.")
                self._expData.writeexception(e)
            except Exception as e:
                self._expData.writeexception(e)
            try:
                self.setCutSliderLimits(xo, yo, x, y)
                self.setArrayLimits(x, y)
                self.setAbsSliderLimits(x)
                self.replot2D(x, y)
            except AttributeError as e:
                self._expData.writeinfo("The data has not been imported yet.")
                self._expData.writeexception(e)
            except Exception as e:
                self._expData.writeexception(e)

    #Maybe we add soundfont in the future
    """def _soundFontChoice(self):
        if self._sFontLabel == 'gm':
            self._expData.printoutput("The choice of sound font is general midi, that's the default sound font.")
            if platform.system() == 'Windows':
                self._sFontChoice = "soundModule\soundFont\FluidR3_GM.sf2"
            else:
                if platform.system() == 'Linux':
                    self._sFontChoice = "soundModule/soundFont/FluidR3_GM.sf2"
                else:
                    if platform.system() == 'Darwin':
                        self._sFontChoice = "soundModule/soundFont/FluidR3_GM.sf2"
                    else:
                        self._expData.writeinfo("The operative system is unknown, the software can't open the sound font.")
        elif self._sFontLabel == 'other':
            self._expData.printoutput("The choice of sound font is look on the operative system.")
            self._sFontChoice = self._openData.getSFPath()
        else:
            self._expData.printoutput("Error!: the sound font chosen is not correct!.")
            self._expData.writeinfo("Error in 'soundFontChoice', on core.py!: the sound
            font chosen is not correct!.")"""

    def swaveformlistboxchoice(self):
        # self._set_waveformnumber(self._swaveformlistbox.GetSelection()+1)
        waveform = self._swaveformlistbox.GetString(self._swaveformlistbox.GetSelection())
        self._dataSound.reproductor.set_waveform(waveform)
        # return waveform

    def matFcSelection(self):
        if self._matFcListBox.GetString(self._matFcListBox.GetSelection()) == "Last limits cut":
            self._avNPointsspinCtrl.Enable(False)
            self._expData.printoutput("Last limits cut function is selected.")
            self._setMatSelection("Last limits cut")
        if self._matFcListBox.GetString(self._matFcListBox.GetSelection()) == "Original":
            self._avNPointsspinCtrl.Enable(False)
            self._expData.printoutput("Original function is selected.")
            self._setMatSelection("Original")
        if self._matFcListBox.GetString(self._matFcListBox.GetSelection()) == "Inverse":
            self._avNPointsspinCtrl.Enable(False)
            self._expData.printoutput("Inverse function is selected.")
            self._setMatSelection("Inverse")
        if self._matFcListBox.GetString(self._matFcListBox.GetSelection()) == "Play Backward":
            self._avNPointsspinCtrl.Enable(False)
            self._expData.printoutput("Play Backward function is selected.")
            self._setMatSelection("Play Backward")
        if self._matFcListBox.GetString(self._matFcListBox.GetSelection()) == "Square":
            self._avNPointsspinCtrl.Enable(False)
            self._expData.printoutput("Square function is selected.")
            self._setMatSelection("Square")
        if self._matFcListBox.GetString(self._matFcListBox.GetSelection()) == "Square root":
            self._avNPointsspinCtrl.Enable(False)
            self._expData.printoutput("Square root function is selected.")
            self._setMatSelection("Square root")
        if self._matFcListBox.GetString(self._matFcListBox.GetSelection()) == "Logarithm":
            self._avNPointsspinCtrl.Enable(False)
            self._expData.printoutput("Logarithm function is selected.")
            self._setMatSelection("Logarithm")
        if self._matFcListBox.GetString(self._matFcListBox.GetSelection()) == "Average":
            self._avNPointsspinCtrl.SetValue(1)
            self._avNPointsspinCtrl.Enable(True)
            self._expData.printoutput("Average function is selected.")
            self._setMatSelection("Average")
        self.matFcExecutor()

    def matFcExecutor(self):
        if self.getXActual().any()==None or self.getYActual().any()==None:
            self._expData.writeinfo("The data has not been imported yet.")
        else:
            if not self._askPoints:
                self.askSavePoints()
            xo = self.getXOriginal()
            yo = self.getYOriginal()
#            xo, yo = self._matFc.mfOriginal(self.getXOriginal(), self.getYOriginal())
            x = self.getXActual()
            y = self.getYActual()
#            x, y = self._matFc.mfOriginal(self.getXActual(), self.getYActual())
            if self._getMatSelection() == "Last limits cut":
                self._lHLimitSlider.Enable(True)
                self._uHLimitSlider.Enable(True)
                x = xo[self._getHoriLower():(self._getHoriUpper()+1)]
                y = yo[self._getHoriLower():(self._getHoriUpper()+1)]
                self._expData.printoutput("Last limits cut function is executed.")
                self.inverseFunc = False
            if self._getMatSelection() == "Original":
                self._lHLimitSlider.Enable(True)
                self._uHLimitSlider.Enable(True)
                x = self.getXOriginal()
                y = self.getYOriginal()
#                x, y = self._matFc.mfOriginal(self.getXOriginal(), self.getYOriginal())
                self._expData.printoutput("Original function is executed.")
                self.inverseFunc = False
            if self._getMatSelection() == "Inverse":
                self._lHLimitSlider.Enable(False)
                self._uHLimitSlider.Enable(False)
                #x, y = self._matFc.mfInverse(self.getXOriginal(), self.getYOriginal())
                self.inverseFunc = True
                self._expData.printoutput("Inverse function is executed.")
            if self._getMatSelection() == "Play Backward":
                self._lHLimitSlider.Enable(False)
                self._uHLimitSlider.Enable(False)
                x, y = self._matFc.mfPlayBack(self.getXOriginal(), self.getYOriginal())
                self._expData.printoutput("Play Backward function is executed.")
                self.inverseFunc = False
            if self._getMatSelection() == "Square":
                self._lHLimitSlider.Enable(False)
                self._uHLimitSlider.Enable(False)
                x, y, status = self._matFc.square(self.getXOriginal(), self.getYOriginal())
                self._expData.printoutput("Square function is executed.")
                self.inverseFunc = False
            if self._getMatSelection() == "Square root":
                self._lHLimitSlider.Enable(False)
                self._uHLimitSlider.Enable(False)
                x, y, status = self._matFc.squareroot(self.getXOriginal(), self.getYOriginal())
                self._expData.printoutput("Square root function is executed.")
                self.inverseFunc = False
            if self._getMatSelection() == "Logarithm":
                self._lHLimitSlider.Enable(False)
                self._uHLimitSlider.Enable(False)
                x, y, status = self._matFc.logarithm(self.getXOriginal(), self.getYOriginal())
                self._expData.printoutput("Logarithm function is executed.")
                self.inverseFunc = False
            if self._getMatSelection() == "Average":
                self._lHLimitSlider.Enable(False)
                self._uHLimitSlider.Enable(False)
                x, y, status = self._matFc.average(self.getXOriginal(), self.getYOriginal(), self._getavNPoints())
                self._expData.printoutput("Average function is executed.")
                self.inverseFunc = False
            try:
                self.setXActual(x)
                self.setYActual(y)
            except AttributeError as e:
                self._expData.writeinfo("The data has not been imported yet.")
                self._expData.writeexception(e)
            except Exception as e:
                self._expData.writeexception(e)
            try:
                self.setCutSliderLimits(xo, yo, x, y)
                self.setArrayLimits(x, y)
                self.setAbsSliderLimits(x)
                self.replot2D(x, y)
            except AttributeError as e:
                self._expData.writeinfo("The data has not been imported yet.")
                self._expData.writeexception(e)
            except Exception as e:
                self._expData.writeexception(e)

    def averageSelect(self):
        if self.getXActual().any()==None:
            self._expData.writeinfo("The data has not been imported yet.")
        else:
            #seteo los límites de average
            x = self.getXActual()
            if x.any() == None:
                self._avNPointsspinCtrl.SetMax(x.size-1)
                self._avNPointsspinCtrl.SetMin(1)
                self._avNPointsspinCtrl.SetValue(1)
                self._setavNPoints(1)
                self._avNPointsspinCtrl.Enable(True)
                self._setMatSelection("Average")
                self.matFcExecutor()

    def lineStyleConfig(self, index):
        if self.getXActual().any()==None or self.getYActual().any()==None:
            self._expData.writeinfo("The data has not been imported yet.")
        else:
            if index == 0:
                self._setLineChar('')
                if self._getMarkerStyleIndex()<1 or self._getMarkerStyleIndex()>21:
                    self._setMarkerStyleIndex(0)
                self.markerStyleConfig()
                self._expData.printoutput("Discreet line was selected.")
            elif index == 1:
                self._setLineChar('-')
                self._setMarkerChar('')
                self._setMarkerStyleIndex(22)
                self.replot2D(self.getXActual(), self.getYActual())
                self.SendSizeEvent()
                self._expData.printoutput("Solid line was selected.")
            elif index == 2:
                self._setLineChar('--')
                self._setMarkerChar('')
                self._setMarkerStyleIndex(22)
                self.replot2D(self.getXActual(), self.getYActual())
                self.SendSizeEvent()
                self._expData.printoutput("Dashed line was selected.")
            elif index == 3:
                self._setLineChar('-.')
                self._setMarkerChar('')
                self._setMarkerStyleIndex(22)
                self.replot2D(self.getXActual(), self.getYActual())
                self.SendSizeEvent()
                self._expData.printoutput("Dash-dot line was selected.")
            elif index == 4:
                self._setLineChar(':')
                self._setMarkerChar('')
                self._setMarkerStyleIndex(22)
                self.replot2D(self.getXActual(), self.getYActual())
                self.SendSizeEvent()
                self._expData.printoutput("Dotted line was selected.")
            else:
                self._setLineChar('-')
                self._setMarkerChar('')
                self._setMarkerStyleIndex(22)
                self.replot2D(self.getXActual(), self.getYActual())
                self.SendSizeEvent()
                self._expData.printoutput("The line style was unknow, solid line was selected by default.")

    def markerStyleConfig(self):
        if self._getMarkerStyleIndex() == 0:
            self._setMarkerChar('.')
            self._expData.printoutput("Point marker line was selected.")
        elif self._getMarkerStyleIndex() == 1:
            self._setMarkerChar(',')
            self._expData.printoutput("Pixel marker line was selected.")
        elif self._getMarkerStyleIndex() == 2:
            self._setMarkerChar('o')
            self._expData.printoutput("Circle marker line was selected.")
        elif self._getMarkerStyleIndex() == 3:
            self._setMarkerChar('v')
            self._expData.printoutput("Triangle down marker line was selected.")
        elif self._getMarkerStyleIndex() == 4:
            self._setMarkerChar('^')
            self._expData.printoutput("Triangle up marker line was selected.")
        elif self._getMarkerStyleIndex() == 5:
            self._setMarkerChar('<')
            self._expData.printoutput("Triangle left marker line was selected.")
        elif self._getMarkerStyleIndex() == 6:
            self._setMarkerChar('>')
            self._expData.printoutput("Triangle right marker line was selected.")
        elif self._getMarkerStyleIndex() == 7:
            self._setMarkerChar('1')
            self._expData.printoutput("Tri-down marker line was selected.")
        elif self._getMarkerStyleIndex() == 8:
            self._setMarkerChar('2')
            self._expData.printoutput("Tri-up marker line was selected.")
        elif self._getMarkerStyleIndex() == 9:
            self._setMarkerChar('3')
            self._expData.printoutput("Tri-left marker line was selected.")
        elif self._getMarkerStyleIndex() == 10:
            self._setMarkerChar('4')
            self._expData.printoutput("Tri-right marker line was selected.")
        elif self._getMarkerStyleIndex() == 11:
            self._setMarkerChar('s')
            self._expData.printoutput("Square marker line was selected.")
        elif self._getMarkerStyleIndex() == 12:
            self._setMarkerChar('p')
            self._expData.printoutput("Pentagon marker line was selected.")
        elif self._getMarkerStyleIndex() == 13:
            self._setMarkerChar('*')
            self._expData.printoutput("Star marker line was selected.")
        elif self._getMarkerStyleIndex() == 14:
            self._setMarkerChar('h')
            self._expData.printoutput("Hexagon (1) marker line was selected.")
        elif self._getMarkerStyleIndex() == 15:
            self._setMarkerChar('H')
            self._expData.printoutput("Hexagon (2) marker line was selected.")
        elif self._getMarkerStyleIndex() == 16:
            self._setMarkerChar('+')
            self._expData.printoutput("Plus marker line was selected.")
        elif self._getMarkerStyleIndex() == 17:
            self._setMarkerChar('x')
            self._expData.printoutput("X marker line was selected.")
        elif self._getMarkerStyleIndex() == 18:
            self._setMarkerChar('D')
            self._expData.printoutput("Diamond marker line was selected.")
        elif self._getMarkerStyleIndex() == 19:
            self._setMarkerChar('d')
            self._expData.printoutput("Thin diamond marker line was selected.")
        elif self._getMarkerStyleIndex() == 20:
            self._setMarkerChar('|')
            self._expData.printoutput("Vertical line marker of the line was selected.")
        elif self._getMarkerStyleIndex() == 21:
            self._setMarkerChar('_')
            self._expData.printoutput("Horizontal line marker of the line was selected.")
        elif self._getMarkerStyleIndex() == 22:
            self._setMarkerChar('')
            self._expData.printoutput("Any marker line was selected.")
        else:
            self._setMarkerChar('')
            self._expData.printoutput("The line marker style was unknow, any marker line was selected by default.")
        if self.getXActual().any()==None or self.getYActual().any()==None:
            self._expData.writeinfo("The data has not been imported yet.")
        else:
            self.replot2D(self.getXActual(), self.getYActual())
            self.SendSizeEvent()

    def colorStyleConfig(self, index):
        if index == 0:
            self._setColorChar('b')
            self._expData.printoutput("Blue line color was selected.")
        elif index == 1:
            self._setColorChar('g')
            self._expData.printoutput("Green line color was selected.")
        elif index == 2:
            self._setColorChar('r')
            self._expData.printoutput("Red line color was selected.")
        elif index == 3:
            self._setColorChar('c')
            self._expData.printoutput("Cyan line color was selected.")
        elif index == 4:
            self._setColorChar('m')
            self._expData.printoutput("Magenta line color was selected.")
        elif index == 5:
            self._setColorChar('y')
            self._expData.printoutput("Yellow line color was selected.")
        elif index == 6:
            self._setColorChar('k')
            self._expData.printoutput("Black line color was selected.")
        else:
            self._setColorChar('b')
            self._expData.printoutput("The line color style was unknow, blue line color was selected by default.")
        if self.getXActual().any()==None or self.getYActual().any()==None:
            self._expData.writeinfo("The data has not been imported yet.")
        else:
            self.replot2D(self.getXActual(), self.getYActual())
            self.SendSizeEvent()

    def askSavePoints(self):
        self._askPoints = True
        if self._timer.IsRunning():
            self.stopMethod()
        xp = self._getxPoints()
        yp = self._getyPoints()
        if not xp.size==0:
            if wx.MessageBox("Brands have been made on the data. Do you want to save them?.", "Please confirm",
                         wx.ICON_QUESTION | wx.YES_NO, self) == wx.NO:
                index = [i for i in range(0, len(xp))]
                self._setxPoints(np.delete(xp,index))
                self._setyPoints(np.delete(yp,index))
            else:
                self.saveMarks()

    def detectcommand(self):
        # yy
        text_original = self._writecommandtextctrl.GetLineText(0)
        #text_original = text_original.replace(' ','')
        cut = text_original.find('(')
        cut2 = text_original.rfind(')')
        if cut!=(-1):
            text = text_original[:cut]
        else:
            text_original = text_original.replace(' ','')
            text = text_original
        #Se chequea a que diccionario corresponde y se ejecuta el comando
        if text in self.command_dict_withoutparam:
            self.command_dict_withoutparam[text]()
        elif text in self.command_dict_withparam:
            if cut==(-1) or cut2==(-1):
                msg = ('You must enter the value between parentheses. '
                    +'Your command was: \n'+text_original)
                wx.MessageBox(
                    msg,
                    'Command error',
                    wx.OK | wx.ICON_INFORMATION
                    )
            else:
                value = text_original[cut+1:cut2]
                self.command_dict_withparam[text](value)
        else:
            msg = ('The command inserted do not match with the list of '
                + 'functionalities. The text inserted was: \n' + text)
            wx.MessageBox(msg,
                          'Command not found', wx.OK | wx.ICON_INFORMATION)
        self._writecommandtextctrl.Clear()

    def xposition_command(self, value):
        try:
            try:
                x_value = float(value)
            except Exception as e:
                wx.MessageBox(
                    'The typed number contains some caracter that do not match with a number.',
                    'Number Error',
                    wx.OK | wx.ICON_INFORMATION
                    )
                self.setAbsSliderLimits(self.getXActual())
                self._expData.writeexception(e)
            x_array = self.getXActual()
            abs_val_array = np.abs(x_array - x_value)
            x_pos = abs_val_array.argmin()
            if x_value<np.amin(self.getXActual()) or x_value>np.amax(self.getXActual()):
                wx.MessageBox(
                    'The number indicated was out of the array bounds.',
                    'Out of bounds',
                    wx.OK | wx.ICON_INFORMATION
                    )
            else:
                self._abspos_slider.SetValue(x_pos)
                self._absposlabel_textctrl.SetValue(str(round(x_array[self._abspos_slider.GetValue()],4)))
                self._setTimerIndex(x_pos)
                self.absPosSetting()
        except Exception as e:
            self._expData.writeexception(e)

    def selecttempo_command(self, value):
        t = int(value)
        self._tempoposlabel_textctrl.SetValue(str(value))
        self._soundVelSlider.SetValue(t)
        self._setVelocity(t)
        self.tempo()

    def xlowerlimit_command(self, value):
        try:
            x_value = float(value)
            x_array = self.getXOriginal()
            abs_val_array = np.abs(x_array - x_value)
            if x_value<np.amin(self.getXOriginal()) or x_value>np.amax(self.getXOriginal()):
                wx.MessageBox(
                    'The number indicated was out of the array bounds.',
                    'Out of bounds',
                    wx.OK | wx.ICON_INFORMATION
                    )
            else:
                x_pos = abs_val_array.argmin()
                self._lHLimitSlider.SetValue(x_pos)
                self.cutHorizontal()
        except Exception as e:
            self._expData.writeexception(e)

    def xupperlimit_command(self, value):
        try:
            x_value = float(value)
            x_array = self.getXOriginal()
            abs_val_array = np.abs(x_array - x_value)
            if x_value<np.amin(self.getXOriginal()) or x_value>np.amax(self.getXOriginal()):
                wx.MessageBox(
                    'The number indicated was out of the array bounds.',
                    'Out of bounds',
                    wx.OK | wx.ICON_INFORMATION
                    )
            else:
                x_pos = abs_val_array.argmin()
                self._uHLimitSlider.SetValue(x_pos)
                self.cutHorizontal()
        except Exception as e:
            self._expData.writeexception(e)

    def originaldata_command(self):
        self._avNPointsspinCtrl.Enable(False)
        self._setMatSelection("Original")
        self.matFcExecutor()

    def xlastcut_command(self):
        self._avNPointsspinCtrl.Enable(False)
        self._setMatSelection("Last limits cut")
        self.matFcExecutor()

    def inverse_command(self):
        self._avNPointsspinCtrl.Enable(False)
        self._setMatSelection("Inverse")
        self.matFcExecutor()

    def square_command(self):
        self._avNPointsspinCtrl.Enable(False)
        self._setMatSelection("Square")
        self.matFcExecutor()

    def squareroot_command(self):
        self._avNPointsspinCtrl.Enable(False)
        self._setMatSelection("Square root")
        self.matFcExecutor()

    def logarithm_command(self):
        self._avNPointsspinCtrl.Enable(False)
        self._setMatSelection("Logarithm")
        self.matFcExecutor()

#Métodos para vincular con octave

    def _savePythonConsole(self):
        text = self._pythonShell.GetText()
        self._expData.printoutput("Python console text: \n" + text)
        self._pythonShell.Execute("self._pythonShell.clear()")

    def _analizeOctaveOutput(self, show):
        text = self._pythonShell.GetText()
        self._expData.printoutput("Python console text: \n" + text)

        indexError = text.find("Traceback")
        if not indexError == -1:
            text1 = text[indexError:-5]
            text2 = text1.rstrip('\n')
            wx.MessageBox(text2,
                          'Error from octave', wx.OK | wx.ICON_INFORMATION)
        else:
            if show:
                index1 = text.find(">>>")
                text3 = text[index1:]
                
                index_command = text.find('"')
                text_command = text3[index_command+1:]
                index_command = text_command.find('"')
                text_command = text_command[:index_command]
                self._octaveOutputTextCtrl.write('>>> '+text_command+'\n')
                
                index2 = text3.find("\n")
                text4 = text3[index2:]
                index3 = text4.find('>')
                text5 = text4[:index3-1]
                
                self._octaveOutputTextCtrl.write(text5+'\n')

        self._pythonShell.Execute("self._pythonShell.clear()")

    def _sendAllToOctave(self):
        if self.getDataFrame() is not None:
            self._expData.printoutput("Sending imported data to octave.")
            try:

                #if data.shape[0] < rowNumber:
                data = self.getDataFrame()

                for i in range (0, data.shape[1]):
                    #text = "octave.push('" + data.iloc[0,i] + "', data.iloc[1:,i])"
                    #wx.MessageBox(text, " ", wx.OK | wx.ICON_INFORMATION)

                    self.dataToOctave, status = self.pandasToNumpy(data.iloc[1:,i])
                    if status:
                        col_name_status = re.search('[^a-zA-Z0-9 \n\.]', data.iloc[0,i])
                        if not col_name_status==None:
                            col_name = re.sub('[^a-zA-Z0-9 \n\.]', '', data.iloc[0,i])
                            msg = (
                                'The name of the octave variable for column number '
                                + str(i+1)
                                + ' was changed to:\n'
                                + col_name
                                )
                            wx.MessageBox(msg,
                              'Variable name', wx.OK | wx.ICON_INFORMATION)
                        else:
                            col_name = data.iloc[0,i]
                        #self._pythonShell.Execute("octave.push('x', self.getXActual())")
                        self._pythonShell.Execute("octave.push('" + col_name + "', self.dataToOctave)")
                        self._analizeOctaveOutput(False)
                    else:
                        wx.MessageBox("Problems sending data to octave.", " ", wx.OK | wx.ICON_INFORMATION)

#                self._pythonShell.Execute("octave.push('x', self.getXActual())")
#                self._analizeOctaveOutput()
#                self._pythonShell.Execute("octave.push('y', self.getYActual())")
#                self._analizeOctaveOutput()
#                self._pythonShell.Execute("octave.push('xoriginal', self.getXOriginal())")
#                self._analizeOctaveOutput()
#                self._pythonShell.Execute("octave.push('yoriginal', self.getYOriginal())")
#                self._analizeOctaveOutput()
            except Exception as e:
                    self._expData.writeexception(e)

    def _sendToOctave(self):
        self._expData.printoutput("Sending data to octave.")
        try:
            self._pythonShell.Execute("octave.push('x', self.getXActual())")
            self._analizeOctaveOutput(False)
            self._pythonShell.Execute("octave.push('y', self.getYActual())")
            self._analizeOctaveOutput(False)
#            self._pythonShell.Execute("octave.push('xoriginal', self.getXOriginal())")
#            self._analizeOctaveOutput()
#            self._pythonShell.Execute("octave.push('yoriginal', self.getYOriginal())")
#            self._analizeOctaveOutput()
#        try:
#            if self._sendToOctaveListBox.GetString(self._sendToOctaveListBox.GetSelection()) == "X":
#                self._pythonShell.Execute("octave.push('x', self.getXActual())")
#                self._analizeOctaveOutput()
#
#            if self._sendToOctaveListBox.GetString(self._sendToOctaveListBox.GetSelection()) == "Y":
#                self._pythonShell.Execute("octave.push('y', self.getYActual())")
#                self._analizeOctaveOutput()
#
#            if self._sendToOctaveListBox.GetString(self._sendToOctaveListBox.GetSelection()) == "Original X":
#                self._pythonShell.Execute("octave.push('xoriginal', self.getXOriginal())")
#                self._analizeOctaveOutput()
#
#            if self._sendToOctaveListBox.GetString(self._sendToOctaveListBox.GetSelection()) == "Original Y":
#                self._pythonShell.Execute("octave.push('yoriginal', self.getYOriginal())")
#                self._analizeOctaveOutput()
        except Exception as e:
                self._expData.writeexception(e)

    def _octaveInput(self):
        if self.dataUpdateToOctave:
            try:
                self._sendToOctave()
            except Exception as e:
                self._expData.writeexception(e)
        self._expData.printoutput("Sending commands to octave.")
        text = self._octaveInputTextCtrl.GetLineText(0)
        self._octaveInputTextCtrl.Clear()
        self._pythonShell.Execute('octave.eval("'+text+'", nout=1)')
        self._analizeOctaveOutput(True)

    def _octaveInput_command(self, value):
        if self.dataUpdateToOctave:
            try:
                self._sendToOctave()
            except Exception as e:
                self._expData.writeexception(e)
        self._expData.printoutput("Sending commands to octave.")
        self._pythonShell.Execute('octave.eval("'+value+'", nout=1)')
        self._analizeOctaveOutput(True)

    def _xFromOctave(self, x):
        self._expData.printoutput("Receiving x from octave.")
        self._pythonShell.Execute("self.xOctave = octave.pull('"+x+"')")
        self._analizeOctaveOutput(True)
        self.xOctave = self.xOctave[0]
        #self._xOctChange = True

    def _yFromOctave(self, y):
        self._expData.printoutput("Receiving y from octave.")
        self._pythonShell.Execute("self.yOctave = octave.pull('"+y+"')")
        self._analizeOctaveOutput(True)
        self.yOctave = self.yOctave[0]
        #self._xOctChange = True

    def _octaveReplot(self):

        self._leftpanel.Hide()
        self._rightpanel.Hide()
        self.retrieveFromOctavePanel.Show()

        self._xFromOctaveLabelTextCtrl.SetFocus()

#        with gui.ReplotFromOctave(None, title='Change Color Depth') as cdDialog:
#            print ("********************Estoy en el dialogo!")
#            if cdDialog.ShowModal() == 1:
#                print ("********************Entre en el continue!")
#                if not cdDialog._xFromOctaveTextCtrl.GetLineText(0) == "":
#                    self._xFromOctave(cdDialog._xFromOctaveTextCtrl.GetLineText(0))
#                else:
#                    self.xOctave = np.array(None)
#                if not cdDialog._yFromOctaveTextCtrl.GetLineText(0) == "":
#                    self._yFromOctave(cdDialog._yFromOctaveTextCtrl.GetLineText(0))
#                else:
#                    self.yOctave = np.array(None)
#                status = True
#            else:
#                status = False
#
#        cdDialog.Destroy()

    def _continueRetrieveFromOctave(self):

        if not self._xFromOctaveTextCtrl.GetLineText(0) == "":
            self._xFromOctave(self._xFromOctaveTextCtrl.GetLineText(0))
        else:
            self.xOctave = np.array(None)
        if not self._yFromOctaveTextCtrl.GetLineText(0) == "":
            self._yFromOctave(self._yFromOctaveTextCtrl.GetLineText(0))
        else:
            self.yOctave = np.array(None)

        x = self.getXOctave()
        y = self.getYOctave()

        if x.any()==None or y.any()==None:
            self._expData.writeinfo("The two arrays from Octave has not been retrieved.")
            wx.MessageBox("The two arrays from Octave has not been retrieved. You must to complete the 'Name of x array' text box and the 'Name of y array' text box, located before the 'Refresh Plot' button.",
                          'Information', wx.OK | wx.ICON_INFORMATION)
        else:
            self._setXName(self._xFromOctaveTextCtrl.GetLineText(0))
            self._setYName(self._yFromOctaveTextCtrl.GetLineText(0))

            self.replot2D(x, y)
            self.setXActual(x)
            self.setYActual(y)

        self._xFromOctaveTextCtrl.Clear()
        self._yFromOctaveTextCtrl.Clear()
#        self._leftpanel.Show()
#        self._rightpanel.Show()
#        self.retrieveFromOctavePanel.Hide()
        self._absPosTextCtrl.SetFocus()

    def _retrieveFromOctave_command(self, value):

        cut = value.find(',')
        value1 = value[:cut]
        value2 = value[cut+1:]
        print(value1)
        print(value2)

        if not value1 == "":
            self._xFromOctave(value1)
        else:
            self.xOctave = np.array(None)
        if not value2 == "":
            self._yFromOctave(value2)
        else:
            self.yOctave = np.array(None)

        x = self.getXOctave()
        y = self.getYOctave()

        if x.any()==None or y.any()==None:
            self._expData.writeinfo("The two arrays from Octave has not been retrieved.")
            wx.MessageBox("The two arrays from Octave has not been retrieved. You must to complete the 'Name of x array' text box and the 'Name of y array' text box, located before the 'Refresh Plot' button.",
                          'Information', wx.OK | wx.ICON_INFORMATION)
        else:
            self._setXName(value1)
            self._setYName(value2)

            self.replot2D(x, y)
            self.setXActual(x)
            self.setYActual(y)

        self._absPosTextCtrl.SetFocus()

    # def addPathToOctave(self):
    #     path = self._openData.get_m_dirpath()
    #     self._pythonShell.Execute('octave.addpath("'+path+'")')

    # def octave_loadmfunc_command(self):
    #     path, self.octavefuncfilename = self._openData.get_m_filepath()
    #     path='C:/Users/johi-/Desktop'
    #     self._pythonShell.Execute('octave.addpath("'+path+'")')
    #     #self._pythonShell.Execute('out = octave.'+filename[:-2]+'()')
    #     self._analizeOctaveOutput()
        
    # def octave_mfunc_command(self, value):
    #     self._pythonShell.Execute('out = octave.'+value+')')
    #     self._analizeOctaveOutput()
        
    # def octave_mfile_command(self):
    #     path, filename = self._openData.get_m_filepath()
    #     #path='C:/Users/johi-/Desktop'
    #     try:
    #         with open(path, "r") as f:
    #             list_lines = f.readlines()
    #             for line in list_lines:
    #                 cut = line.find("%")
    #                 self._pythonShell.Execute('octave.eval("'+line[:cut]+'", nout=1)')
    #                 self._analizeOctaveOutput()
                    
    #     except Exception as e:
    #         self._expData.writeexception(e)
    #         wx.MessageBox("An error occurred while trying to run the M file in Octave.",
    #                       'Information', wx.OK | wx.ICON_INFORMATION)

    def _setspecialsoundconfig(self):
        self._dataSound.reproductor.set_adsr(
            self.getsoundattack(),
            self.getsounddecay(),
            self.getsoundsustain(),
            self.getsoundrelease()
            )

    def _check_adr(self):
        a = self._soundattackslider.GetValue()/100
        d = self._sounddecayslider.GetValue()/100
        r = self._soundreleaseslider.GetValue()/100
        if a+d+r>1:
            return False
        else:
            return True

    def plotsoundenvelope(self):
        self._axesenvelopegraph.cla()
        #self._envelopefigure.canvas.draw()
        env = self._dataSound.reproductor.get_envelope()
        n_samples = np.arange(0.0, env.size)
        self.setenvelope(env)
        self._axesenvelopegraph.plot(n_samples, env)
        self._envelopefigure.tight_layout()
        self._envelopefigure.canvas.draw()

#Displays configs!!!
    #Muestra o esconde el panel de la grilla con los botones correspondientes.
    def displayGridChoice(self):
        if self._gridChoice.IsChecked():
            self._plotGridPanel.Show()
            self.panel.grid(color=self._getGridColor(), linestyle=self._getGridLinestyle(), linewidth=self._getGridLinewidth())
            self._figure.tight_layout()
            self._figure.canvas.draw()
            self._splotgridoptionmenuitem.Check(True)
        else:
            self._plotGridPanel.Hide()
            self.panel.grid(False)
            self._splotgridoptionmenuitem.Check(False)
        self.SendSizeEvent()
    #Muestra o esconde el panel File con los botones correspondientes.
    def displayGFile(self):
        if self._filepanel.IsShown():
            self._filepanel.Hide()
            # self._fileToggleBtn.SetLabel("Show File")
            # self._fileToggleBtn.SetValue(False)
            self._cpfilemenuitem.Check(False)
            self.SendSizeEvent()
        else:
            self._filepanel.Show()
            # self._fileToggleBtn.SetLabel("Hide File")
            # self._fileToggleBtn.SetValue(True)
            self._cpfilemenuitem.Check(True)
            self.SendSizeEvent()
    #Muestra o esconde el panel Configuraciones, sin preocuparse por los paneles de sonido y gráfico porque contiene los toggle buttons.
    def displayGConfig(self):
        if self._congifpanel.IsShown():
            self._congifpanel.Hide()
            # self._configToggleBtn.SetLabel("Show Configuration")
            # self._configToggleBtn.SetValue(False)
            self._cpcallmenuitem.Check(False)
            self.SendSizeEvent()
        else:
            self._congifpanel.Show()
            # self._configToggleBtn.SetLabel("Hide Configuration")
            # self._configToggleBtn.SetValue(True)
            self._cpcallmenuitem.Check(True)
            self.SendSizeEvent()
    #Muestra o esconde el panel Display, es suficiente porque no se esconde ningún elemento de este panel.
    def displayData(self):
        if self._displaypanel.IsShown():
            self._displaypanel.Hide()
            # self._displayToggleBtn.SetLabel("Show Data Display")
            # self._displayToggleBtn.SetValue(False)
            self._cpdatadisplaymenuitem.Check(False)
            self.SendSizeEvent()
            if self._mainrightsizer.IsRowGrowable(0):
                self._mainrightsizer.RemoveGrowableRow(0)
        else:
            if not self._mainrightsizer.IsRowGrowable(0):
                self._mainrightsizer.AddGrowableRow(0)
            self._displaypanel.Show()
            # self._displayToggleBtn.SetLabel("Hide Data Display")
            # self._displayToggleBtn.SetValue(True)
            self._cpdatadisplaymenuitem.Check(True)
            self._absPosTextCtrl.SetFocus()
            self.SendSizeEvent()

    def displayDataOp(self):
        if not self._cpdataopmenuitem.IsChecked(): #self._operationpanel.IsShown():
            self._operationpanel.Hide()
            self._cpdataopmenuitem.Check(False)
            self._writecommandpanel.Hide()
            self._cpdo_writecommandmenuitem.Check(False)
            self._gnuOctavePanel.Hide()
            self._cpdooctavemenuitem.Check(False)
            self._sizersMFPanel.Hide()
            self._cpdocutslidermenuitem.Check(False)
            # self._gnuOctavePanel.Show()
            # self.displayOctave()
            # self._sizersMFPanel.Show()
            # self.displayFunctions()
            # self._writecommandpanel.Show()
            # self.displayWritefunc()
        else:
            self._operationpanel.Show()
            self._cpdataopmenuitem.Check(True)
            self._writecommandpanel.Show()
            self._cpdo_writecommandmenuitem.Check(True)
            self._gnuOctavePanel.Show()
            self._cpdooctavemenuitem.Check(True)
            self._sizersMFPanel.Show()
            self._cpdocutslidermenuitem.Check(True)
            # self._gnuOctavePanel.Hide()
            # self.displayOctave()
            # self._sizersMFPanel.Hide()
            # self.displayFunctions()
            # self._writecommandpanel.Hide()
            # self.displayWritefunc()
        self.SendSizeEvent()

    def displayWritefunc(self):
        if self._writecommandpanel.IsShown():
            self._writecommandpanel.Hide()
            self._cpdo_writecommandmenuitem.Check(False)
            if not self._sizersMFPanel.IsShown() and self._gnuOctavePanel.IsShown():
                self._operationpanel.Hide()
                if self._cpdataopmenuitem.IsChecked():
                    self._cpdataopmenuitem.Check(False)
            else:
                if self._cpdataopmenuitem.IsChecked():
                    self._cpdataopmenuitem.Check(False)
        else:
            self._operationpanel.Show()
            if self._sizersMFPanel.IsShown() and self._gnuOctavePanel.IsShown():
                self._cpdataopmenuitem.Check(True)
            self._writecommandpanel.Show()
            self._cpdo_writecommandmenuitem.Check(True)
        self.SendSizeEvent()

    def displayOctave(self):
        if self._gnuOctavePanel.IsShown():
            self._gnuOctavePanel.Hide()
            # self._octaveToggleBtn.SetLabel("Show Octave Operation")
            # self._octaveToggleBtn.SetValue(False)
            self._cpdooctavemenuitem.Check(False)
            if not self._sizersMFPanel.IsShown() and self._writecommandpanel.IsShown():
                self._operationpanel.Hide()
                if self._cpdataopmenuitem.IsChecked():
                    self._cpdataopmenuitem.Check(False)
            else:
                if self._cpdataopmenuitem.IsChecked():
                    self._cpdataopmenuitem.Check(False)
        else:
            self._operationpanel.Show()
            if self._sizersMFPanel.IsShown() and self._writecommandpanel.IsShown():
                self._cpdataopmenuitem.Check(True)
            self._gnuOctavePanel.Show()
            # self._octaveToggleBtn.SetLabel("Hide Octave Operation")
            # self._octaveToggleBtn.SetValue(True)
            self._cpdooctavemenuitem.Check(True)
        self.SendSizeEvent()

    def displayFunctions(self):
        if self._sizersMFPanel.IsShown():
            self._sizersMFPanel.Hide()
            # self._sliderToggleBtn.SetLabel("Show Sliders and Math Functions")
            # self._sliderToggleBtn.SetValue(False)
            self._cpdocutslidermenuitem.Check(False)
            if not self._gnuOctavePanel.IsShown() and self._writecommandpanel.IsShown():
                self._operationpanel.Hide()
                if self._cpdataopmenuitem.IsChecked():
                    self._cpdataopmenuitem.Check(False)
            else:
                if self._cpdataopmenuitem.IsChecked():
                    self._cpdataopmenuitem.Check(False)
        else:
            self._operationpanel.Show()
            if self._gnuOctavePanel.IsShown() and self._writecommandpanel.IsShown():
                self._cpdataopmenuitem.Check(True)
            self._sizersMFPanel.Show()
            # self._sliderToggleBtn.SetLabel("Hide Sliders and Math Functions")
            # self._sliderToggleBtn.SetValue(True)
            self._cpdocutslidermenuitem.Check(True)
        self.SendSizeEvent()

    def displaySoundFontConfig (self):
        if self._soundFontPanel.IsShown():
            self._soundFontPanel.Hide()
            self._configSoundToggleBtn.SetLabel("Show Sound\nConfigurations")
            self._configSoundToggleBtn.SetValue(False)
            self._cpconfigsoundmenuitem.Check(False)
        else:
            self._congifpanel.Show()
            # self._configToggleBtn.SetLabel("Hide Configuration")
            # self._configToggleBtn.SetValue(True)
            self._cpcallmenuitem.Check(True)
            self._soundFontPanel.Show()
            self._configSoundToggleBtn.SetLabel("Hide Sound\nConfigurations")
            self._configSoundToggleBtn.SetValue(True)
            self._cpconfigsoundmenuitem.Check(True)
        self.SendSizeEvent()

    def linvslog_soundscale(self):
        if self._linvslog_soundscale_togglebtn.GetValue():
            #Set logarithmic
            self._linvslog_soundscale_togglebtn.SetLabel('Set linear scale')
            self._linvslog_soundscale_togglebtn.SetValue(True)
            self._linvslog_soundscale_display_togglebtn.SetLabel('Set linear scale')
            self._linvslog_soundscale_display_togglebtn.SetValue(True)
            self._slinscale_menuitem.Check(False)
            self._slogscale_menuitem.Check(True)
            self._dataSound.reproductor.set_logscale(True)
        else:
            #Set linear
            self._linvslog_soundscale_togglebtn.SetLabel('Set logarithmic scale')
            self._linvslog_soundscale_togglebtn.SetValue(False)
            self._linvslog_soundscale_display_togglebtn.SetLabel('Set logarithmic scale')
            self._linvslog_soundscale_display_togglebtn.SetValue(False)
            self._slinscale_menuitem.Check(True)
            self._slogscale_menuitem.Check(False)
            self._dataSound.reproductor.set_logscale(False)
        self.SendSizeEvent()
        
    def linvslog_soundscale_display(self):
        if self._linvslog_soundscale_display_togglebtn.GetValue():
            #Set logarithmic
            self._linvslog_soundscale_togglebtn.SetLabel('Set linear scale')
            self._linvslog_soundscale_togglebtn.SetValue(True)
            self._linvslog_soundscale_display_togglebtn.SetLabel('Set linear scale')
            self._linvslog_soundscale_display_togglebtn.SetValue(True)
            self._slinscale_menuitem.Check(False)
            self._slogscale_menuitem.Check(True)
            self._dataSound.reproductor.set_logscale(True)
        else:
            #Set linear
            self._linvslog_soundscale_togglebtn.SetLabel('Set logarithmic scale')
            self._linvslog_soundscale_togglebtn.SetValue(False)
            self._linvslog_soundscale_display_togglebtn.SetLabel('Set logarithmic scale')
            self._linvslog_soundscale_display_togglebtn.SetValue(False)
            self._slinscale_menuitem.Check(True)
            self._slogscale_menuitem.Check(False)
            self._dataSound.reproductor.set_logscale(False)
        self.SendSizeEvent()

    def setlinsoundscale(self):
        if self._slinscale_menuitem.IsChecked():
            #Set linear
            self._linvslog_soundscale_togglebtn.SetLabel('Set logarithmic scale')
            self._linvslog_soundscale_togglebtn.SetValue(False)
            self._linvslog_soundscale_display_togglebtn.SetLabel('Set logarithmic scale')
            self._linvslog_soundscale_display_togglebtn.SetValue(False)
            self._slogscale_menuitem.Check(False)
            #self.dataSound.reproductor.()
        else:
            #Set logarithmic
            self._linvslog_soundscale_togglebtn.SetLabel('Set linear scale')
            self._linvslog_soundscale_togglebtn.SetValue(True)
            self._linvslog_soundscale_display_togglebtn.SetLabel('Set linear scale')
            self._linvslog_soundscale_display_togglebtn.SetValue(True)
            self._slogscale_menuitem.Check(True)
            #self.dataSound.reproductor.()
        self.SendSizeEvent()

    def setlogsoundscale(self):
        if self._slogscale_menuitem.IsChecked():
            #Set logarithmic
            self._linvslog_soundscale_togglebtn.SetLabel('Set linear scale')
            self._linvslog_soundscale_togglebtn.SetValue(True)
            self._linvslog_soundscale_display_togglebtn.SetLabel('Set linear scale')
            self._linvslog_soundscale_display_togglebtn.SetValue(True)
            self._slinscale_menuitem.Check(False)
            #self.dataSound.reproductor.()
        else:
            #Set linear
            self._linvslog_soundscale_togglebtn.SetLabel('Set logarithmic scale')
            self._linvslog_soundscale_togglebtn.SetValue(False)
            self._linvslog_soundscale_display_togglebtn.SetLabel('Set logarithmic scale')
            self._linvslog_soundscale_display_togglebtn.SetValue(False)
            self._slinscale_menuitem.Check(True)
            #self.dataSound.reproductor.()
        self.SendSizeEvent()

    def cont_vs_discrete_sound(self):
        if self._contdiscsoundToggleBtn.GetValue():
            #Set continuous
            self._contdiscsoundToggleBtn.SetLabel("Set discrete sound")
            self._contdiscsoundToggleBtn.SetValue(True)
            self._contdiscsound_display_ToggleBtn.SetLabel("Set discrete sound")
            self._contdiscsound_display_ToggleBtn.SetValue(True)
            self._scontmenuitem.Check(True)
            self._sdiscretemenuitem.Check(False)
            self._dataSound.reproductor.set_continuous()
        else:
            #Set discrete
            self._contdiscsoundToggleBtn.SetLabel("Set continuous sound")
            self._contdiscsoundToggleBtn.SetValue(False)
            self._contdiscsound_display_ToggleBtn.SetLabel("Set continuous sound")
            self._contdiscsound_display_ToggleBtn.SetValue(False)
            self._scontmenuitem.Check(False)
            self._sdiscretemenuitem.Check(True)
            self._dataSound.reproductor.set_discrete()
        self.SendSizeEvent()
        
    def cont_vs_discrete_sound_display(self):
        if self._contdiscsound_display_ToggleBtn.GetValue():
            #Set continuous
            self._contdiscsoundToggleBtn.SetLabel("Set discrete sound")
            self._contdiscsoundToggleBtn.SetValue(True)
            self._contdiscsound_display_ToggleBtn.SetLabel("Set discrete sound")
            self._contdiscsound_display_ToggleBtn.SetValue(True)
            self._scontmenuitem.Check(True)
            self._sdiscretemenuitem.Check(False)
            self._dataSound.reproductor.set_continuous()
        else:
            #Set discrete
            self._contdiscsoundToggleBtn.SetLabel("Set continuous sound")
            self._contdiscsoundToggleBtn.SetValue(False)
            self._contdiscsound_display_ToggleBtn.SetLabel("Set continuous sound")
            self._contdiscsound_display_ToggleBtn.SetValue(False)
            self._scontmenuitem.Check(False)
            self._sdiscretemenuitem.Check(True)
            self._dataSound.reproductor.set_discrete()
        self.SendSizeEvent()

    def setcontsound(self):
        if self._scontmenuitem.IsChecked():
            #Set continuous
            self._contdiscsoundToggleBtn.SetLabel("Set discrete sound")
            self._contdiscsoundToggleBtn.SetValue(True)
            self._contdiscsound_display_ToggleBtn.SetLabel("Set discrete sound")
            self._contdiscsound_display_ToggleBtn.SetValue(True)
            # self._scontmenuitem.Check(True)
            self._sdiscretemenuitem.Check(False)
            self._dataSound.reproductor.set_continuous()
        else:
            #Set discrete
            self._contdiscsoundToggleBtn.SetLabel("Set continuous sound")
            self._contdiscsoundToggleBtn.SetValue(False)
            self._contdiscsound_display_ToggleBtn.SetLabel("Set continuous sound")
            self._contdiscsound_display_ToggleBtn.SetValue(False)
            # self._scontmenuitem.Check(False)
            self._sdiscretemenuitem.Check(True)
            self._dataSound.reproductor.set_discrete()
        self.SendSizeEvent()

    def setdiscretesound(self):
        if self._sdiscretemenuitem.IsChecked():
            #Set discrete
            self._contdiscsoundToggleBtn.SetLabel("Set continuous sound")
            self._contdiscsoundToggleBtn.SetValue(False)
            self._contdiscsound_display_ToggleBtn.SetLabel("Set continuous sound")
            self._contdiscsound_display_ToggleBtn.SetValue(False)
            self._scontmenuitem.Check(False)
            # self._sdiscretemenuitem.Check(True)
            self._dataSound.reproductor.set_discrete()
        else:
            #Set continuous
            self._contdiscsoundToggleBtn.SetLabel("Set discrete sound")
            self._contdiscsoundToggleBtn.SetValue(True)
            self._contdiscsound_display_ToggleBtn.SetLabel("Set discrete sound")
            self._contdiscsound_display_ToggleBtn.SetValue(True)
            self._scontmenuitem.Check(True)
            # self._sdiscretemenuitem.Check(False)
            self._dataSound.reproductor.set_continuous()
        self.SendSizeEvent()

    def displayfreqmapping(self):
        if self._freqmappingCheckBox.IsChecked():
            self._freqmappingPanel.Show()
            self._volmappingCheckBox.SetValue(False)
            self._volmappingPanel.Hide()
            self._ssvolmappingmenuitem.Check(False)
            self._ssfreqmappingmenuitem.Check(True)
        else:
            self._freqmappingPanel.Hide()
            self._volmappingCheckBox.SetValue(True)
            self._volmappingPanel.Show()
            self._ssvolmappingmenuitem.Check(True)
            self._ssfreqmappingmenuitem.Check(False)
        self.SendSizeEvent()

    def displayfreqmapping_menuitem(self):
        if self._ssfreqmappingmenuitem.IsChecked():
            self._freqmappingPanel.Show()
            self._volmappingCheckBox.SetValue(False)
            self._volmappingPanel.Hide()
            self._ssvolmappingmenuitem.Check(False)
            self._freqmappingCheckBox.SetValue(True)
        else:
            self._freqmappingPanel.Hide()
            self._volmappingCheckBox.SetValue(True)
            self._volmappingPanel.Show()
            self._ssvolmappingmenuitem.Check(True)
            self._freqmappingCheckBox.SetValue(False)
        self.SendSizeEvent()

    def displayvolmapping(self):
        if self._volmappingCheckBox.IsChecked():
            self._freqmappingPanel.Hide()
            self._freqmappingCheckBox.SetValue(False)
            self._volmappingPanel.Show()
            self._ssfreqmappingmenuitem.Check(False)
            self._ssvolmappingmenuitem.Check(True)
        else:
            self._freqmappingPanel.Show()
            self._freqmappingCheckBox.SetValue(True)
            self._volmappingPanel.Hide()
            self._ssfreqmappingmenuitem.Check(True)
            self._ssvolmappingmenuitem.Check(False)
        self.SendSizeEvent()

    def displayvolmapping_menuitem(self):
        if self._ssvolmappingmenuitem.IsChecked():
            self._freqmappingPanel.Hide()
            self._freqmappingCheckBox.SetValue(False)
            self._volmappingPanel.Show()
            self._ssfreqmappingmenuitem.Check(False)
            self._volmappingCheckBox.SetValue(True)
        else:
            self._freqmappingPanel.Show()
            self._freqmappingCheckBox.SetValue(True)
            self._volmappingPanel.Hide()
            self._ssfreqmappingmenuitem.Check(True)
            self._volmappingCheckBox.SetValue(False)
        self.SendSizeEvent()

    def displayPlotConfig(self):
        if self._configPlotPanel.IsShown():
            self._configPlotPanel.Hide()
            self._configPlotToggleBtn.SetLabel("Show Plot\nConfigurations")
            self._configPlotToggleBtn.SetValue(False)
            self._cpconfigplotmenuitem.Check(False)
        else:
            self._congifpanel.Show()
            # self._configToggleBtn.SetLabel("Hide Configuration")
            # self._configToggleBtn.SetValue(True)
            self._cpcallmenuitem.Check(True)
            self._configPlotPanel.Show()
            self._configPlotToggleBtn.SetLabel("Hide Plot\nConfigurations")
            self._configPlotToggleBtn.SetValue(True)
            self._cpconfigplotmenuitem.Check(True)
        self.SendSizeEvent()

    def displayVisualConfig(self):
        #under construction
        self.SendSizeEvent()

    def displayDataParamPanel(self):
        if self._openPanel.IsShown():
            self._openPanel.Hide()
            #self._dataParamPlotToggleBtn.SetValue( False )
            self._cpdataparamplotmenuitem.Check(False)
        else:
            self._openPanel.Show()
            #self._dataParamPlotToggleBtn.SetValue( True )
            self._cpdataparamplotmenuitem.Check(True)
        self._displaypanel.SendSizeEvent()

    def displayspecialsoundconfig(self):
        if self._ssspecialconfigmenuitem.IsChecked():
            self._congifpanel.Show()
            self.displaySoundFontConfig()
            # self._configToggleBtn.SetLabel("Hide Configuration")
            # self._configToggleBtn.SetValue(True)
            # self._cpcallmenuitem.Check(True)
            self._specialsoundcongifpanel.Show()
            # self._specialConfigSoundToggleBtn.SetValue(True)
            # self._specialConfigSoundToggleBtn.SetLabel("Hide Special Sound\nConfigurations")
            self._ssspecialconfigmenuitem.Check(True)
            self._envelope_checkbox.SetValue(True)
            self._soundattacktextctrl.SetFocus()
        else:
            self._specialsoundcongifpanel.Hide()
            # self._specialConfigSoundToggleBtn.SetValue(False)
            # self._specialConfigSoundToggleBtn.SetLabel("Show Special Sound\nConfigurations")
            self._ssspecialconfigmenuitem.Check(False)
            self._envelope_checkbox.SetValue(False)
            self._envelope_checkbox.SetFocus()
        self.SendSizeEvent()

    def displayenvelopegraph(self):
        if self._envelopegraphpanel.IsShown():
            self._envelopegraphpanel.Hide()
            self._envelopegraphtogglebtn.SetValue(False)
            self._envelopegraphtogglebtn.SetLabel('Show envelope\nplot')
        else:
            self._envelopegraphpanel.Show()
            self._envelopegraphtogglebtn.SetValue(True)
            self._envelopegraphtogglebtn.SetLabel('Hide envelope\nplot')
        self.SendSizeEvent()

    def soundFontSelect(self):
        self._soundFontPanel.Hide()
        self.displaySoundFontConfig()
        # self._soundFontTextCtrl.SetFocus()

    def panelSSInstSelect(self):
        self._soundFontPanel.Hide()
        self.displaySoundFontConfig()
        self._soundwaveformtextctrl.SetFocus()

    def lineStyleSelect(self):
        self._configPlotPanel.Hide()
        self.displayPlotConfig()
        self._lineStileTextCtrl.SetFocus()

    def markerStyleSelect(self):
        self._configPlotPanel.Hide()
        self.displayPlotConfig()
        self._markerTextCtrl.SetFocus()

    def colorStyleSelect(self):
        self._configPlotPanel.Hide()
        self.displayPlotConfig()
        self._colorTextCtrl.SetFocus()

    def gridOpSelect(self):
        self._configPlotPanel.Hide()
        self.displayPlotConfig()
        self._gridChoice.SetFocus()

#Eventos!!!
    #De aquí en adelante están los eventos derivados de la clase design_origin.py
    def _onclose(self, event):
        self.Close()

    def _eventabout( self, event ):
        message = "SonoUno is a Sonification Software for astronomical data in two column files. \n\nThis software is being developed by Bioing. Johanna Casado on her PhD tesis framework, under direction of Dr. Beatriz García. With general collaboration of Dr. Wanda Diaz Merced, and the collaboration on software development of Aldana Palma and Bioing. Julieta Carricondo Robino.\n\nThe email contact of the SonoUno team is: sonounoteam@gmail.com"
        wx.MessageBox(message, 'Information', wx.OK | wx.ICON_INFORMATION)

    def _eventmanual( self, event ):
        # message = "The user manual of the software is located in the software root folder in PDF format, or in the next link (copy and paste on the browser): \n"
        # url = "https://drive.google.com/file/d/1RtI1bG5Q-PjpT3LBcmWJfW88YfbqCCg1/view?usp=sharing"
        # dialogs.scrolledMessageDialog(parent=self, message=message+url, title='Information', pos=wx.DefaultPosition, size=(500, 150))
        webbrowser.open("http://sion.frm.utn.edu.ar/sonoUno/", new=2, autoraise=True)

    def _eventclose( self, event ):
#        try:
#            text = self._pythonShell.GetText()
#            #text.encode('utf-8')
#            self._expData.printoutput("Python console text: \n" + text.encode('utf-8'))
#        except Exception as e:
#            self._expData.writeexception(e)
        self._timer.Stop()
        self._timer_envelope.Stop()
        if self._fileSaved: #cambiar a 'if not' para que pregunte cuando no ha sido salvado.
            if wx.MessageBox("The file has not been saved... continue closing?",
                                 "Please confirm",
                                 wx.ICON_QUESTION | wx.YES_NO, self) != wx.YES:
                return
            else:
                event.Skip()
        else:
            event.Skip()

    def _eventopen( self, event ):
        self._expData.printoutput("Open button pressed.")
        self.openMethod()

    def _eventTitleEdData( self, event ):
        self._expData.printoutput("Enter key pressed on the text box of data title.")
        self.titleEdData()

    def _eventdatagridpage(self, event):
        self._expData.printoutput("The display page of the grid was changed.")
        #Escribir set y get para esta variable
        if self.getXActual().any()==None:
            self._expData.writeinfo("The data has not been imported yet.")
        else:
            self._actualgridpagetextctrl.SetValue(str(self._datagridslider.GetValue()))
            if self.originaldataselected:
                self._setdatagridpage(self._datagridslider.GetValue())
            else:
                self.dataGridUpdate()
        event.Skip()

    def _eventAskLabelData( self, event ):
        self._expData.printoutput("The check box to set if the data have the labels on the fisrt row, is selected.")
        self.askLabelData()

    def _eventAddGridChanges( self, event ):
        self._expData.printoutput("Apply changes button of the grid is pressed.")
        self.dataGridChange()

    def _eventUpdateGrid( self, event ):
        self._expData.printoutput("Update button of the grid is pressed.")
        self.originaldataselected = False
        self.dataGridUpdate()

    def _eventOriginalGrid( self, event ):
        self._expData.printoutput("Original Array button of the grid is pressed.")
        self.originaldataselected = True
        self._setdatagridpage(self._datagridslider.GetValue())
        # self.dataGridOriginal()

    def _eventAxisChoiceX( self, event ):
        self._expData.printoutput("A new choice on the X axis is selected.")
        self.axisChoiceXMethod()

    def _eventAxisChoiceY( self, event ):
        self._expData.printoutput("A new choice on the Y axis is selected.")
        self.axisChoiceYMethod()

    def _eventdeleteallmark( self, event ):
        self._expData.printoutput("Delete all marks button is pressed.")
        self.deleteAllMark()

    def _eventsaveplot( self, event ):
        self._expData.printoutput("Export Plot button is pressed.")
        self.savePlot()

    def _eventsavesound( self, event ):
        self._expData.printoutput("Export Sound button is pressed.")
        self.eSound()

    def _eventplay( self, event ):
        self.playMethod()

#    def _eventPause( self, event ):
#        self._expData.printoutput("Pause button is pressed.")
#        self._dataSound.make_sound(0, -1)
#        self._timer.Stop()

    def _eventstop( self, event ):
        self._expData.printoutput("Stop button is pressed.")
        self.stopMethod()

    def _eventmarkpoint( self, event ):
        self._expData.printoutput("Mark point button is pressed.")
        self.markPoints()

    def _eventdeletelastmark( self, event ):
        self._expData.printoutput("Delete last mark button is pressed.")
        self.deleteLastMark()

    def _eventcpdataparamplot( self, event ):
        self.displayDataParamPanel()

    def _eventsavedata( self, event ):
        self._expData.printoutput("Export Data button is pressed.")
        self.saveData()

    def _eventsavemarks( self, event ):
        self._expData.printoutput("Export Points button is pressed.")
        self.saveMarks()

    def _eventAbsPos( self, event ):
        self._expData.printoutput("Position Slider Bar is modified.")
        self._setTimerIndex(self._abspos_slider.GetValue())
        if self.getXActual().any()==None:
            self._expData.writeinfo("The data has not been imported yet.")
            self._abspos_slider.SetValue(0)
        else:
            self._absposlabel_textctrl.SetValue(str(round(self.getXActual()[self._abspos_slider.GetValue()],4)))
            self.absPosSetting()
        event.Skip()

    def _eventabsposition(self, event):
        value=(self._absposlabel_textctrl.GetLineText(0))
        self.xposition_command(value)
        event.Skip()

    def _eventtempoposition(self, event):
        value = (self._tempoposlabel_textctrl.GetLineText(0))
        self.selecttempo_command(value)
        event.Skip()

    def _eventSoundVel( self, event ):
        self._expData.printoutput("Sound Velocity Slider Bar is modified.")
        self._tempoposlabel_textctrl.SetValue(str(self._soundVelSlider.GetValue()))
        self._setVelocity(self._soundVelSlider.GetValue())
        self.tempo()

#    def _eventLVLimitSlider( self, event ):
#        self._expData.printoutput("Horizontal lower limit is setted.")
#        self.cutVertical()

#    def _eventUVLimitSlider( self, event ):
#        self._expData.printoutput("Horizontal upper limit is setted.")
#        self.cutVertical()

    def _eventLHLimitSlider( self, event ):
        self._expData.printoutput("Horizontal lower limit is setted.")
        self.cutHorizontal()

    def _eventUHLimitSlider( self, event ):
        self._expData.printoutput("Horizontal upper limit is setted.")
        self.cutHorizontal()

    def _eventConfigSound(self, event):
        self._expData.printoutput("Event configuration sound is setted.")
        self.displaySoundFontConfig()

    def _event_linvslog_soundscalechoice(self, event):
        self.linvslog_soundscale()
        event.Skip()
        
    def _event_linvslog_soundscalechoice_display(self, event):
        self.linvslog_soundscale_display()
        event.Skip()

    def _eventcontdiscsoundchoice(self, event):
        self.cont_vs_discrete_sound()
        event.Skip()
    
    def _eventcontdiscsoundchoice_display(self, event):
        self.cont_vs_discrete_sound_display()
        event.Skip()

    def _eventsoundvolumn(self, event):
        self._expData.printoutput("Event sound volume is setted.")
        # self.set_soundvolumn(self._soundvolumnslider.GetValue())
        self._dataSound.reproductor.set_volume(self._soundvolumnslider.GetValue())

    def _eventshow_soundfreqmin(self, event):
        if self._soundfreqmin_checkbox.IsChecked():
            self._soundfreqmin_panel.Show()
        else:
            self._soundfreqmin_panel.Hide()
        self.SendSizeEvent()
        event.Skip()

    def _eventsoundfreqmin(self, event):
        self._expData.printoutput("Event sound min frequency is setted.")
        value = (int(self._minsoundfreqmintextctrl.GetLineText(0))
            + self._soundfreqminslider.GetValue())
        self._actualsoundfreqmintextctrl.SetValue(str(value))
        self._dataSound.reproductor.set_min_freq(value)
        event.Skip()
        
    def _eventshow_soundfreqmax(self, event):
        if self._soundfreqmax_checkbox.IsChecked():
            self._soundfreqmax_panel.Show()
        else:
            self._soundfreqmax_panel.Hide()
        self.SendSizeEvent()
        event.Skip()

    def _eventsoundfreqmax(self, event):
        self._expData.printoutput("Event sound max frequency is setted.")
        value = (int(self._minsoundfreqmaxtextctrl.GetLineText(0))
            + self._soundfreqmaxslider.GetValue())
        self._actualsoundfreqmaxtextctrl.SetValue(str(value))
        self._dataSound.reproductor.set_max_freq(value)
        event.Skip()

    def _eventfreqmapping(self, event):
        self.displayfreqmapping()
        self._dataSound.reproductor.set_mapping('frequency')
        event.Skip()

    def _eventvolmapping(self, event):
        self.displayvolmapping()
        self._dataSound.reproductor.set_mapping('volume')
        event.Skip()
        
    def _eventshow_soundvolmin(self, event):
        if self._soundvolmin_checkbox.IsChecked():
            self._soundvolmin_panel.Show()
        else:
            self._soundvolmin_panel.Hide()
        self.SendSizeEvent()
        event.Skip()

    def _eventsoundvolmin(self, event):
        value = self._soundvolminslider.GetValue()
        self._actualsoundvolmintextctrl.SetValue(str(value))
        self._dataSound.reproductor.set__volume(value)
        event.Skip()
        
    def _eventshow_soundvolmax(self, event):       
        if self._soundvolmax_checkbox.IsChecked():
            self._soundvolmax_panel.Show()
        else:
            self._soundvolmax_panel.Hide()
        self.SendSizeEvent()
        event.Skip()

    def _eventsoundvolmax(self, event):
        value = self._soundvolmaxslider.GetValue()
        self._actualsoundvolmaxtextctrl.SetValue(str(value))
        self._dataSound.reproductor.set_max_volume(value)
        event.Skip()
        
    def _eventshow_soundvolfreq(self, event):
        if self._soundvolfreq_checkbox.IsChecked():
            self._soundvolfreq_panel.Show()
        else:
            self._soundvolfreq_panel.Hide()
        self.SendSizeEvent()
        event.Skip()

    def _eventsoundvolfreq(self, event):
        self._expData.printoutput("Event frequency of volume mapping is setted.")
        value = (int(self._minsoundvolfreqtextctrl.GetLineText(0))
                 + self._soundvolfreq_slider.GetValue())
        self._actualsoundvolfreq_textctrl.SetValue(str(value))
        self._dataSound.reproductor.set_fixed_freq(value)
        event.Skip()

    def _eventswaveform(self, event):
        self._expData.printoutput("Event select waveform choice on the main display is setted.")
        self.swaveformlistboxchoice()
    
    def _eventshowenvelope(self, event):
        if self._envelope_checkbox.GetValue():
            self._specialsoundcongifpanel.Show()
            self._ssspecialconfigmenuitem.Check(True)
        else:
            self._specialsoundcongifpanel.Hide()
            self._ssspecialconfigmenuitem.Check(False)
        self.SendSizeEvent()
        event.Skip()

    def _eventsoundattack(self, event):
        if not self._check_adr():
            value = float(self._actualattacktextctrl.GetValue())
            self._soundattackslider.SetValue(100*value)

        self._expData.printoutput("Event sound envelope attack is setted.")
        value = self._soundattackslider.GetValue()/100
        self._actualattacktextctrl.SetValue(str(value))
        self.setsoundattack(value)
        self._setspecialsoundconfig()
        self.plotsoundenvelope()
        event.Skip()

    def _eventsounddecay(self, event):
        if not self._check_adr():
            value = float(self._actualdecaytextctrl.GetValue())
            self._sounddecayslider.SetValue(100*value)
        self._expData.printoutput("Event sound envelope decay is setted.")
        value = self._sounddecayslider.GetValue()/100
        self._actualdecaytextctrl.SetValue(str(value))
        self.setsounddecay(value)
        self._setspecialsoundconfig()
        self.plotsoundenvelope()
        event.Skip()

    def _eventsoundsustain(self, event):
        self._expData.printoutput("Event sound envelope sustain is setted.")
        value = self._soundsustainslider.GetValue()
        self._actualsustaintextctrl.SetValue(str(value))
        self.setsoundsustain(value)
        self._setspecialsoundconfig()
        self.plotsoundenvelope()
        event.Skip()

    def _eventsoundrelease(self, event):
        if not self._check_adr():
            value = float(self._actualreleasetextctrl.GetValue())
            self._soundreleaseslider.SetValue(100*value)
        self._expData.printoutput("Event sound envelope release is setted.")
        value = self._soundreleaseslider.GetValue()/100
        self._actualreleasetextctrl.SetValue(str(value))
        self.setsoundrelease(value)
        self._setspecialsoundconfig()
        self.plotsoundenvelope()
        event.Skip()

    def _eventSpecialSoundConfig( self, event ):
        self.displayspecialsoundconfig()
        event.Skip()

    def _eventenvelopegraph(self, event):
        self.displayenvelopegraph()
        event.Skip()
        
    def _eventenvelopeplay(self, event):
        if self._envelopeplaytogglebtn.GetValue():
            #play the sound
            self._envelopeplaytogglebtn.SetLabel('Stop envelope\nsound')
            self._playenvelope()
        else:
            #Stop the sound
            self._envelopeplaytogglebtn.SetLabel('Play envelope\nsound')
            if self._timer_envelope.IsRunning():
                self._timer_envelope.Stop()
                self._settimerenvelopeindex(0)

    def _eventGFile(self, event):
        self._expData.printoutput("Event File Panel is setted.")
        self.displayGFile()

    def _eventGConfig(self, event):
        self._expData.printoutput("Event Config Panel is setted.")
        self.displayGConfig()

    def _eventGDisplay(self, event):
        self._expData.printoutput("Event data display is setted.")
        self.displayData()

    def _eventOctaveToggle( self, event ):
        self._expData.printoutput("Event octave panel is setted.")
        self.displayOctave()

    def _eventSliderToggle( self, event ):
        self._expData.printoutput("Event cut sliders panel is setted.")
        self.displayFunctions()

    def _eventMatFc(self, event):
        self._expData.printoutput("Event mathematical function is setted.")
        self.matFcSelection()

    def _eventAvNPoints(self, event):
        self._expData.printoutput("Event average number of points is setted.")
        self._setavNPoints(self._avNPointsspinCtrl.GetValue())
        self.matFcExecutor()

    def _eventlastcutmf(self, event):
        self._avNPointsspinCtrl.Enable(False)
        self._expData.printoutput("Last limits cut function is selected.")
        self._setMatSelection("Last limits cut")
        self.matFcExecutor()

    def _eventoriginalmf(self, event):
        self._avNPointsspinCtrl.Enable(False)
        self._expData.printoutput("Original function is selected.")
        self._setMatSelection("Original")
        self.matFcExecutor()

    def _eventinversemf(self, event):
        self._avNPointsspinCtrl.Enable(False)
        self._expData.printoutput("Inverse function is selected.")
        self._setMatSelection("Inverse")
        self.matFcExecutor()

#    def _eventMFPlayBack(self, event):
#        self._avNPointsspinCtrl.Enable(False)
#        self._expData.printoutput("Play Backward function is selected.")
#        self._setMatSelection("Play Backward")
#        self.matFcExecutor()

    def _eventsquaremf(self, event):
        self._avNPointsspinCtrl.Enable(False)
        self._expData.printoutput("Square function is selected.")
        self._setMatSelection("Square")
        self.matFcExecutor()

    def _eventsquarerootmf( self, event ):
        self._avNPointsspinCtrl.Enable(False)
        self._expData.printoutput("Square root function is selected.")
        self._setMatSelection("Square root")
        self.matFcExecutor()

    def _eventlogmf(self, event):
        self._avNPointsspinCtrl.Enable(False)
        self._expData.printoutput("Logarithm function is selected.")
        self._setMatSelection("Logarithm")
        self.matFcExecutor()

    def _eventaveragemf(self, event):
        self._sizersMFPanel.Hide()
        self.displayFunctions()
        self._expData.printoutput("Average function is selected.")
        self._avNPointsspinCtrl.SetValue(1)
        self._avNPointsspinCtrl.Enable(True)
        self.averageSelect()

    def _eventabsposselect(self, event):
        self._expData.printoutput("Set the focus on the abscisa position.")
        self._displaypanel.Hide()
        self.displayData()
        self._absPosTextCtrl.SetFocus()

    def _eventtemposelect(self, event):
        self._expData.printoutput("Set the focus on the tempo.")
        self._displaypanel.Hide()
        self.displayData()
        self._soundVelTextCtrl.SetFocus()

#    def _eventvlowerlimitselect(self, event):
#        self._expData.printoutput("Set the focus on the vertical lower limit.")
#        self._sizersMFPanel.Hide()
#        self.displayFunctions()
#        self._lvLimitTextCtrl.SetFocus()

#    def _eventvupperlimitselect(self, event):
#        self._expData.printoutput("Set the focus on the vertical upper limit.")
#        self._sizersMFPanel.Hide()
#        self.displayFunctions()
#        self._uvLimitTextCtrl.SetFocus()

    def _eventhlowerlimitselect(self, event):
        self._expData.printoutput("Set the focus on the horizontal lower limit.")
        self._sizersMFPanel.Hide()
        self.displayFunctions()
        self._lhLimitTextCtrl.SetFocus()

    def _eventhupperlimitselect(self, event):
        self._expData.printoutput("Set the focus on the horizontal upper limit.")
        self._sizersMFPanel.Hide()
        self.displayFunctions()
        self._uhLimitTextCtrl.SetFocus()

    def _eventavnumpointselect(self, event):
        self._expData.printoutput("The average function is selected.")
        self._sizersMFPanel.Hide()
        self.displayFunctions()
        self._avNPointsTextCtrl.SetFocus()
        self._avNPointsspinCtrl.SetValue(1)
        self._avNPointsspinCtrl.Enable(True)
        self.averageSelect()

    def _eventoctaveselect(self, event):
        self._expData.printoutput("The octave output was selected.")
        self._gnuOctavePanel.Hide()
        self.displayOctave()
        self._pythonShell.SetFocus()
#
    def _eventsswaveformselect(self, event):
        self._expData.printoutput("The waveform select on panel was selected.")
        self.panelSSInstSelect()

    def _eventcpfileselect(self, event):
        self._expData.printoutput("The panel file was selected.")
        self.displayGFile()
        self._openButton.SetFocus()

    def _eventcpdatadisplayselect(self, event):
        self._expData.printoutput("The panel data display was selected.")
        self.displayData()
        self._absPosTextCtrl.SetFocus()

    def _eventcpdataopselect(self, event):
        self._expData.printoutput("The panel data operation was selected.")
        self.displayDataOp()
        self._pythonShell.SetFocus()

    def _eventcpdo_writecommandselect(self, event):
        self._expData.printoutput("The panel write functionalities was selected.")
        self.displayWritefunc()
        self._writecommandtextctrl.SetFocus()
        event.Skip()

    def _eventcpdooctaveselect( self, event ):
        self._expData.printoutput("The panel octave was selected.")
        self.displayOctave()
        self._pythonShell.SetFocus()

    def _eventcpdocutsliderselect( self, event ):
        self._expData.printoutput("The panel sliders and mathematical functions was selected.")
        self.displayFunctions()
#        self._vAxisTextCtrl.SetFocus()

    def _eventcpcallselect(self, event):
        self._expData.printoutput("The panel configurations was selected.")
        self.displayGConfig()
        self._configSoundToggleBtn.SetFocus()

    def _eventcpconfigsoundselect(self, event):
        self._expData.printoutput("The panel configuration sound was selected.")
        self.displaySoundFontConfig()
        self._configSoundToggleBtn.SetFocus()

    def _eventcpconfigplotselect(self, event):
        self._expData.printoutput("The panel configuration plot was selected.")
        self.displayPlotConfig()
        self._configPlotToggleBtn.SetFocus()

    def _eventcpconfigvisualselect(self, event):
        self._expData.printoutput("The panel configuration visual was selected.\nUNDER CONSTRUCTION.")
        self.displayVisualConfig()
##Set focus cuando se generen los objetos

    def _eventlinsoundscalechoice(self, event):
        self.setlinsoundscale()
        event.Skip()

    def _eventlogsoundscalechoice(self, event):
        self.setlogsoundscale()
        event.Skip()

    def _eventcontsoundchoice(self, event):
        self.setcontsound()
        event.Skip()

    def _eventdiscsoundchoice(self, event):
        self.setdiscretesound()
        event.Skip()

    def _eventssvolumeselect( self, event ):
        self._expData.printoutput("The volume button was selected.")
        #Cambiar para setear el volumen
        self.soundFontSelect()
        self._volumeTextCtrl.SetFocus()
        event.Skip()

    def _eventssfreqmappingselect(self, event):
        self._expData.printoutput("The frequency mapping was selected.")
        self.soundFontSelect()
        self.displayfreqmapping_menuitem()
        self._soundfreqmintextctrl.SetFocus()
        event.Skip()

    def _eventssvolmappingselect(self, event):
        self._expData.printoutput("The volume mapping was selected.")
        self.soundFontSelect()
        self.displayvolmapping_menuitem()
        self._soundvolmintextctrl.SetFocus()
        event.Skip()

    def _eventConfigPlot( self, event ):
        self._expData.printoutput("Plot configurations panel was modified.")
        self.displayPlotConfig()
        self._configPlotToggleBtn.SetFocus()

    def _eventLineStyleConfig( self, event ):
        self._expData.printoutput("Line style of the plot was modified.")
        index = self._lineStyleChoice.GetSelection()
        self.lineStyleConfig(index)

    def _eventMarkerStyleConfig( self, event ):
        self._expData.printoutput("Marker style of the plot was modified.")
        self._setMarkerStyleIndex(self._markerStyleChoice.GetSelection())
        self.markerStyleConfig()

    def _eventColorStyleConfig( self, event ):
        self._expData.printoutput("Color style of the plot was modified.")
        index = self._colorStyleChoice.GetSelection()
        self.colorStyleConfig(index)

    def _eventsplotlineselect( self, event ):
        self._expData.printoutput("The line style configuration is selected.")
        self.lineStyleSelect()

    def _eventsplotmarkerselect( self, event ):
        self._expData.printoutput("The line marker style configuration is selected.")
        self.markerStyleSelect()

    def _eventsplotcolorselect( self, event ):
        self._expData.printoutput("The line color style configuration is selected.")
        self.colorStyleSelect()

    def _eventsplotgridoptionselect( self, event ):
        self._expData.printoutput("The grid option configurations is selected.")
        self.gridOpSelect()
        if self._gridChoice.IsChecked():
            self._gridChoice.SetValue(False)
        else:
            self._gridChoice.SetValue(True)
        self.displayGridChoice()

    def _eventGridChoice( self, event ):
        self._expData.printoutput("The grid check box is selected.")
        self.displayGridChoice()

    def _eventGridColorChoice( self, event ):
        self._expData.printoutput("The grid color style is modified.")
        self._setGridColor(self._gridColorChoice.GetString(self._gridColorChoice.GetSelection()))
        self.displayGridChoice()

    def _eventGridLineChoice( self, event ):
        self._expData.printoutput("The grid line style is modified.")
        self._setGridLinestyle(self._gridLineChoice.GetString(self._gridLineChoice.GetSelection()))
        self.displayGridChoice()

    def _eventGridWidthSpinCtrl( self, event ):
        self._expData.printoutput("The grid width is modified.")
        self._setGridLinewidth(self._gridWidthSpinCtrl.GetValue())
        self.displayGridChoice()

#    def _eventSendToOctave( self, event ):
#        #Evento que envía atributo seleccionado a octave
#        self._sendToOctave()

    def _eventOctaveReplot( self, event ):
        #Evento que resetea la session de octave
        self._octaveReplot()

    def _eventContinueReplotFromOctave( self, event ):
        self._continueRetrieveFromOctave()

    def _eventCloseReplotFromOctave( self, event ):
        self._leftpanel.Show()
        self._rightpanel.Show()
        self.retrieveFromOctavePanel.Hide()

    def _eventwritecommand(self, event):
        self._expData.printoutput("One command was introduced.")
        self.detectcommand()
        event.Skip()

    def _eventXFromOctave( self, event ):
        #event.Skip()
        #Evento que trae x array desde octave
        self._xFromOctave()

    def _eventYFromOctave( self, event ):
        #event.Skip()
        #Evento que trae y array desde octave
        self._yFromOctave()

    def _eventOctaveInput( self, event ):
        #Evento que envía comandos a octave
        self._octaveInput()

#Se conservan por si llega a surgir un error, se ha duplicado este código por uno de los merge realizados.
#    def _eventabout( self, event ):
#        message = "SonoUno is a Sonification Software for astronomical data in two column files. \n\nThis software is being developed by Bioing. Johanna Casado on her PhD tesis framework, under direction of Dr. Beatriz García. With general collaboration of Dr. Wanda Diaz Merced, and the collaboration on software development of Aldana Palma and Bioing. Julieta Carricondo Robino.\n\nThe email contact of the SonoUno team is: sonounoteam@gmail.com"
#        wx.MessageBox(message, 'Information', wx.OK | wx.ICON_INFORMATION)
#
#    def _eventmanual( self, event ):
#        message = "The user manual of the software is located in the software root folder in PDF format, or in the next link (copy and paste on the browser): \n"
#        url = "https://docs.google.com/document/d/11_mTYgqX7OdgvkuxYaXB6G3Hd4U0YRFLd9mjISAO688/edit?usp=sharing"
#        dialogs.scrolledMessageDialog(parent=self, message=message+url, title='Information', pos=wx.DefaultPosition, size=(500, 150))

if __name__ == "__main__":
    app = wx.App()
    frame = core()
    frame.Show()
    app.MainLoop()
